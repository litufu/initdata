// Code generated by Prisma (prisma@1.24.0). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  advertisement: (where?: AdvertisementWhereInput) => Promise<boolean>;
  area: (where?: AreaWhereInput) => Promise<boolean>;
  bootCount: (where?: BootCountWhereInput) => Promise<boolean>;
  city: (where?: CityWhereInput) => Promise<boolean>;
  classGroup: (where?: ClassGroupWhereInput) => Promise<boolean>;
  classMate: (where?: ClassMateWhereInput) => Promise<boolean>;
  colleague: (where?: ColleagueWhereInput) => Promise<boolean>;
  collegeEntranceExam: (
    where?: CollegeEntranceExamWhereInput
  ) => Promise<boolean>;
  company: (where?: CompanyWhereInput) => Promise<boolean>;
  family: (where?: FamilyWhereInput) => Promise<boolean>;
  familyGroup: (where?: FamilyGroupWhereInput) => Promise<boolean>;
  feeSetting: (where?: FeeSettingWhereInput) => Promise<boolean>;
  findPassWord: (where?: FindPassWordWhereInput) => Promise<boolean>;
  group: (where?: GroupWhereInput) => Promise<boolean>;
  groupMessage: (where?: GroupMessageWhereInput) => Promise<boolean>;
  location: (where?: LocationWhereInput) => Promise<boolean>;
  locationGroup: (where?: LocationGroupWhereInput) => Promise<boolean>;
  logs: (where?: LogsWhereInput) => Promise<boolean>;
  loveMatching: (where?: LoveMatchingWhereInput) => Promise<boolean>;
  loveSetting: (where?: LoveSettingWhereInput) => Promise<boolean>;
  loveSignUp: (where?: LoveSignUpWhereInput) => Promise<boolean>;
  major: (where?: MajorWhereInput) => Promise<boolean>;
  message: (where?: MessageWhereInput) => Promise<boolean>;
  oldColleague: (where?: OldColleagueWhereInput) => Promise<boolean>;
  partnerCondition: (where?: PartnerConditionWhereInput) => Promise<boolean>;
  person: (where?: PersonWhereInput) => Promise<boolean>;
  photo: (where?: PhotoWhereInput) => Promise<boolean>;
  post: (where?: PostWhereInput) => Promise<boolean>;
  product: (where?: ProductWhereInput) => Promise<boolean>;
  project: (where?: ProjectWhereInput) => Promise<boolean>;
  province: (where?: ProvinceWhereInput) => Promise<boolean>;
  regStatus: (where?: RegStatusWhereInput) => Promise<boolean>;
  registerCount: (where?: RegisterCountWhereInput) => Promise<boolean>;
  school: (where?: SchoolWhereInput) => Promise<boolean>;
  schoolEdu: (where?: SchoolEduWhereInput) => Promise<boolean>;
  skill: (where?: SkillWhereInput) => Promise<boolean>;
  station: (where?: StationWhereInput) => Promise<boolean>;
  street: (where?: StreetWhereInput) => Promise<boolean>;
  trade: (where?: TradeWhereInput) => Promise<boolean>;
  university: (where?: UniversityWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  village: (where?: VillageWhereInput) => Promise<boolean>;
  work: (where?: WorkWhereInput) => Promise<boolean>;
  workGroup: (where?: WorkGroupWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  advertisement: (where: AdvertisementWhereUniqueInput) => AdvertisementPromise;
  advertisements: (
    args?: {
      where?: AdvertisementWhereInput;
      orderBy?: AdvertisementOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Advertisement>;
  advertisementsConnection: (
    args?: {
      where?: AdvertisementWhereInput;
      orderBy?: AdvertisementOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => AdvertisementConnectionPromise;
  area: (where: AreaWhereUniqueInput) => AreaPromise;
  areas: (
    args?: {
      where?: AreaWhereInput;
      orderBy?: AreaOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Area>;
  areasConnection: (
    args?: {
      where?: AreaWhereInput;
      orderBy?: AreaOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => AreaConnectionPromise;
  bootCount: (where: BootCountWhereUniqueInput) => BootCountPromise;
  bootCounts: (
    args?: {
      where?: BootCountWhereInput;
      orderBy?: BootCountOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<BootCount>;
  bootCountsConnection: (
    args?: {
      where?: BootCountWhereInput;
      orderBy?: BootCountOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => BootCountConnectionPromise;
  city: (where: CityWhereUniqueInput) => CityPromise;
  cities: (
    args?: {
      where?: CityWhereInput;
      orderBy?: CityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<City>;
  citiesConnection: (
    args?: {
      where?: CityWhereInput;
      orderBy?: CityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CityConnectionPromise;
  classGroup: (where: ClassGroupWhereUniqueInput) => ClassGroupPromise;
  classGroups: (
    args?: {
      where?: ClassGroupWhereInput;
      orderBy?: ClassGroupOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ClassGroup>;
  classGroupsConnection: (
    args?: {
      where?: ClassGroupWhereInput;
      orderBy?: ClassGroupOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ClassGroupConnectionPromise;
  classMate: (where: ClassMateWhereUniqueInput) => ClassMatePromise;
  classMates: (
    args?: {
      where?: ClassMateWhereInput;
      orderBy?: ClassMateOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ClassMate>;
  classMatesConnection: (
    args?: {
      where?: ClassMateWhereInput;
      orderBy?: ClassMateOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ClassMateConnectionPromise;
  colleague: (where: ColleagueWhereUniqueInput) => ColleaguePromise;
  colleagues: (
    args?: {
      where?: ColleagueWhereInput;
      orderBy?: ColleagueOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Colleague>;
  colleaguesConnection: (
    args?: {
      where?: ColleagueWhereInput;
      orderBy?: ColleagueOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ColleagueConnectionPromise;
  collegeEntranceExam: (
    where: CollegeEntranceExamWhereUniqueInput
  ) => CollegeEntranceExamPromise;
  collegeEntranceExams: (
    args?: {
      where?: CollegeEntranceExamWhereInput;
      orderBy?: CollegeEntranceExamOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<CollegeEntranceExam>;
  collegeEntranceExamsConnection: (
    args?: {
      where?: CollegeEntranceExamWhereInput;
      orderBy?: CollegeEntranceExamOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CollegeEntranceExamConnectionPromise;
  company: (where: CompanyWhereUniqueInput) => CompanyPromise;
  companies: (
    args?: {
      where?: CompanyWhereInput;
      orderBy?: CompanyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Company>;
  companiesConnection: (
    args?: {
      where?: CompanyWhereInput;
      orderBy?: CompanyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CompanyConnectionPromise;
  family: (where: FamilyWhereUniqueInput) => FamilyPromise;
  families: (
    args?: {
      where?: FamilyWhereInput;
      orderBy?: FamilyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Family>;
  familiesConnection: (
    args?: {
      where?: FamilyWhereInput;
      orderBy?: FamilyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FamilyConnectionPromise;
  familyGroup: (where: FamilyGroupWhereUniqueInput) => FamilyGroupPromise;
  familyGroups: (
    args?: {
      where?: FamilyGroupWhereInput;
      orderBy?: FamilyGroupOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<FamilyGroup>;
  familyGroupsConnection: (
    args?: {
      where?: FamilyGroupWhereInput;
      orderBy?: FamilyGroupOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FamilyGroupConnectionPromise;
  feeSetting: (where: FeeSettingWhereUniqueInput) => FeeSettingPromise;
  feeSettings: (
    args?: {
      where?: FeeSettingWhereInput;
      orderBy?: FeeSettingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<FeeSetting>;
  feeSettingsConnection: (
    args?: {
      where?: FeeSettingWhereInput;
      orderBy?: FeeSettingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FeeSettingConnectionPromise;
  findPassWord: (where: FindPassWordWhereUniqueInput) => FindPassWordPromise;
  findPassWords: (
    args?: {
      where?: FindPassWordWhereInput;
      orderBy?: FindPassWordOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<FindPassWord>;
  findPassWordsConnection: (
    args?: {
      where?: FindPassWordWhereInput;
      orderBy?: FindPassWordOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FindPassWordConnectionPromise;
  group: (where: GroupWhereUniqueInput) => GroupPromise;
  groups: (
    args?: {
      where?: GroupWhereInput;
      orderBy?: GroupOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Group>;
  groupsConnection: (
    args?: {
      where?: GroupWhereInput;
      orderBy?: GroupOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => GroupConnectionPromise;
  groupMessage: (where: GroupMessageWhereUniqueInput) => GroupMessagePromise;
  groupMessages: (
    args?: {
      where?: GroupMessageWhereInput;
      orderBy?: GroupMessageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<GroupMessage>;
  groupMessagesConnection: (
    args?: {
      where?: GroupMessageWhereInput;
      orderBy?: GroupMessageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => GroupMessageConnectionPromise;
  location: (where: LocationWhereUniqueInput) => LocationPromise;
  locations: (
    args?: {
      where?: LocationWhereInput;
      orderBy?: LocationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Location>;
  locationsConnection: (
    args?: {
      where?: LocationWhereInput;
      orderBy?: LocationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => LocationConnectionPromise;
  locationGroup: (where: LocationGroupWhereUniqueInput) => LocationGroupPromise;
  locationGroups: (
    args?: {
      where?: LocationGroupWhereInput;
      orderBy?: LocationGroupOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<LocationGroup>;
  locationGroupsConnection: (
    args?: {
      where?: LocationGroupWhereInput;
      orderBy?: LocationGroupOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => LocationGroupConnectionPromise;
  logses: (
    args?: {
      where?: LogsWhereInput;
      orderBy?: LogsOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Logs>;
  logsesConnection: (
    args?: {
      where?: LogsWhereInput;
      orderBy?: LogsOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => LogsConnectionPromise;
  loveMatching: (where: LoveMatchingWhereUniqueInput) => LoveMatchingPromise;
  loveMatchings: (
    args?: {
      where?: LoveMatchingWhereInput;
      orderBy?: LoveMatchingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<LoveMatching>;
  loveMatchingsConnection: (
    args?: {
      where?: LoveMatchingWhereInput;
      orderBy?: LoveMatchingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => LoveMatchingConnectionPromise;
  loveSetting: (where: LoveSettingWhereUniqueInput) => LoveSettingPromise;
  loveSettings: (
    args?: {
      where?: LoveSettingWhereInput;
      orderBy?: LoveSettingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<LoveSetting>;
  loveSettingsConnection: (
    args?: {
      where?: LoveSettingWhereInput;
      orderBy?: LoveSettingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => LoveSettingConnectionPromise;
  loveSignUp: (where: LoveSignUpWhereUniqueInput) => LoveSignUpPromise;
  loveSignUps: (
    args?: {
      where?: LoveSignUpWhereInput;
      orderBy?: LoveSignUpOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<LoveSignUp>;
  loveSignUpsConnection: (
    args?: {
      where?: LoveSignUpWhereInput;
      orderBy?: LoveSignUpOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => LoveSignUpConnectionPromise;
  major: (where: MajorWhereUniqueInput) => MajorPromise;
  majors: (
    args?: {
      where?: MajorWhereInput;
      orderBy?: MajorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Major>;
  majorsConnection: (
    args?: {
      where?: MajorWhereInput;
      orderBy?: MajorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => MajorConnectionPromise;
  message: (where: MessageWhereUniqueInput) => MessagePromise;
  messages: (
    args?: {
      where?: MessageWhereInput;
      orderBy?: MessageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Message>;
  messagesConnection: (
    args?: {
      where?: MessageWhereInput;
      orderBy?: MessageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => MessageConnectionPromise;
  oldColleague: (where: OldColleagueWhereUniqueInput) => OldColleaguePromise;
  oldColleagues: (
    args?: {
      where?: OldColleagueWhereInput;
      orderBy?: OldColleagueOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<OldColleague>;
  oldColleaguesConnection: (
    args?: {
      where?: OldColleagueWhereInput;
      orderBy?: OldColleagueOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => OldColleagueConnectionPromise;
  partnerCondition: (
    where: PartnerConditionWhereUniqueInput
  ) => PartnerConditionPromise;
  partnerConditions: (
    args?: {
      where?: PartnerConditionWhereInput;
      orderBy?: PartnerConditionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<PartnerCondition>;
  partnerConditionsConnection: (
    args?: {
      where?: PartnerConditionWhereInput;
      orderBy?: PartnerConditionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PartnerConditionConnectionPromise;
  person: (where: PersonWhereUniqueInput) => PersonPromise;
  persons: (
    args?: {
      where?: PersonWhereInput;
      orderBy?: PersonOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Person>;
  personsConnection: (
    args?: {
      where?: PersonWhereInput;
      orderBy?: PersonOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PersonConnectionPromise;
  photo: (where: PhotoWhereUniqueInput) => PhotoPromise;
  photos: (
    args?: {
      where?: PhotoWhereInput;
      orderBy?: PhotoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Photo>;
  photosConnection: (
    args?: {
      where?: PhotoWhereInput;
      orderBy?: PhotoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PhotoConnectionPromise;
  post: (where: PostWhereUniqueInput) => PostPromise;
  posts: (
    args?: {
      where?: PostWhereInput;
      orderBy?: PostOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Post>;
  postsConnection: (
    args?: {
      where?: PostWhereInput;
      orderBy?: PostOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PostConnectionPromise;
  product: (where: ProductWhereUniqueInput) => ProductPromise;
  products: (
    args?: {
      where?: ProductWhereInput;
      orderBy?: ProductOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Product>;
  productsConnection: (
    args?: {
      where?: ProductWhereInput;
      orderBy?: ProductOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ProductConnectionPromise;
  project: (where: ProjectWhereUniqueInput) => ProjectPromise;
  projects: (
    args?: {
      where?: ProjectWhereInput;
      orderBy?: ProjectOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Project>;
  projectsConnection: (
    args?: {
      where?: ProjectWhereInput;
      orderBy?: ProjectOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ProjectConnectionPromise;
  province: (where: ProvinceWhereUniqueInput) => ProvincePromise;
  provinces: (
    args?: {
      where?: ProvinceWhereInput;
      orderBy?: ProvinceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Province>;
  provincesConnection: (
    args?: {
      where?: ProvinceWhereInput;
      orderBy?: ProvinceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ProvinceConnectionPromise;
  regStatus: (where: RegStatusWhereUniqueInput) => RegStatusPromise;
  regStatuses: (
    args?: {
      where?: RegStatusWhereInput;
      orderBy?: RegStatusOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<RegStatus>;
  regStatusesConnection: (
    args?: {
      where?: RegStatusWhereInput;
      orderBy?: RegStatusOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => RegStatusConnectionPromise;
  registerCount: (where: RegisterCountWhereUniqueInput) => RegisterCountPromise;
  registerCounts: (
    args?: {
      where?: RegisterCountWhereInput;
      orderBy?: RegisterCountOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<RegisterCount>;
  registerCountsConnection: (
    args?: {
      where?: RegisterCountWhereInput;
      orderBy?: RegisterCountOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => RegisterCountConnectionPromise;
  school: (where: SchoolWhereUniqueInput) => SchoolPromise;
  schools: (
    args?: {
      where?: SchoolWhereInput;
      orderBy?: SchoolOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<School>;
  schoolsConnection: (
    args?: {
      where?: SchoolWhereInput;
      orderBy?: SchoolOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SchoolConnectionPromise;
  schoolEdu: (where: SchoolEduWhereUniqueInput) => SchoolEduPromise;
  schoolEdus: (
    args?: {
      where?: SchoolEduWhereInput;
      orderBy?: SchoolEduOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<SchoolEdu>;
  schoolEdusConnection: (
    args?: {
      where?: SchoolEduWhereInput;
      orderBy?: SchoolEduOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SchoolEduConnectionPromise;
  skill: (where: SkillWhereUniqueInput) => SkillPromise;
  skills: (
    args?: {
      where?: SkillWhereInput;
      orderBy?: SkillOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Skill>;
  skillsConnection: (
    args?: {
      where?: SkillWhereInput;
      orderBy?: SkillOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SkillConnectionPromise;
  station: (where: StationWhereUniqueInput) => StationPromise;
  stations: (
    args?: {
      where?: StationWhereInput;
      orderBy?: StationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Station>;
  stationsConnection: (
    args?: {
      where?: StationWhereInput;
      orderBy?: StationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => StationConnectionPromise;
  street: (where: StreetWhereUniqueInput) => StreetPromise;
  streets: (
    args?: {
      where?: StreetWhereInput;
      orderBy?: StreetOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Street>;
  streetsConnection: (
    args?: {
      where?: StreetWhereInput;
      orderBy?: StreetOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => StreetConnectionPromise;
  trade: (where: TradeWhereUniqueInput) => TradePromise;
  trades: (
    args?: {
      where?: TradeWhereInput;
      orderBy?: TradeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Trade>;
  tradesConnection: (
    args?: {
      where?: TradeWhereInput;
      orderBy?: TradeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => TradeConnectionPromise;
  university: (where: UniversityWhereUniqueInput) => UniversityPromise;
  universities: (
    args?: {
      where?: UniversityWhereInput;
      orderBy?: UniversityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<University>;
  universitiesConnection: (
    args?: {
      where?: UniversityWhereInput;
      orderBy?: UniversityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UniversityConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<User>;
  usersConnection: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserConnectionPromise;
  village: (where: VillageWhereUniqueInput) => VillagePromise;
  villages: (
    args?: {
      where?: VillageWhereInput;
      orderBy?: VillageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Village>;
  villagesConnection: (
    args?: {
      where?: VillageWhereInput;
      orderBy?: VillageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => VillageConnectionPromise;
  work: (where: WorkWhereUniqueInput) => WorkPromise;
  works: (
    args?: {
      where?: WorkWhereInput;
      orderBy?: WorkOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Work>;
  worksConnection: (
    args?: {
      where?: WorkWhereInput;
      orderBy?: WorkOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => WorkConnectionPromise;
  workGroup: (where: WorkGroupWhereUniqueInput) => WorkGroupPromise;
  workGroups: (
    args?: {
      where?: WorkGroupWhereInput;
      orderBy?: WorkGroupOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<WorkGroup>;
  workGroupsConnection: (
    args?: {
      where?: WorkGroupWhereInput;
      orderBy?: WorkGroupOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => WorkGroupConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAdvertisement: (data: AdvertisementCreateInput) => AdvertisementPromise;
  updateAdvertisement: (
    args: {
      data: AdvertisementUpdateInput;
      where: AdvertisementWhereUniqueInput;
    }
  ) => AdvertisementPromise;
  updateManyAdvertisements: (
    args: {
      data: AdvertisementUpdateManyMutationInput;
      where?: AdvertisementWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertAdvertisement: (
    args: {
      where: AdvertisementWhereUniqueInput;
      create: AdvertisementCreateInput;
      update: AdvertisementUpdateInput;
    }
  ) => AdvertisementPromise;
  deleteAdvertisement: (
    where: AdvertisementWhereUniqueInput
  ) => AdvertisementPromise;
  deleteManyAdvertisements: (
    where?: AdvertisementWhereInput
  ) => BatchPayloadPromise;
  createArea: (data: AreaCreateInput) => AreaPromise;
  updateArea: (
    args: { data: AreaUpdateInput; where: AreaWhereUniqueInput }
  ) => AreaPromise;
  updateManyAreas: (
    args: { data: AreaUpdateManyMutationInput; where?: AreaWhereInput }
  ) => BatchPayloadPromise;
  upsertArea: (
    args: {
      where: AreaWhereUniqueInput;
      create: AreaCreateInput;
      update: AreaUpdateInput;
    }
  ) => AreaPromise;
  deleteArea: (where: AreaWhereUniqueInput) => AreaPromise;
  deleteManyAreas: (where?: AreaWhereInput) => BatchPayloadPromise;
  createBootCount: (data: BootCountCreateInput) => BootCountPromise;
  updateBootCount: (
    args: { data: BootCountUpdateInput; where: BootCountWhereUniqueInput }
  ) => BootCountPromise;
  upsertBootCount: (
    args: {
      where: BootCountWhereUniqueInput;
      create: BootCountCreateInput;
      update: BootCountUpdateInput;
    }
  ) => BootCountPromise;
  deleteBootCount: (where: BootCountWhereUniqueInput) => BootCountPromise;
  deleteManyBootCounts: (where?: BootCountWhereInput) => BatchPayloadPromise;
  createCity: (data: CityCreateInput) => CityPromise;
  updateCity: (
    args: { data: CityUpdateInput; where: CityWhereUniqueInput }
  ) => CityPromise;
  updateManyCities: (
    args: { data: CityUpdateManyMutationInput; where?: CityWhereInput }
  ) => BatchPayloadPromise;
  upsertCity: (
    args: {
      where: CityWhereUniqueInput;
      create: CityCreateInput;
      update: CityUpdateInput;
    }
  ) => CityPromise;
  deleteCity: (where: CityWhereUniqueInput) => CityPromise;
  deleteManyCities: (where?: CityWhereInput) => BatchPayloadPromise;
  createClassGroup: (data: ClassGroupCreateInput) => ClassGroupPromise;
  updateClassGroup: (
    args: { data: ClassGroupUpdateInput; where: ClassGroupWhereUniqueInput }
  ) => ClassGroupPromise;
  updateManyClassGroups: (
    args: {
      data: ClassGroupUpdateManyMutationInput;
      where?: ClassGroupWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertClassGroup: (
    args: {
      where: ClassGroupWhereUniqueInput;
      create: ClassGroupCreateInput;
      update: ClassGroupUpdateInput;
    }
  ) => ClassGroupPromise;
  deleteClassGroup: (where: ClassGroupWhereUniqueInput) => ClassGroupPromise;
  deleteManyClassGroups: (where?: ClassGroupWhereInput) => BatchPayloadPromise;
  createClassMate: (data: ClassMateCreateInput) => ClassMatePromise;
  updateClassMate: (
    args: { data: ClassMateUpdateInput; where: ClassMateWhereUniqueInput }
  ) => ClassMatePromise;
  updateManyClassMates: (
    args: {
      data: ClassMateUpdateManyMutationInput;
      where?: ClassMateWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertClassMate: (
    args: {
      where: ClassMateWhereUniqueInput;
      create: ClassMateCreateInput;
      update: ClassMateUpdateInput;
    }
  ) => ClassMatePromise;
  deleteClassMate: (where: ClassMateWhereUniqueInput) => ClassMatePromise;
  deleteManyClassMates: (where?: ClassMateWhereInput) => BatchPayloadPromise;
  createColleague: (data: ColleagueCreateInput) => ColleaguePromise;
  updateColleague: (
    args: { data: ColleagueUpdateInput; where: ColleagueWhereUniqueInput }
  ) => ColleaguePromise;
  updateManyColleagues: (
    args: {
      data: ColleagueUpdateManyMutationInput;
      where?: ColleagueWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertColleague: (
    args: {
      where: ColleagueWhereUniqueInput;
      create: ColleagueCreateInput;
      update: ColleagueUpdateInput;
    }
  ) => ColleaguePromise;
  deleteColleague: (where: ColleagueWhereUniqueInput) => ColleaguePromise;
  deleteManyColleagues: (where?: ColleagueWhereInput) => BatchPayloadPromise;
  createCollegeEntranceExam: (
    data: CollegeEntranceExamCreateInput
  ) => CollegeEntranceExamPromise;
  updateCollegeEntranceExam: (
    args: {
      data: CollegeEntranceExamUpdateInput;
      where: CollegeEntranceExamWhereUniqueInput;
    }
  ) => CollegeEntranceExamPromise;
  updateManyCollegeEntranceExams: (
    args: {
      data: CollegeEntranceExamUpdateManyMutationInput;
      where?: CollegeEntranceExamWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertCollegeEntranceExam: (
    args: {
      where: CollegeEntranceExamWhereUniqueInput;
      create: CollegeEntranceExamCreateInput;
      update: CollegeEntranceExamUpdateInput;
    }
  ) => CollegeEntranceExamPromise;
  deleteCollegeEntranceExam: (
    where: CollegeEntranceExamWhereUniqueInput
  ) => CollegeEntranceExamPromise;
  deleteManyCollegeEntranceExams: (
    where?: CollegeEntranceExamWhereInput
  ) => BatchPayloadPromise;
  createCompany: (data: CompanyCreateInput) => CompanyPromise;
  updateCompany: (
    args: { data: CompanyUpdateInput; where: CompanyWhereUniqueInput }
  ) => CompanyPromise;
  updateManyCompanies: (
    args: { data: CompanyUpdateManyMutationInput; where?: CompanyWhereInput }
  ) => BatchPayloadPromise;
  upsertCompany: (
    args: {
      where: CompanyWhereUniqueInput;
      create: CompanyCreateInput;
      update: CompanyUpdateInput;
    }
  ) => CompanyPromise;
  deleteCompany: (where: CompanyWhereUniqueInput) => CompanyPromise;
  deleteManyCompanies: (where?: CompanyWhereInput) => BatchPayloadPromise;
  createFamily: (data: FamilyCreateInput) => FamilyPromise;
  updateFamily: (
    args: { data: FamilyUpdateInput; where: FamilyWhereUniqueInput }
  ) => FamilyPromise;
  updateManyFamilies: (
    args: { data: FamilyUpdateManyMutationInput; where?: FamilyWhereInput }
  ) => BatchPayloadPromise;
  upsertFamily: (
    args: {
      where: FamilyWhereUniqueInput;
      create: FamilyCreateInput;
      update: FamilyUpdateInput;
    }
  ) => FamilyPromise;
  deleteFamily: (where: FamilyWhereUniqueInput) => FamilyPromise;
  deleteManyFamilies: (where?: FamilyWhereInput) => BatchPayloadPromise;
  createFamilyGroup: (data: FamilyGroupCreateInput) => FamilyGroupPromise;
  updateFamilyGroup: (
    args: { data: FamilyGroupUpdateInput; where: FamilyGroupWhereUniqueInput }
  ) => FamilyGroupPromise;
  updateManyFamilyGroups: (
    args: {
      data: FamilyGroupUpdateManyMutationInput;
      where?: FamilyGroupWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertFamilyGroup: (
    args: {
      where: FamilyGroupWhereUniqueInput;
      create: FamilyGroupCreateInput;
      update: FamilyGroupUpdateInput;
    }
  ) => FamilyGroupPromise;
  deleteFamilyGroup: (where: FamilyGroupWhereUniqueInput) => FamilyGroupPromise;
  deleteManyFamilyGroups: (
    where?: FamilyGroupWhereInput
  ) => BatchPayloadPromise;
  createFeeSetting: (data: FeeSettingCreateInput) => FeeSettingPromise;
  updateFeeSetting: (
    args: { data: FeeSettingUpdateInput; where: FeeSettingWhereUniqueInput }
  ) => FeeSettingPromise;
  updateManyFeeSettings: (
    args: {
      data: FeeSettingUpdateManyMutationInput;
      where?: FeeSettingWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertFeeSetting: (
    args: {
      where: FeeSettingWhereUniqueInput;
      create: FeeSettingCreateInput;
      update: FeeSettingUpdateInput;
    }
  ) => FeeSettingPromise;
  deleteFeeSetting: (where: FeeSettingWhereUniqueInput) => FeeSettingPromise;
  deleteManyFeeSettings: (where?: FeeSettingWhereInput) => BatchPayloadPromise;
  createFindPassWord: (data: FindPassWordCreateInput) => FindPassWordPromise;
  updateFindPassWord: (
    args: { data: FindPassWordUpdateInput; where: FindPassWordWhereUniqueInput }
  ) => FindPassWordPromise;
  updateManyFindPassWords: (
    args: {
      data: FindPassWordUpdateManyMutationInput;
      where?: FindPassWordWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertFindPassWord: (
    args: {
      where: FindPassWordWhereUniqueInput;
      create: FindPassWordCreateInput;
      update: FindPassWordUpdateInput;
    }
  ) => FindPassWordPromise;
  deleteFindPassWord: (
    where: FindPassWordWhereUniqueInput
  ) => FindPassWordPromise;
  deleteManyFindPassWords: (
    where?: FindPassWordWhereInput
  ) => BatchPayloadPromise;
  createGroup: (data: GroupCreateInput) => GroupPromise;
  updateGroup: (
    args: { data: GroupUpdateInput; where: GroupWhereUniqueInput }
  ) => GroupPromise;
  updateManyGroups: (
    args: { data: GroupUpdateManyMutationInput; where?: GroupWhereInput }
  ) => BatchPayloadPromise;
  upsertGroup: (
    args: {
      where: GroupWhereUniqueInput;
      create: GroupCreateInput;
      update: GroupUpdateInput;
    }
  ) => GroupPromise;
  deleteGroup: (where: GroupWhereUniqueInput) => GroupPromise;
  deleteManyGroups: (where?: GroupWhereInput) => BatchPayloadPromise;
  createGroupMessage: (data: GroupMessageCreateInput) => GroupMessagePromise;
  updateGroupMessage: (
    args: { data: GroupMessageUpdateInput; where: GroupMessageWhereUniqueInput }
  ) => GroupMessagePromise;
  updateManyGroupMessages: (
    args: {
      data: GroupMessageUpdateManyMutationInput;
      where?: GroupMessageWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertGroupMessage: (
    args: {
      where: GroupMessageWhereUniqueInput;
      create: GroupMessageCreateInput;
      update: GroupMessageUpdateInput;
    }
  ) => GroupMessagePromise;
  deleteGroupMessage: (
    where: GroupMessageWhereUniqueInput
  ) => GroupMessagePromise;
  deleteManyGroupMessages: (
    where?: GroupMessageWhereInput
  ) => BatchPayloadPromise;
  createLocation: (data: LocationCreateInput) => LocationPromise;
  updateLocation: (
    args: { data: LocationUpdateInput; where: LocationWhereUniqueInput }
  ) => LocationPromise;
  updateManyLocations: (
    args: { data: LocationUpdateManyMutationInput; where?: LocationWhereInput }
  ) => BatchPayloadPromise;
  upsertLocation: (
    args: {
      where: LocationWhereUniqueInput;
      create: LocationCreateInput;
      update: LocationUpdateInput;
    }
  ) => LocationPromise;
  deleteLocation: (where: LocationWhereUniqueInput) => LocationPromise;
  deleteManyLocations: (where?: LocationWhereInput) => BatchPayloadPromise;
  createLocationGroup: (data: LocationGroupCreateInput) => LocationGroupPromise;
  updateLocationGroup: (
    args: {
      data: LocationGroupUpdateInput;
      where: LocationGroupWhereUniqueInput;
    }
  ) => LocationGroupPromise;
  updateManyLocationGroups: (
    args: {
      data: LocationGroupUpdateManyMutationInput;
      where?: LocationGroupWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertLocationGroup: (
    args: {
      where: LocationGroupWhereUniqueInput;
      create: LocationGroupCreateInput;
      update: LocationGroupUpdateInput;
    }
  ) => LocationGroupPromise;
  deleteLocationGroup: (
    where: LocationGroupWhereUniqueInput
  ) => LocationGroupPromise;
  deleteManyLocationGroups: (
    where?: LocationGroupWhereInput
  ) => BatchPayloadPromise;
  createLogs: (data: LogsCreateInput) => LogsPromise;
  updateManyLogses: (
    args: { data: LogsUpdateManyMutationInput; where?: LogsWhereInput }
  ) => BatchPayloadPromise;
  deleteManyLogses: (where?: LogsWhereInput) => BatchPayloadPromise;
  createLoveMatching: (data: LoveMatchingCreateInput) => LoveMatchingPromise;
  updateLoveMatching: (
    args: { data: LoveMatchingUpdateInput; where: LoveMatchingWhereUniqueInput }
  ) => LoveMatchingPromise;
  updateManyLoveMatchings: (
    args: {
      data: LoveMatchingUpdateManyMutationInput;
      where?: LoveMatchingWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertLoveMatching: (
    args: {
      where: LoveMatchingWhereUniqueInput;
      create: LoveMatchingCreateInput;
      update: LoveMatchingUpdateInput;
    }
  ) => LoveMatchingPromise;
  deleteLoveMatching: (
    where: LoveMatchingWhereUniqueInput
  ) => LoveMatchingPromise;
  deleteManyLoveMatchings: (
    where?: LoveMatchingWhereInput
  ) => BatchPayloadPromise;
  createLoveSetting: (data: LoveSettingCreateInput) => LoveSettingPromise;
  updateLoveSetting: (
    args: { data: LoveSettingUpdateInput; where: LoveSettingWhereUniqueInput }
  ) => LoveSettingPromise;
  updateManyLoveSettings: (
    args: {
      data: LoveSettingUpdateManyMutationInput;
      where?: LoveSettingWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertLoveSetting: (
    args: {
      where: LoveSettingWhereUniqueInput;
      create: LoveSettingCreateInput;
      update: LoveSettingUpdateInput;
    }
  ) => LoveSettingPromise;
  deleteLoveSetting: (where: LoveSettingWhereUniqueInput) => LoveSettingPromise;
  deleteManyLoveSettings: (
    where?: LoveSettingWhereInput
  ) => BatchPayloadPromise;
  createLoveSignUp: (data: LoveSignUpCreateInput) => LoveSignUpPromise;
  updateLoveSignUp: (
    args: { data: LoveSignUpUpdateInput; where: LoveSignUpWhereUniqueInput }
  ) => LoveSignUpPromise;
  updateManyLoveSignUps: (
    args: {
      data: LoveSignUpUpdateManyMutationInput;
      where?: LoveSignUpWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertLoveSignUp: (
    args: {
      where: LoveSignUpWhereUniqueInput;
      create: LoveSignUpCreateInput;
      update: LoveSignUpUpdateInput;
    }
  ) => LoveSignUpPromise;
  deleteLoveSignUp: (where: LoveSignUpWhereUniqueInput) => LoveSignUpPromise;
  deleteManyLoveSignUps: (where?: LoveSignUpWhereInput) => BatchPayloadPromise;
  createMajor: (data: MajorCreateInput) => MajorPromise;
  updateMajor: (
    args: { data: MajorUpdateInput; where: MajorWhereUniqueInput }
  ) => MajorPromise;
  updateManyMajors: (
    args: { data: MajorUpdateManyMutationInput; where?: MajorWhereInput }
  ) => BatchPayloadPromise;
  upsertMajor: (
    args: {
      where: MajorWhereUniqueInput;
      create: MajorCreateInput;
      update: MajorUpdateInput;
    }
  ) => MajorPromise;
  deleteMajor: (where: MajorWhereUniqueInput) => MajorPromise;
  deleteManyMajors: (where?: MajorWhereInput) => BatchPayloadPromise;
  createMessage: (data: MessageCreateInput) => MessagePromise;
  updateMessage: (
    args: { data: MessageUpdateInput; where: MessageWhereUniqueInput }
  ) => MessagePromise;
  updateManyMessages: (
    args: { data: MessageUpdateManyMutationInput; where?: MessageWhereInput }
  ) => BatchPayloadPromise;
  upsertMessage: (
    args: {
      where: MessageWhereUniqueInput;
      create: MessageCreateInput;
      update: MessageUpdateInput;
    }
  ) => MessagePromise;
  deleteMessage: (where: MessageWhereUniqueInput) => MessagePromise;
  deleteManyMessages: (where?: MessageWhereInput) => BatchPayloadPromise;
  createOldColleague: (data: OldColleagueCreateInput) => OldColleaguePromise;
  updateOldColleague: (
    args: { data: OldColleagueUpdateInput; where: OldColleagueWhereUniqueInput }
  ) => OldColleaguePromise;
  updateManyOldColleagues: (
    args: {
      data: OldColleagueUpdateManyMutationInput;
      where?: OldColleagueWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertOldColleague: (
    args: {
      where: OldColleagueWhereUniqueInput;
      create: OldColleagueCreateInput;
      update: OldColleagueUpdateInput;
    }
  ) => OldColleaguePromise;
  deleteOldColleague: (
    where: OldColleagueWhereUniqueInput
  ) => OldColleaguePromise;
  deleteManyOldColleagues: (
    where?: OldColleagueWhereInput
  ) => BatchPayloadPromise;
  createPartnerCondition: (
    data: PartnerConditionCreateInput
  ) => PartnerConditionPromise;
  updatePartnerCondition: (
    args: {
      data: PartnerConditionUpdateInput;
      where: PartnerConditionWhereUniqueInput;
    }
  ) => PartnerConditionPromise;
  updateManyPartnerConditions: (
    args: {
      data: PartnerConditionUpdateManyMutationInput;
      where?: PartnerConditionWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertPartnerCondition: (
    args: {
      where: PartnerConditionWhereUniqueInput;
      create: PartnerConditionCreateInput;
      update: PartnerConditionUpdateInput;
    }
  ) => PartnerConditionPromise;
  deletePartnerCondition: (
    where: PartnerConditionWhereUniqueInput
  ) => PartnerConditionPromise;
  deleteManyPartnerConditions: (
    where?: PartnerConditionWhereInput
  ) => BatchPayloadPromise;
  createPerson: (data: PersonCreateInput) => PersonPromise;
  updatePerson: (
    args: { data: PersonUpdateInput; where: PersonWhereUniqueInput }
  ) => PersonPromise;
  updateManyPersons: (
    args: { data: PersonUpdateManyMutationInput; where?: PersonWhereInput }
  ) => BatchPayloadPromise;
  upsertPerson: (
    args: {
      where: PersonWhereUniqueInput;
      create: PersonCreateInput;
      update: PersonUpdateInput;
    }
  ) => PersonPromise;
  deletePerson: (where: PersonWhereUniqueInput) => PersonPromise;
  deleteManyPersons: (where?: PersonWhereInput) => BatchPayloadPromise;
  createPhoto: (data: PhotoCreateInput) => PhotoPromise;
  updatePhoto: (
    args: { data: PhotoUpdateInput; where: PhotoWhereUniqueInput }
  ) => PhotoPromise;
  updateManyPhotos: (
    args: { data: PhotoUpdateManyMutationInput; where?: PhotoWhereInput }
  ) => BatchPayloadPromise;
  upsertPhoto: (
    args: {
      where: PhotoWhereUniqueInput;
      create: PhotoCreateInput;
      update: PhotoUpdateInput;
    }
  ) => PhotoPromise;
  deletePhoto: (where: PhotoWhereUniqueInput) => PhotoPromise;
  deleteManyPhotos: (where?: PhotoWhereInput) => BatchPayloadPromise;
  createPost: (data: PostCreateInput) => PostPromise;
  updatePost: (
    args: { data: PostUpdateInput; where: PostWhereUniqueInput }
  ) => PostPromise;
  updateManyPosts: (
    args: { data: PostUpdateManyMutationInput; where?: PostWhereInput }
  ) => BatchPayloadPromise;
  upsertPost: (
    args: {
      where: PostWhereUniqueInput;
      create: PostCreateInput;
      update: PostUpdateInput;
    }
  ) => PostPromise;
  deletePost: (where: PostWhereUniqueInput) => PostPromise;
  deleteManyPosts: (where?: PostWhereInput) => BatchPayloadPromise;
  createProduct: (data: ProductCreateInput) => ProductPromise;
  updateProduct: (
    args: { data: ProductUpdateInput; where: ProductWhereUniqueInput }
  ) => ProductPromise;
  updateManyProducts: (
    args: { data: ProductUpdateManyMutationInput; where?: ProductWhereInput }
  ) => BatchPayloadPromise;
  upsertProduct: (
    args: {
      where: ProductWhereUniqueInput;
      create: ProductCreateInput;
      update: ProductUpdateInput;
    }
  ) => ProductPromise;
  deleteProduct: (where: ProductWhereUniqueInput) => ProductPromise;
  deleteManyProducts: (where?: ProductWhereInput) => BatchPayloadPromise;
  createProject: (data: ProjectCreateInput) => ProjectPromise;
  updateProject: (
    args: { data: ProjectUpdateInput; where: ProjectWhereUniqueInput }
  ) => ProjectPromise;
  updateManyProjects: (
    args: { data: ProjectUpdateManyMutationInput; where?: ProjectWhereInput }
  ) => BatchPayloadPromise;
  upsertProject: (
    args: {
      where: ProjectWhereUniqueInput;
      create: ProjectCreateInput;
      update: ProjectUpdateInput;
    }
  ) => ProjectPromise;
  deleteProject: (where: ProjectWhereUniqueInput) => ProjectPromise;
  deleteManyProjects: (where?: ProjectWhereInput) => BatchPayloadPromise;
  createProvince: (data: ProvinceCreateInput) => ProvincePromise;
  updateProvince: (
    args: { data: ProvinceUpdateInput; where: ProvinceWhereUniqueInput }
  ) => ProvincePromise;
  updateManyProvinces: (
    args: { data: ProvinceUpdateManyMutationInput; where?: ProvinceWhereInput }
  ) => BatchPayloadPromise;
  upsertProvince: (
    args: {
      where: ProvinceWhereUniqueInput;
      create: ProvinceCreateInput;
      update: ProvinceUpdateInput;
    }
  ) => ProvincePromise;
  deleteProvince: (where: ProvinceWhereUniqueInput) => ProvincePromise;
  deleteManyProvinces: (where?: ProvinceWhereInput) => BatchPayloadPromise;
  createRegStatus: (data: RegStatusCreateInput) => RegStatusPromise;
  updateRegStatus: (
    args: { data: RegStatusUpdateInput; where: RegStatusWhereUniqueInput }
  ) => RegStatusPromise;
  updateManyRegStatuses: (
    args: {
      data: RegStatusUpdateManyMutationInput;
      where?: RegStatusWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertRegStatus: (
    args: {
      where: RegStatusWhereUniqueInput;
      create: RegStatusCreateInput;
      update: RegStatusUpdateInput;
    }
  ) => RegStatusPromise;
  deleteRegStatus: (where: RegStatusWhereUniqueInput) => RegStatusPromise;
  deleteManyRegStatuses: (where?: RegStatusWhereInput) => BatchPayloadPromise;
  createRegisterCount: (data: RegisterCountCreateInput) => RegisterCountPromise;
  updateRegisterCount: (
    args: {
      data: RegisterCountUpdateInput;
      where: RegisterCountWhereUniqueInput;
    }
  ) => RegisterCountPromise;
  updateManyRegisterCounts: (
    args: {
      data: RegisterCountUpdateManyMutationInput;
      where?: RegisterCountWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertRegisterCount: (
    args: {
      where: RegisterCountWhereUniqueInput;
      create: RegisterCountCreateInput;
      update: RegisterCountUpdateInput;
    }
  ) => RegisterCountPromise;
  deleteRegisterCount: (
    where: RegisterCountWhereUniqueInput
  ) => RegisterCountPromise;
  deleteManyRegisterCounts: (
    where?: RegisterCountWhereInput
  ) => BatchPayloadPromise;
  createSchool: (data: SchoolCreateInput) => SchoolPromise;
  updateSchool: (
    args: { data: SchoolUpdateInput; where: SchoolWhereUniqueInput }
  ) => SchoolPromise;
  updateManySchools: (
    args: { data: SchoolUpdateManyMutationInput; where?: SchoolWhereInput }
  ) => BatchPayloadPromise;
  upsertSchool: (
    args: {
      where: SchoolWhereUniqueInput;
      create: SchoolCreateInput;
      update: SchoolUpdateInput;
    }
  ) => SchoolPromise;
  deleteSchool: (where: SchoolWhereUniqueInput) => SchoolPromise;
  deleteManySchools: (where?: SchoolWhereInput) => BatchPayloadPromise;
  createSchoolEdu: (data: SchoolEduCreateInput) => SchoolEduPromise;
  updateSchoolEdu: (
    args: { data: SchoolEduUpdateInput; where: SchoolEduWhereUniqueInput }
  ) => SchoolEduPromise;
  updateManySchoolEdus: (
    args: {
      data: SchoolEduUpdateManyMutationInput;
      where?: SchoolEduWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertSchoolEdu: (
    args: {
      where: SchoolEduWhereUniqueInput;
      create: SchoolEduCreateInput;
      update: SchoolEduUpdateInput;
    }
  ) => SchoolEduPromise;
  deleteSchoolEdu: (where: SchoolEduWhereUniqueInput) => SchoolEduPromise;
  deleteManySchoolEdus: (where?: SchoolEduWhereInput) => BatchPayloadPromise;
  createSkill: (data: SkillCreateInput) => SkillPromise;
  updateSkill: (
    args: { data: SkillUpdateInput; where: SkillWhereUniqueInput }
  ) => SkillPromise;
  updateManySkills: (
    args: { data: SkillUpdateManyMutationInput; where?: SkillWhereInput }
  ) => BatchPayloadPromise;
  upsertSkill: (
    args: {
      where: SkillWhereUniqueInput;
      create: SkillCreateInput;
      update: SkillUpdateInput;
    }
  ) => SkillPromise;
  deleteSkill: (where: SkillWhereUniqueInput) => SkillPromise;
  deleteManySkills: (where?: SkillWhereInput) => BatchPayloadPromise;
  createStation: (data: StationCreateInput) => StationPromise;
  updateStation: (
    args: { data: StationUpdateInput; where: StationWhereUniqueInput }
  ) => StationPromise;
  updateManyStations: (
    args: { data: StationUpdateManyMutationInput; where?: StationWhereInput }
  ) => BatchPayloadPromise;
  upsertStation: (
    args: {
      where: StationWhereUniqueInput;
      create: StationCreateInput;
      update: StationUpdateInput;
    }
  ) => StationPromise;
  deleteStation: (where: StationWhereUniqueInput) => StationPromise;
  deleteManyStations: (where?: StationWhereInput) => BatchPayloadPromise;
  createStreet: (data: StreetCreateInput) => StreetPromise;
  updateStreet: (
    args: { data: StreetUpdateInput; where: StreetWhereUniqueInput }
  ) => StreetPromise;
  updateManyStreets: (
    args: { data: StreetUpdateManyMutationInput; where?: StreetWhereInput }
  ) => BatchPayloadPromise;
  upsertStreet: (
    args: {
      where: StreetWhereUniqueInput;
      create: StreetCreateInput;
      update: StreetUpdateInput;
    }
  ) => StreetPromise;
  deleteStreet: (where: StreetWhereUniqueInput) => StreetPromise;
  deleteManyStreets: (where?: StreetWhereInput) => BatchPayloadPromise;
  createTrade: (data: TradeCreateInput) => TradePromise;
  updateTrade: (
    args: { data: TradeUpdateInput; where: TradeWhereUniqueInput }
  ) => TradePromise;
  updateManyTrades: (
    args: { data: TradeUpdateManyMutationInput; where?: TradeWhereInput }
  ) => BatchPayloadPromise;
  upsertTrade: (
    args: {
      where: TradeWhereUniqueInput;
      create: TradeCreateInput;
      update: TradeUpdateInput;
    }
  ) => TradePromise;
  deleteTrade: (where: TradeWhereUniqueInput) => TradePromise;
  deleteManyTrades: (where?: TradeWhereInput) => BatchPayloadPromise;
  createUniversity: (data: UniversityCreateInput) => UniversityPromise;
  updateUniversity: (
    args: { data: UniversityUpdateInput; where: UniversityWhereUniqueInput }
  ) => UniversityPromise;
  updateManyUniversities: (
    args: {
      data: UniversityUpdateManyMutationInput;
      where?: UniversityWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertUniversity: (
    args: {
      where: UniversityWhereUniqueInput;
      create: UniversityCreateInput;
      update: UniversityUpdateInput;
    }
  ) => UniversityPromise;
  deleteUniversity: (where: UniversityWhereUniqueInput) => UniversityPromise;
  deleteManyUniversities: (where?: UniversityWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (
    args: { data: UserUpdateInput; where: UserWhereUniqueInput }
  ) => UserPromise;
  updateManyUsers: (
    args: { data: UserUpdateManyMutationInput; where?: UserWhereInput }
  ) => BatchPayloadPromise;
  upsertUser: (
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    }
  ) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createVillage: (data: VillageCreateInput) => VillagePromise;
  updateVillage: (
    args: { data: VillageUpdateInput; where: VillageWhereUniqueInput }
  ) => VillagePromise;
  updateManyVillages: (
    args: { data: VillageUpdateManyMutationInput; where?: VillageWhereInput }
  ) => BatchPayloadPromise;
  upsertVillage: (
    args: {
      where: VillageWhereUniqueInput;
      create: VillageCreateInput;
      update: VillageUpdateInput;
    }
  ) => VillagePromise;
  deleteVillage: (where: VillageWhereUniqueInput) => VillagePromise;
  deleteManyVillages: (where?: VillageWhereInput) => BatchPayloadPromise;
  createWork: (data: WorkCreateInput) => WorkPromise;
  updateWork: (
    args: { data: WorkUpdateInput; where: WorkWhereUniqueInput }
  ) => WorkPromise;
  updateManyWorks: (
    args: { data: WorkUpdateManyMutationInput; where?: WorkWhereInput }
  ) => BatchPayloadPromise;
  upsertWork: (
    args: {
      where: WorkWhereUniqueInput;
      create: WorkCreateInput;
      update: WorkUpdateInput;
    }
  ) => WorkPromise;
  deleteWork: (where: WorkWhereUniqueInput) => WorkPromise;
  deleteManyWorks: (where?: WorkWhereInput) => BatchPayloadPromise;
  createWorkGroup: (data: WorkGroupCreateInput) => WorkGroupPromise;
  updateWorkGroup: (
    args: { data: WorkGroupUpdateInput; where: WorkGroupWhereUniqueInput }
  ) => WorkGroupPromise;
  upsertWorkGroup: (
    args: {
      where: WorkGroupWhereUniqueInput;
      create: WorkGroupCreateInput;
      update: WorkGroupUpdateInput;
    }
  ) => WorkGroupPromise;
  deleteWorkGroup: (where: WorkGroupWhereUniqueInput) => WorkGroupPromise;
  deleteManyWorkGroups: (where?: WorkGroupWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  advertisement: (
    where?: AdvertisementSubscriptionWhereInput
  ) => AdvertisementSubscriptionPayloadSubscription;
  area: (
    where?: AreaSubscriptionWhereInput
  ) => AreaSubscriptionPayloadSubscription;
  bootCount: (
    where?: BootCountSubscriptionWhereInput
  ) => BootCountSubscriptionPayloadSubscription;
  city: (
    where?: CitySubscriptionWhereInput
  ) => CitySubscriptionPayloadSubscription;
  classGroup: (
    where?: ClassGroupSubscriptionWhereInput
  ) => ClassGroupSubscriptionPayloadSubscription;
  classMate: (
    where?: ClassMateSubscriptionWhereInput
  ) => ClassMateSubscriptionPayloadSubscription;
  colleague: (
    where?: ColleagueSubscriptionWhereInput
  ) => ColleagueSubscriptionPayloadSubscription;
  collegeEntranceExam: (
    where?: CollegeEntranceExamSubscriptionWhereInput
  ) => CollegeEntranceExamSubscriptionPayloadSubscription;
  company: (
    where?: CompanySubscriptionWhereInput
  ) => CompanySubscriptionPayloadSubscription;
  family: (
    where?: FamilySubscriptionWhereInput
  ) => FamilySubscriptionPayloadSubscription;
  familyGroup: (
    where?: FamilyGroupSubscriptionWhereInput
  ) => FamilyGroupSubscriptionPayloadSubscription;
  feeSetting: (
    where?: FeeSettingSubscriptionWhereInput
  ) => FeeSettingSubscriptionPayloadSubscription;
  findPassWord: (
    where?: FindPassWordSubscriptionWhereInput
  ) => FindPassWordSubscriptionPayloadSubscription;
  group: (
    where?: GroupSubscriptionWhereInput
  ) => GroupSubscriptionPayloadSubscription;
  groupMessage: (
    where?: GroupMessageSubscriptionWhereInput
  ) => GroupMessageSubscriptionPayloadSubscription;
  location: (
    where?: LocationSubscriptionWhereInput
  ) => LocationSubscriptionPayloadSubscription;
  locationGroup: (
    where?: LocationGroupSubscriptionWhereInput
  ) => LocationGroupSubscriptionPayloadSubscription;
  logs: (
    where?: LogsSubscriptionWhereInput
  ) => LogsSubscriptionPayloadSubscription;
  loveMatching: (
    where?: LoveMatchingSubscriptionWhereInput
  ) => LoveMatchingSubscriptionPayloadSubscription;
  loveSetting: (
    where?: LoveSettingSubscriptionWhereInput
  ) => LoveSettingSubscriptionPayloadSubscription;
  loveSignUp: (
    where?: LoveSignUpSubscriptionWhereInput
  ) => LoveSignUpSubscriptionPayloadSubscription;
  major: (
    where?: MajorSubscriptionWhereInput
  ) => MajorSubscriptionPayloadSubscription;
  message: (
    where?: MessageSubscriptionWhereInput
  ) => MessageSubscriptionPayloadSubscription;
  oldColleague: (
    where?: OldColleagueSubscriptionWhereInput
  ) => OldColleagueSubscriptionPayloadSubscription;
  partnerCondition: (
    where?: PartnerConditionSubscriptionWhereInput
  ) => PartnerConditionSubscriptionPayloadSubscription;
  person: (
    where?: PersonSubscriptionWhereInput
  ) => PersonSubscriptionPayloadSubscription;
  photo: (
    where?: PhotoSubscriptionWhereInput
  ) => PhotoSubscriptionPayloadSubscription;
  post: (
    where?: PostSubscriptionWhereInput
  ) => PostSubscriptionPayloadSubscription;
  product: (
    where?: ProductSubscriptionWhereInput
  ) => ProductSubscriptionPayloadSubscription;
  project: (
    where?: ProjectSubscriptionWhereInput
  ) => ProjectSubscriptionPayloadSubscription;
  province: (
    where?: ProvinceSubscriptionWhereInput
  ) => ProvinceSubscriptionPayloadSubscription;
  regStatus: (
    where?: RegStatusSubscriptionWhereInput
  ) => RegStatusSubscriptionPayloadSubscription;
  registerCount: (
    where?: RegisterCountSubscriptionWhereInput
  ) => RegisterCountSubscriptionPayloadSubscription;
  school: (
    where?: SchoolSubscriptionWhereInput
  ) => SchoolSubscriptionPayloadSubscription;
  schoolEdu: (
    where?: SchoolEduSubscriptionWhereInput
  ) => SchoolEduSubscriptionPayloadSubscription;
  skill: (
    where?: SkillSubscriptionWhereInput
  ) => SkillSubscriptionPayloadSubscription;
  station: (
    where?: StationSubscriptionWhereInput
  ) => StationSubscriptionPayloadSubscription;
  street: (
    where?: StreetSubscriptionWhereInput
  ) => StreetSubscriptionPayloadSubscription;
  trade: (
    where?: TradeSubscriptionWhereInput
  ) => TradeSubscriptionPayloadSubscription;
  university: (
    where?: UniversitySubscriptionWhereInput
  ) => UniversitySubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  village: (
    where?: VillageSubscriptionWhereInput
  ) => VillageSubscriptionPayloadSubscription;
  work: (
    where?: WorkSubscriptionWhereInput
  ) => WorkSubscriptionPayloadSubscription;
  workGroup: (
    where?: WorkGroupSubscriptionWhereInput
  ) => WorkGroupSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type LoveMatchingOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "period_ASC"
  | "period_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type LocationGroupKind =
  | "HomeVillage"
  | "ResidenceVillage"
  | "VillageInResidenceVillage"
  | "StreetInResidenceVillage"
  | "AreaInResidenceVillage"
  | "CityInResidenceVillage"
  | "ProvinceInResidenceVillage"
  | "VillageInResidenceStreet"
  | "StreetInResidenceStreet"
  | "AreaInResidenceStreet"
  | "CityInResidenceStreet"
  | "ProvinceInResidenceStreet"
  | "VillageInResidenceArea"
  | "StreetInResidenceArea"
  | "AreaInResidenceArea"
  | "CityInResidenceArea"
  | "ProvinceInResidenceArea"
  | "VillageInResidenceCity"
  | "StreetInResidenceCity"
  | "AreaInResidenceCity"
  | "CityInResidenceCity"
  | "ProvinceInResidenceCity";

export type Educationkind =
  | "PrimarySchool"
  | "JuniorMiddleSchool"
  | "HighSchool"
  | "VocationalHighSchool"
  | "TechnicalSchool"
  | "SecondarySpecializedSchool"
  | "JuniorCollege"
  | "Undergraduate"
  | "Master"
  | "Doctor"
  | "JuniorToCollege"
  | "HighToCollege"
  | "HighToJunior";

export type WorkGroupOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type FindPassWordOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "times_ASC"
  | "times_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type RegisterCountOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "deviceId_ASC"
  | "deviceId_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type LocationGroupOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "kind_ASC"
  | "kind_DESC"
  | "code_ASC"
  | "code_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type RegStatusOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "education_ASC"
  | "education_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type OldColleagueOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "status_ASC"
  | "status_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ProductOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "subject_ASC"
  | "subject_DESC"
  | "info_ASC"
  | "info_DESC"
  | "price_ASC"
  | "price_DESC"
  | "kind_ASC"
  | "kind_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ClassMateOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "status_ASC"
  | "status_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PersonOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type GroupOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "type_ASC"
  | "type_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type LoveSignUpOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "period_ASC"
  | "period_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type GroupMessageOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "type_ASC"
  | "type_DESC"
  | "to_ASC"
  | "to_DESC"
  | "text_ASC"
  | "text_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type LogsOrderByInput =
  | "createFamilyGroupTime_ASC"
  | "createFamilyGroupTime_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MessageOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "text_ASC"
  | "text_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type FeeSettingOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "fee_ASC"
  | "fee_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SchoolEduOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "startTime_ASC"
  | "startTime_DESC"
  | "grade_ASC"
  | "grade_DESC"
  | "className_ASC"
  | "className_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ClassGroupOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type FamilyGroupOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type TradeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "number_ASC"
  | "number_DESC"
  | "amount_ASC"
  | "amount_DESC"
  | "status_ASC"
  | "status_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type FamilyOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "relationship_ASC"
  | "relationship_DESC"
  | "status_ASC"
  | "status_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PartnerConditionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "skillName_ASC"
  | "skillName_DESC"
  | "place_ASC"
  | "place_DESC"
  | "number_ASC"
  | "number_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PostOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "isPublished_ASC"
  | "isPublished_DESC"
  | "title_ASC"
  | "title_DESC"
  | "content_ASC"
  | "content_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type UniversityOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "education_ASC"
  | "education_DESC"
  | "department_ASC"
  | "department_DESC"
  | "location_ASC"
  | "location_DESC"
  | "desc_ASC"
  | "desc_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type AdvertisementOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "image1_ASC"
  | "image1_DESC"
  | "image2_ASC"
  | "image2_DESC"
  | "image3_ASC"
  | "image3_DESC"
  | "image4_ASC"
  | "image4_DESC"
  | "image5_ASC"
  | "image5_DESC"
  | "startTime_ASC"
  | "startTime_DESC"
  | "endTime_ASC"
  | "endTime_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ColleagueOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "status_ASC"
  | "status_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PhotoOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "url_ASC"
  | "url_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type WorkOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "startTime_ASC"
  | "startTime_DESC"
  | "endTime_ASC"
  | "endTime_DESC"
  | "department_ASC"
  | "department_DESC"
  | "jobContent_ASC"
  | "jobContent_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type LoveSettingOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "myHeight_ASC"
  | "myHeight_DESC"
  | "myWeight_ASC"
  | "myWeight_DESC"
  | "otherHeightMin_ASC"
  | "otherHeightMin_DESC"
  | "otherHeightMax_ASC"
  | "otherHeightMax_DESC"
  | "otherWeightMin_ASC"
  | "otherWeightMin_DESC"
  | "otherWeightMax_ASC"
  | "otherWeightMax_DESC"
  | "otherAgeMin_ASC"
  | "otherAgeMin_DESC"
  | "otherAgeMax_ASC"
  | "otherAgeMax_DESC"
  | "dateTime_ASC"
  | "dateTime_DESC"
  | "datePlace_ASC"
  | "datePlace_DESC"
  | "memeberGrade_ASC"
  | "memeberGrade_DESC"
  | "memeberGradeEndTime_ASC"
  | "memeberGradeEndTime_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CompanyOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "code_ASC"
  | "code_DESC"
  | "establishmentDate_ASC"
  | "establishmentDate_DESC"
  | "representative_ASC"
  | "representative_DESC"
  | "BusinessScope_ASC"
  | "BusinessScope_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CollegeEntranceExamOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "subject_ASC"
  | "subject_DESC"
  | "culscore_ASC"
  | "culscore_DESC"
  | "proscore_ASC"
  | "proscore_DESC"
  | "candidatenum_ASC"
  | "candidatenum_DESC"
  | "times_ASC"
  | "times_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SchoolOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "kind_ASC"
  | "kind_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ProjectOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "content_ASC"
  | "content_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "username_ASC"
  | "username_DESC"
  | "password_ASC"
  | "password_DESC"
  | "name_ASC"
  | "name_DESC"
  | "gender_ASC"
  | "gender_DESC"
  | "birthdaycalendar_ASC"
  | "birthdaycalendar_DESC"
  | "birthday_ASC"
  | "birthday_DESC"
  | "uid_ASC"
  | "uid_DESC"
  | "token_ASC"
  | "token_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "regTimes_ASC"
  | "regTimes_DESC"
  | "maxRegTimes_ASC"
  | "maxRegTimes_DESC";

export type StationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "code_ASC"
  | "code_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type GroupKind =
  | "Family"
  | "ClassMate"
  | "Colleague"
  | "FellowTownsman"
  | "SameCity"
  | "SameOccupation"
  | "SameDisease"
  | "RegStatus";

export type MajorOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "category_ASC"
  | "category_DESC"
  | "education_ASC"
  | "education_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CityOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "code_ASC"
  | "code_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type AreaOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "code_ASC"
  | "code_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type StreetOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "code_ASC"
  | "code_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type VillageOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "code_ASC"
  | "code_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type LocationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ProvinceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "code_ASC"
  | "code_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SkillOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type BootCountOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export interface MessageCreateManyWithoutFromInput {
  create?: MessageCreateWithoutFromInput[] | MessageCreateWithoutFromInput;
  connect?: MessageWhereUniqueInput[] | MessageWhereUniqueInput;
}

export type AdvertisementWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ColleagueCreateWithoutWorkerInput {
  status: String;
  group?: WorkGroupCreateOneWithoutColleaguesInput;
}

export interface LocationGroupWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  kind?: LocationGroupKind;
  kind_not?: LocationGroupKind;
  kind_in?: LocationGroupKind[] | LocationGroupKind;
  kind_not_in?: LocationGroupKind[] | LocationGroupKind;
  code?: String;
  code_not?: String;
  code_in?: String[] | String;
  code_not_in?: String[] | String;
  code_lt?: String;
  code_lte?: String;
  code_gt?: String;
  code_gte?: String;
  code_contains?: String;
  code_not_contains?: String;
  code_starts_with?: String;
  code_not_starts_with?: String;
  code_ends_with?: String;
  code_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  users_every?: UserWhereInput;
  users_some?: UserWhereInput;
  users_none?: UserWhereInput;
  AND?: LocationGroupWhereInput[] | LocationGroupWhereInput;
  OR?: LocationGroupWhereInput[] | LocationGroupWhereInput;
  NOT?: LocationGroupWhereInput[] | LocationGroupWhereInput;
}

export interface CompanyCreateWithoutWorkGroupInput {
  name?: String;
  code?: String;
  establishmentDate?: DateTimeInput;
  representative?: String;
  location?: LocationCreateOneWithoutCompaniesInput;
  BusinessScope?: String;
  works?: WorkCreateManyWithoutCompanyInput;
}

export interface LoveSettingWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  myHeight?: Int;
  myHeight_not?: Int;
  myHeight_in?: Int[] | Int;
  myHeight_not_in?: Int[] | Int;
  myHeight_lt?: Int;
  myHeight_lte?: Int;
  myHeight_gt?: Int;
  myHeight_gte?: Int;
  myWeight?: Int;
  myWeight_not?: Int;
  myWeight_in?: Int[] | Int;
  myWeight_not_in?: Int[] | Int;
  myWeight_lt?: Int;
  myWeight_lte?: Int;
  myWeight_gt?: Int;
  myWeight_gte?: Int;
  otherHeightMin?: Int;
  otherHeightMin_not?: Int;
  otherHeightMin_in?: Int[] | Int;
  otherHeightMin_not_in?: Int[] | Int;
  otherHeightMin_lt?: Int;
  otherHeightMin_lte?: Int;
  otherHeightMin_gt?: Int;
  otherHeightMin_gte?: Int;
  otherHeightMax?: Int;
  otherHeightMax_not?: Int;
  otherHeightMax_in?: Int[] | Int;
  otherHeightMax_not_in?: Int[] | Int;
  otherHeightMax_lt?: Int;
  otherHeightMax_lte?: Int;
  otherHeightMax_gt?: Int;
  otherHeightMax_gte?: Int;
  otherWeightMin?: Int;
  otherWeightMin_not?: Int;
  otherWeightMin_in?: Int[] | Int;
  otherWeightMin_not_in?: Int[] | Int;
  otherWeightMin_lt?: Int;
  otherWeightMin_lte?: Int;
  otherWeightMin_gt?: Int;
  otherWeightMin_gte?: Int;
  otherWeightMax?: Int;
  otherWeightMax_not?: Int;
  otherWeightMax_in?: Int[] | Int;
  otherWeightMax_not_in?: Int[] | Int;
  otherWeightMax_lt?: Int;
  otherWeightMax_lte?: Int;
  otherWeightMax_gt?: Int;
  otherWeightMax_gte?: Int;
  otherAgeMin?: Int;
  otherAgeMin_not?: Int;
  otherAgeMin_in?: Int[] | Int;
  otherAgeMin_not_in?: Int[] | Int;
  otherAgeMin_lt?: Int;
  otherAgeMin_lte?: Int;
  otherAgeMin_gt?: Int;
  otherAgeMin_gte?: Int;
  otherAgeMax?: Int;
  otherAgeMax_not?: Int;
  otherAgeMax_in?: Int[] | Int;
  otherAgeMax_not_in?: Int[] | Int;
  otherAgeMax_lt?: Int;
  otherAgeMax_lte?: Int;
  otherAgeMax_gt?: Int;
  otherAgeMax_gte?: Int;
  dateTime?: String;
  dateTime_not?: String;
  dateTime_in?: String[] | String;
  dateTime_not_in?: String[] | String;
  dateTime_lt?: String;
  dateTime_lte?: String;
  dateTime_gt?: String;
  dateTime_gte?: String;
  dateTime_contains?: String;
  dateTime_not_contains?: String;
  dateTime_starts_with?: String;
  dateTime_not_starts_with?: String;
  dateTime_ends_with?: String;
  dateTime_not_ends_with?: String;
  datePlace?: String;
  datePlace_not?: String;
  datePlace_in?: String[] | String;
  datePlace_not_in?: String[] | String;
  datePlace_lt?: String;
  datePlace_lte?: String;
  datePlace_gt?: String;
  datePlace_gte?: String;
  datePlace_contains?: String;
  datePlace_not_contains?: String;
  datePlace_starts_with?: String;
  datePlace_not_starts_with?: String;
  datePlace_ends_with?: String;
  datePlace_not_ends_with?: String;
  memeberGrade?: Int;
  memeberGrade_not?: Int;
  memeberGrade_in?: Int[] | Int;
  memeberGrade_not_in?: Int[] | Int;
  memeberGrade_lt?: Int;
  memeberGrade_lte?: Int;
  memeberGrade_gt?: Int;
  memeberGrade_gte?: Int;
  memeberGradeEndTime?: String;
  memeberGradeEndTime_not?: String;
  memeberGradeEndTime_in?: String[] | String;
  memeberGradeEndTime_not_in?: String[] | String;
  memeberGradeEndTime_lt?: String;
  memeberGradeEndTime_lte?: String;
  memeberGradeEndTime_gt?: String;
  memeberGradeEndTime_gte?: String;
  memeberGradeEndTime_contains?: String;
  memeberGradeEndTime_not_contains?: String;
  memeberGradeEndTime_starts_with?: String;
  memeberGradeEndTime_not_starts_with?: String;
  memeberGradeEndTime_ends_with?: String;
  memeberGradeEndTime_not_ends_with?: String;
  user?: UserWhereInput;
  AND?: LoveSettingWhereInput[] | LoveSettingWhereInput;
  OR?: LoveSettingWhereInput[] | LoveSettingWhereInput;
  NOT?: LoveSettingWhereInput[] | LoveSettingWhereInput;
}

export interface WorkGroupCreateInput {
  company?: CompanyCreateOneWithoutWorkGroupInput;
  colleagues?: ColleagueCreateManyWithoutGroupInput;
}

export interface LoveSignUpWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  period?: String;
  period_not?: String;
  period_in?: String[] | String;
  period_not_in?: String[] | String;
  period_lt?: String;
  period_lte?: String;
  period_gt?: String;
  period_gte?: String;
  period_contains?: String;
  period_not_contains?: String;
  period_starts_with?: String;
  period_not_starts_with?: String;
  period_ends_with?: String;
  period_not_ends_with?: String;
  city?: CityWhereInput;
  person?: UserWhereInput;
  AND?: LoveSignUpWhereInput[] | LoveSignUpWhereInput;
  OR?: LoveSignUpWhereInput[] | LoveSignUpWhereInput;
  NOT?: LoveSignUpWhereInput[] | LoveSignUpWhereInput;
}

export interface UserCreateWithoutLoveManInput {
  username: String;
  password: String;
  name?: String;
  gender?: String;
  avatar?: PhotoCreateOneWithoutUserInput;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationCreateOneWithoutBornsInput;
  residence?: LocationCreateOneWithoutLivesInput;
  uid: String;
  token: String;
  posts?: PostCreateManyWithoutAuthorInput;
  regStatus?: RegStatusCreateOneWithoutApplicantsInput;
  regTimes?: Int;
  maxRegTimes?: Int;
  families?: FamilyCreateManyWithoutFromInput;
  studies?: SchoolEduCreateManyWithoutStudentsInput;
  works?: WorkCreateManyWithoutWorkerInput;
  exam?: CollegeEntranceExamCreateOneWithoutStudentInput;
  sentMessages?: MessageCreateManyWithoutFromInput;
  receiveMessages?: MessageCreateManyWithoutToInput;
  groupMessages?: GroupMessageCreateManyWithoutFromInput;
  groups?: GroupCreateManyWithoutUsersInput;
  friends?: UserCreateManyInput;
  familyGroup?: FamilyGroupCreateOneWithoutUsersInput;
  creater?: FamilyGroupCreateOneWithoutCreaterInput;
  classMate?: ClassMateCreateManyWithoutStudentInput;
  workGroup?: WorkGroupCreateOneInput;
  colleagues?: ColleagueCreateManyWithoutWorkerInput;
  fromOldColleagues?: OldColleagueCreateManyWithoutFromInput;
  toOldColleagues?: OldColleagueCreateManyWithoutToInput;
  locationGroups?: LocationGroupCreateManyWithoutUsersInput;
  forgetPassword?: FindPassWordCreateOneWithoutForgetterInput;
  remmemberPassword?: FindPassWordCreateManyWithoutRemmemberInput;
  loveSetting?: LoveSettingCreateOneWithoutUserInput;
  loveWoman?: LoveMatchingCreateManyWithoutWomanInput;
  signUpLove?: LoveSignUpCreateOneWithoutPersonInput;
  skills?: SkillCreateManyWithoutPersonsInput;
  fitConditions?: PartnerConditionCreateManyWithoutPartnersInput;
  nofitConditions?: PartnerConditionCreateManyWithoutPassedPartnersInput;
  projects?: ProjectCreateManyWithoutStarterInput;
  trades?: TradeCreateManyWithoutUserInput;
}

export interface PartnerConditionWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  skillName?: String;
  skillName_not?: String;
  skillName_in?: String[] | String;
  skillName_not_in?: String[] | String;
  skillName_lt?: String;
  skillName_lte?: String;
  skillName_gt?: String;
  skillName_gte?: String;
  skillName_contains?: String;
  skillName_not_contains?: String;
  skillName_starts_with?: String;
  skillName_not_starts_with?: String;
  skillName_ends_with?: String;
  skillName_not_ends_with?: String;
  place?: String;
  place_not?: String;
  place_in?: String[] | String;
  place_not_in?: String[] | String;
  place_lt?: String;
  place_lte?: String;
  place_gt?: String;
  place_gte?: String;
  place_contains?: String;
  place_not_contains?: String;
  place_starts_with?: String;
  place_not_starts_with?: String;
  place_ends_with?: String;
  place_not_ends_with?: String;
  number?: Int;
  number_not?: Int;
  number_in?: Int[] | Int;
  number_not_in?: Int[] | Int;
  number_lt?: Int;
  number_lte?: Int;
  number_gt?: Int;
  number_gte?: Int;
  partners_every?: UserWhereInput;
  partners_some?: UserWhereInput;
  partners_none?: UserWhereInput;
  passedPartners_every?: UserWhereInput;
  passedPartners_some?: UserWhereInput;
  passedPartners_none?: UserWhereInput;
  project?: ProjectWhereInput;
  AND?: PartnerConditionWhereInput[] | PartnerConditionWhereInput;
  OR?: PartnerConditionWhereInput[] | PartnerConditionWhereInput;
  NOT?: PartnerConditionWhereInput[] | PartnerConditionWhereInput;
}

export type SchoolWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface TradeWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  product?: ProductWhereInput;
  number?: Int;
  number_not?: Int;
  number_in?: Int[] | Int;
  number_not_in?: Int[] | Int;
  number_lt?: Int;
  number_lte?: Int;
  number_gt?: Int;
  number_gte?: Int;
  amount?: Float;
  amount_not?: Float;
  amount_in?: Float[] | Float;
  amount_not_in?: Float[] | Float;
  amount_lt?: Float;
  amount_lte?: Float;
  amount_gt?: Float;
  amount_gte?: Float;
  user?: UserWhereInput;
  status?: String;
  status_not?: String;
  status_in?: String[] | String;
  status_not_in?: String[] | String;
  status_lt?: String;
  status_lte?: String;
  status_gt?: String;
  status_gte?: String;
  status_contains?: String;
  status_not_contains?: String;
  status_starts_with?: String;
  status_not_starts_with?: String;
  status_ends_with?: String;
  status_not_ends_with?: String;
  AND?: TradeWhereInput[] | TradeWhereInput;
  OR?: TradeWhereInput[] | TradeWhereInput;
  NOT?: TradeWhereInput[] | TradeWhereInput;
}

export interface ProductWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  subject?: String;
  subject_not?: String;
  subject_in?: String[] | String;
  subject_not_in?: String[] | String;
  subject_lt?: String;
  subject_lte?: String;
  subject_gt?: String;
  subject_gte?: String;
  subject_contains?: String;
  subject_not_contains?: String;
  subject_starts_with?: String;
  subject_not_starts_with?: String;
  subject_ends_with?: String;
  subject_not_ends_with?: String;
  info?: String;
  info_not?: String;
  info_in?: String[] | String;
  info_not_in?: String[] | String;
  info_lt?: String;
  info_lte?: String;
  info_gt?: String;
  info_gte?: String;
  info_contains?: String;
  info_not_contains?: String;
  info_starts_with?: String;
  info_not_starts_with?: String;
  info_ends_with?: String;
  info_not_ends_with?: String;
  price?: Float;
  price_not?: Float;
  price_in?: Float[] | Float;
  price_not_in?: Float[] | Float;
  price_lt?: Float;
  price_lte?: Float;
  price_gt?: Float;
  price_gte?: Float;
  kind?: String;
  kind_not?: String;
  kind_in?: String[] | String;
  kind_not_in?: String[] | String;
  kind_lt?: String;
  kind_lte?: String;
  kind_gt?: String;
  kind_gte?: String;
  kind_contains?: String;
  kind_not_contains?: String;
  kind_starts_with?: String;
  kind_not_starts_with?: String;
  kind_ends_with?: String;
  kind_not_ends_with?: String;
  AND?: ProductWhereInput[] | ProductWhereInput;
  OR?: ProductWhereInput[] | ProductWhereInput;
  NOT?: ProductWhereInput[] | ProductWhereInput;
}

export interface OldColleagueWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  from?: UserWhereInput;
  to?: UserWhereInput;
  company?: CompanyWhereInput;
  status?: String;
  status_not?: String;
  status_in?: String[] | String;
  status_not_in?: String[] | String;
  status_lt?: String;
  status_lte?: String;
  status_gt?: String;
  status_gte?: String;
  status_contains?: String;
  status_not_contains?: String;
  status_starts_with?: String;
  status_not_starts_with?: String;
  status_ends_with?: String;
  status_not_ends_with?: String;
  AND?: OldColleagueWhereInput[] | OldColleagueWhereInput;
  OR?: OldColleagueWhereInput[] | OldColleagueWhereInput;
  NOT?: OldColleagueWhereInput[] | OldColleagueWhereInput;
}

export interface UserCreateWithoutForgetPasswordInput {
  username: String;
  password: String;
  name?: String;
  gender?: String;
  avatar?: PhotoCreateOneWithoutUserInput;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationCreateOneWithoutBornsInput;
  residence?: LocationCreateOneWithoutLivesInput;
  uid: String;
  token: String;
  posts?: PostCreateManyWithoutAuthorInput;
  regStatus?: RegStatusCreateOneWithoutApplicantsInput;
  regTimes?: Int;
  maxRegTimes?: Int;
  families?: FamilyCreateManyWithoutFromInput;
  studies?: SchoolEduCreateManyWithoutStudentsInput;
  works?: WorkCreateManyWithoutWorkerInput;
  exam?: CollegeEntranceExamCreateOneWithoutStudentInput;
  sentMessages?: MessageCreateManyWithoutFromInput;
  receiveMessages?: MessageCreateManyWithoutToInput;
  groupMessages?: GroupMessageCreateManyWithoutFromInput;
  groups?: GroupCreateManyWithoutUsersInput;
  friends?: UserCreateManyInput;
  familyGroup?: FamilyGroupCreateOneWithoutUsersInput;
  creater?: FamilyGroupCreateOneWithoutCreaterInput;
  classMate?: ClassMateCreateManyWithoutStudentInput;
  workGroup?: WorkGroupCreateOneInput;
  colleagues?: ColleagueCreateManyWithoutWorkerInput;
  fromOldColleagues?: OldColleagueCreateManyWithoutFromInput;
  toOldColleagues?: OldColleagueCreateManyWithoutToInput;
  locationGroups?: LocationGroupCreateManyWithoutUsersInput;
  remmemberPassword?: FindPassWordCreateManyWithoutRemmemberInput;
  loveSetting?: LoveSettingCreateOneWithoutUserInput;
  loveWoman?: LoveMatchingCreateManyWithoutWomanInput;
  loveMan?: LoveMatchingCreateManyWithoutManInput;
  signUpLove?: LoveSignUpCreateOneWithoutPersonInput;
  skills?: SkillCreateManyWithoutPersonsInput;
  fitConditions?: PartnerConditionCreateManyWithoutPartnersInput;
  nofitConditions?: PartnerConditionCreateManyWithoutPassedPartnersInput;
  projects?: ProjectCreateManyWithoutStarterInput;
  trades?: TradeCreateManyWithoutUserInput;
}

export interface ClassMateWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  student?: UserWhereInput;
  status?: String;
  status_not?: String;
  status_in?: String[] | String;
  status_not_in?: String[] | String;
  status_lt?: String;
  status_lte?: String;
  status_gt?: String;
  status_gte?: String;
  status_contains?: String;
  status_not_contains?: String;
  status_starts_with?: String;
  status_not_starts_with?: String;
  status_ends_with?: String;
  status_not_ends_with?: String;
  group?: ClassGroupWhereInput;
  AND?: ClassMateWhereInput[] | ClassMateWhereInput;
  OR?: ClassMateWhereInput[] | ClassMateWhereInput;
  NOT?: ClassMateWhereInput[] | ClassMateWhereInput;
}

export interface FindPassWordCreateWithoutRemmemberInput {
  times?: Int;
  forgetter?: UserCreateOneWithoutForgetPasswordInput;
}

export interface GroupWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  type?: GroupKind;
  type_not?: GroupKind;
  type_in?: GroupKind[] | GroupKind;
  type_not_in?: GroupKind[] | GroupKind;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  users_every?: UserWhereInput;
  users_some?: UserWhereInput;
  users_none?: UserWhereInput;
  messages_every?: MessageWhereInput;
  messages_some?: MessageWhereInput;
  messages_none?: MessageWhereInput;
  AND?: GroupWhereInput[] | GroupWhereInput;
  OR?: GroupWhereInput[] | GroupWhereInput;
  NOT?: GroupWhereInput[] | GroupWhereInput;
}

export interface UserCreateWithoutFromOldColleaguesInput {
  username: String;
  password: String;
  name?: String;
  gender?: String;
  avatar?: PhotoCreateOneWithoutUserInput;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationCreateOneWithoutBornsInput;
  residence?: LocationCreateOneWithoutLivesInput;
  uid: String;
  token: String;
  posts?: PostCreateManyWithoutAuthorInput;
  regStatus?: RegStatusCreateOneWithoutApplicantsInput;
  regTimes?: Int;
  maxRegTimes?: Int;
  families?: FamilyCreateManyWithoutFromInput;
  studies?: SchoolEduCreateManyWithoutStudentsInput;
  works?: WorkCreateManyWithoutWorkerInput;
  exam?: CollegeEntranceExamCreateOneWithoutStudentInput;
  sentMessages?: MessageCreateManyWithoutFromInput;
  receiveMessages?: MessageCreateManyWithoutToInput;
  groupMessages?: GroupMessageCreateManyWithoutFromInput;
  groups?: GroupCreateManyWithoutUsersInput;
  friends?: UserCreateManyInput;
  familyGroup?: FamilyGroupCreateOneWithoutUsersInput;
  creater?: FamilyGroupCreateOneWithoutCreaterInput;
  classMate?: ClassMateCreateManyWithoutStudentInput;
  workGroup?: WorkGroupCreateOneInput;
  colleagues?: ColleagueCreateManyWithoutWorkerInput;
  toOldColleagues?: OldColleagueCreateManyWithoutToInput;
  locationGroups?: LocationGroupCreateManyWithoutUsersInput;
  forgetPassword?: FindPassWordCreateOneWithoutForgetterInput;
  remmemberPassword?: FindPassWordCreateManyWithoutRemmemberInput;
  loveSetting?: LoveSettingCreateOneWithoutUserInput;
  loveWoman?: LoveMatchingCreateManyWithoutWomanInput;
  loveMan?: LoveMatchingCreateManyWithoutManInput;
  signUpLove?: LoveSignUpCreateOneWithoutPersonInput;
  skills?: SkillCreateManyWithoutPersonsInput;
  fitConditions?: PartnerConditionCreateManyWithoutPartnersInput;
  nofitConditions?: PartnerConditionCreateManyWithoutPassedPartnersInput;
  projects?: ProjectCreateManyWithoutStarterInput;
  trades?: TradeCreateManyWithoutUserInput;
}

export interface GroupMessageWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  type?: GroupKind;
  type_not?: GroupKind;
  type_in?: GroupKind[] | GroupKind;
  type_not_in?: GroupKind[] | GroupKind;
  to?: String;
  to_not?: String;
  to_in?: String[] | String;
  to_not_in?: String[] | String;
  to_lt?: String;
  to_lte?: String;
  to_gt?: String;
  to_gte?: String;
  to_contains?: String;
  to_not_contains?: String;
  to_starts_with?: String;
  to_not_starts_with?: String;
  to_ends_with?: String;
  to_not_ends_with?: String;
  from?: UserWhereInput;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  image?: PhotoWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  AND?: GroupMessageWhereInput[] | GroupMessageWhereInput;
  OR?: GroupMessageWhereInput[] | GroupMessageWhereInput;
  NOT?: GroupMessageWhereInput[] | GroupMessageWhereInput;
}

export interface CityUpdateOneRequiredWithoutAreasInput {
  create?: CityCreateWithoutAreasInput;
  update?: CityUpdateWithoutAreasDataInput;
  upsert?: CityUpsertWithoutAreasInput;
  connect?: CityWhereUniqueInput;
}

export interface CompanyUpdateInput {
  name?: String;
  code?: String;
  establishmentDate?: DateTimeInput;
  representative?: String;
  location?: LocationUpdateOneWithoutCompaniesInput;
  BusinessScope?: String;
  works?: WorkUpdateManyWithoutCompanyInput;
  workGroup?: WorkGroupUpdateOneWithoutCompanyInput;
}

export interface CityUpdateWithoutAreasDataInput {
  code?: String;
  name?: String;
  province?: ProvinceUpdateOneRequiredWithoutCitiesInput;
}

export interface OldColleagueCreateWithoutToInput {
  from?: UserCreateOneWithoutFromOldColleaguesInput;
  company?: CompanyCreateOneInput;
  status: String;
}

export interface ProvinceUpdateOneRequiredWithoutCitiesInput {
  create?: ProvinceCreateWithoutCitiesInput;
  update?: ProvinceUpdateWithoutCitiesDataInput;
  upsert?: ProvinceUpsertWithoutCitiesInput;
  connect?: ProvinceWhereUniqueInput;
}

export interface WorkGroupSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: WorkGroupWhereInput;
  AND?: WorkGroupSubscriptionWhereInput[] | WorkGroupSubscriptionWhereInput;
  OR?: WorkGroupSubscriptionWhereInput[] | WorkGroupSubscriptionWhereInput;
  NOT?: WorkGroupSubscriptionWhereInput[] | WorkGroupSubscriptionWhereInput;
}

export interface ProvinceUpdateWithoutCitiesDataInput {
  code?: String;
  name?: String;
}

export interface VillageSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: VillageWhereInput;
  AND?: VillageSubscriptionWhereInput[] | VillageSubscriptionWhereInput;
  OR?: VillageSubscriptionWhereInput[] | VillageSubscriptionWhereInput;
  NOT?: VillageSubscriptionWhereInput[] | VillageSubscriptionWhereInput;
}

export interface ProvinceUpsertWithoutCitiesInput {
  update: ProvinceUpdateWithoutCitiesDataInput;
  create: ProvinceCreateWithoutCitiesInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface CityUpsertWithoutAreasInput {
  update: CityUpdateWithoutAreasDataInput;
  create: CityCreateWithoutAreasInput;
}

export interface TradeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TradeWhereInput;
  AND?: TradeSubscriptionWhereInput[] | TradeSubscriptionWhereInput;
  OR?: TradeSubscriptionWhereInput[] | TradeSubscriptionWhereInput;
  NOT?: TradeSubscriptionWhereInput[] | TradeSubscriptionWhereInput;
}

export interface StreetUpdateManyWithoutAreaInput {
  create?: StreetCreateWithoutAreaInput[] | StreetCreateWithoutAreaInput;
  delete?: StreetWhereUniqueInput[] | StreetWhereUniqueInput;
  connect?: StreetWhereUniqueInput[] | StreetWhereUniqueInput;
  disconnect?: StreetWhereUniqueInput[] | StreetWhereUniqueInput;
  update?:
    | StreetUpdateWithWhereUniqueWithoutAreaInput[]
    | StreetUpdateWithWhereUniqueWithoutAreaInput;
  upsert?:
    | StreetUpsertWithWhereUniqueWithoutAreaInput[]
    | StreetUpsertWithWhereUniqueWithoutAreaInput;
  deleteMany?: StreetScalarWhereInput[] | StreetScalarWhereInput;
  updateMany?:
    | StreetUpdateManyWithWhereNestedInput[]
    | StreetUpdateManyWithWhereNestedInput;
}

export interface StreetSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: StreetWhereInput;
  AND?: StreetSubscriptionWhereInput[] | StreetSubscriptionWhereInput;
  OR?: StreetSubscriptionWhereInput[] | StreetSubscriptionWhereInput;
  NOT?: StreetSubscriptionWhereInput[] | StreetSubscriptionWhereInput;
}

export interface StreetUpdateWithWhereUniqueWithoutAreaInput {
  where: StreetWhereUniqueInput;
  data: StreetUpdateWithoutAreaDataInput;
}

export interface StationSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: StationWhereInput;
  AND?: StationSubscriptionWhereInput[] | StationSubscriptionWhereInput;
  OR?: StationSubscriptionWhereInput[] | StationSubscriptionWhereInput;
  NOT?: StationSubscriptionWhereInput[] | StationSubscriptionWhereInput;
}

export interface StreetUpdateWithoutAreaDataInput {
  code?: String;
  name?: String;
  villages?: VillageUpdateManyWithoutStreetInput;
}

export interface SkillSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SkillWhereInput;
  AND?: SkillSubscriptionWhereInput[] | SkillSubscriptionWhereInput;
  OR?: SkillSubscriptionWhereInput[] | SkillSubscriptionWhereInput;
  NOT?: SkillSubscriptionWhereInput[] | SkillSubscriptionWhereInput;
}

export interface VillageUpdateManyWithoutStreetInput {
  create?: VillageCreateWithoutStreetInput[] | VillageCreateWithoutStreetInput;
  delete?: VillageWhereUniqueInput[] | VillageWhereUniqueInput;
  connect?: VillageWhereUniqueInput[] | VillageWhereUniqueInput;
  disconnect?: VillageWhereUniqueInput[] | VillageWhereUniqueInput;
  update?:
    | VillageUpdateWithWhereUniqueWithoutStreetInput[]
    | VillageUpdateWithWhereUniqueWithoutStreetInput;
  upsert?:
    | VillageUpsertWithWhereUniqueWithoutStreetInput[]
    | VillageUpsertWithWhereUniqueWithoutStreetInput;
  deleteMany?: VillageScalarWhereInput[] | VillageScalarWhereInput;
  updateMany?:
    | VillageUpdateManyWithWhereNestedInput[]
    | VillageUpdateManyWithWhereNestedInput;
}

export interface SchoolSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SchoolWhereInput;
  AND?: SchoolSubscriptionWhereInput[] | SchoolSubscriptionWhereInput;
  OR?: SchoolSubscriptionWhereInput[] | SchoolSubscriptionWhereInput;
  NOT?: SchoolSubscriptionWhereInput[] | SchoolSubscriptionWhereInput;
}

export interface VillageUpdateWithWhereUniqueWithoutStreetInput {
  where: VillageWhereUniqueInput;
  data: VillageUpdateWithoutStreetDataInput;
}

export interface RegisterCountSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: RegisterCountWhereInput;
  AND?:
    | RegisterCountSubscriptionWhereInput[]
    | RegisterCountSubscriptionWhereInput;
  OR?:
    | RegisterCountSubscriptionWhereInput[]
    | RegisterCountSubscriptionWhereInput;
  NOT?:
    | RegisterCountSubscriptionWhereInput[]
    | RegisterCountSubscriptionWhereInput;
}

export interface VillageUpdateWithoutStreetDataInput {
  code?: String;
  name?: String;
  people?: UserUpdateManyInput;
}

export interface MajorWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  category?: String;
  category_not?: String;
  category_in?: String[] | String;
  category_not_in?: String[] | String;
  category_lt?: String;
  category_lte?: String;
  category_gt?: String;
  category_gte?: String;
  category_contains?: String;
  category_not_contains?: String;
  category_starts_with?: String;
  category_not_starts_with?: String;
  category_ends_with?: String;
  category_not_ends_with?: String;
  education?: Educationkind;
  education_not?: Educationkind;
  education_in?: Educationkind[] | Educationkind;
  education_not_in?: Educationkind[] | Educationkind;
  AND?: MajorWhereInput[] | MajorWhereInput;
  OR?: MajorWhereInput[] | MajorWhereInput;
  NOT?: MajorWhereInput[] | MajorWhereInput;
}

export interface UserUpdateManyInput {
  create?: UserCreateInput[] | UserCreateInput;
  update?:
    | UserUpdateWithWhereUniqueNestedInput[]
    | UserUpdateWithWhereUniqueNestedInput;
  upsert?:
    | UserUpsertWithWhereUniqueNestedInput[]
    | UserUpsertWithWhereUniqueNestedInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export interface RegStatusWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  education?: Educationkind;
  education_not?: Educationkind;
  education_in?: Educationkind[] | Educationkind;
  education_not_in?: Educationkind[] | Educationkind;
  university?: UniversityWhereInput;
  major?: MajorWhereInput;
  applicants_every?: UserWhereInput;
  applicants_some?: UserWhereInput;
  applicants_none?: UserWhereInput;
  AND?: RegStatusWhereInput[] | RegStatusWhereInput;
  OR?: RegStatusWhereInput[] | RegStatusWhereInput;
  NOT?: RegStatusWhereInput[] | RegStatusWhereInput;
}

export interface UserUpdateWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput;
  data: UserUpdateDataInput;
}

export interface ProductSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ProductWhereInput;
  AND?: ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput;
  OR?: ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput;
  NOT?: ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput;
}

export interface UserUpdateDataInput {
  username?: String;
  password?: String;
  name?: String;
  gender?: String;
  avatar?: PhotoUpdateOneWithoutUserInput;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationUpdateOneWithoutBornsInput;
  residence?: LocationUpdateOneWithoutLivesInput;
  uid?: String;
  token?: String;
  posts?: PostUpdateManyWithoutAuthorInput;
  regStatus?: RegStatusUpdateOneWithoutApplicantsInput;
  regTimes?: Int;
  maxRegTimes?: Int;
  families?: FamilyUpdateManyWithoutFromInput;
  studies?: SchoolEduUpdateManyWithoutStudentsInput;
  works?: WorkUpdateManyWithoutWorkerInput;
  exam?: CollegeEntranceExamUpdateOneWithoutStudentInput;
  sentMessages?: MessageUpdateManyWithoutFromInput;
  receiveMessages?: MessageUpdateManyWithoutToInput;
  groupMessages?: GroupMessageUpdateManyWithoutFromInput;
  groups?: GroupUpdateManyWithoutUsersInput;
  friends?: UserUpdateManyInput;
  familyGroup?: FamilyGroupUpdateOneWithoutUsersInput;
  creater?: FamilyGroupUpdateOneWithoutCreaterInput;
  classMate?: ClassMateUpdateManyWithoutStudentInput;
  workGroup?: WorkGroupUpdateOneInput;
  colleagues?: ColleagueUpdateManyWithoutWorkerInput;
  fromOldColleagues?: OldColleagueUpdateManyWithoutFromInput;
  toOldColleagues?: OldColleagueUpdateManyWithoutToInput;
  locationGroups?: LocationGroupUpdateManyWithoutUsersInput;
  forgetPassword?: FindPassWordUpdateOneWithoutForgetterInput;
  remmemberPassword?: FindPassWordUpdateManyWithoutRemmemberInput;
  loveSetting?: LoveSettingUpdateOneWithoutUserInput;
  loveWoman?: LoveMatchingUpdateManyWithoutWomanInput;
  loveMan?: LoveMatchingUpdateManyWithoutManInput;
  signUpLove?: LoveSignUpUpdateOneWithoutPersonInput;
  skills?: SkillUpdateManyWithoutPersonsInput;
  fitConditions?: PartnerConditionUpdateManyWithoutPartnersInput;
  nofitConditions?: PartnerConditionUpdateManyWithoutPassedPartnersInput;
  projects?: ProjectUpdateManyWithoutStarterInput;
  trades?: TradeUpdateManyWithoutUserInput;
}

export interface PostSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PostWhereInput;
  AND?: PostSubscriptionWhereInput[] | PostSubscriptionWhereInput;
  OR?: PostSubscriptionWhereInput[] | PostSubscriptionWhereInput;
  NOT?: PostSubscriptionWhereInput[] | PostSubscriptionWhereInput;
}

export interface PhotoUpdateOneWithoutUserInput {
  create?: PhotoCreateWithoutUserInput;
  update?: PhotoUpdateWithoutUserDataInput;
  upsert?: PhotoUpsertWithoutUserInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: PhotoWhereUniqueInput;
}

export interface PhotoSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PhotoWhereInput;
  AND?: PhotoSubscriptionWhereInput[] | PhotoSubscriptionWhereInput;
  OR?: PhotoSubscriptionWhereInput[] | PhotoSubscriptionWhereInput;
  NOT?: PhotoSubscriptionWhereInput[] | PhotoSubscriptionWhereInput;
}

export interface PhotoUpdateWithoutUserDataInput {
  name?: String;
  url?: String;
}

export interface PersonSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PersonWhereInput;
  AND?: PersonSubscriptionWhereInput[] | PersonSubscriptionWhereInput;
  OR?: PersonSubscriptionWhereInput[] | PersonSubscriptionWhereInput;
  NOT?: PersonSubscriptionWhereInput[] | PersonSubscriptionWhereInput;
}

export interface PhotoUpsertWithoutUserInput {
  update: PhotoUpdateWithoutUserDataInput;
  create: PhotoCreateWithoutUserInput;
}

export interface PartnerConditionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PartnerConditionWhereInput;
  AND?:
    | PartnerConditionSubscriptionWhereInput[]
    | PartnerConditionSubscriptionWhereInput;
  OR?:
    | PartnerConditionSubscriptionWhereInput[]
    | PartnerConditionSubscriptionWhereInput;
  NOT?:
    | PartnerConditionSubscriptionWhereInput[]
    | PartnerConditionSubscriptionWhereInput;
}

export interface LocationUpdateOneWithoutBornsInput {
  create?: LocationCreateWithoutBornsInput;
  update?: LocationUpdateWithoutBornsDataInput;
  upsert?: LocationUpsertWithoutBornsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: LocationWhereUniqueInput;
}

export interface StationWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  code?: String;
  code_not?: String;
  code_in?: String[] | String;
  code_not_in?: String[] | String;
  code_lt?: String;
  code_lte?: String;
  code_gt?: String;
  code_gte?: String;
  code_contains?: String;
  code_not_contains?: String;
  code_starts_with?: String;
  code_not_starts_with?: String;
  code_ends_with?: String;
  code_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: StationWhereInput[] | StationWhereInput;
  OR?: StationWhereInput[] | StationWhereInput;
  NOT?: StationWhereInput[] | StationWhereInput;
}

export interface LocationUpdateWithoutBornsDataInput {
  name?: String;
  province?: ProvinceUpdateOneInput;
  city?: CityUpdateOneInput;
  area?: AreaUpdateOneInput;
  street?: StreetUpdateOneInput;
  village?: VillageUpdateOneInput;
  schools?: SchoolUpdateManyWithoutLocationInput;
  companies?: CompanyUpdateManyWithoutLocationInput;
  universities?: UniversityUpdateManyInput;
  lives?: UserUpdateManyWithoutResidenceInput;
}

export interface WorkWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  startTime?: DateTimeInput;
  startTime_not?: DateTimeInput;
  startTime_in?: DateTimeInput[] | DateTimeInput;
  startTime_not_in?: DateTimeInput[] | DateTimeInput;
  startTime_lt?: DateTimeInput;
  startTime_lte?: DateTimeInput;
  startTime_gt?: DateTimeInput;
  startTime_gte?: DateTimeInput;
  endTime?: DateTimeInput;
  endTime_not?: DateTimeInput;
  endTime_in?: DateTimeInput[] | DateTimeInput;
  endTime_not_in?: DateTimeInput[] | DateTimeInput;
  endTime_lt?: DateTimeInput;
  endTime_lte?: DateTimeInput;
  endTime_gt?: DateTimeInput;
  endTime_gte?: DateTimeInput;
  company?: CompanyWhereInput;
  department?: String;
  department_not?: String;
  department_in?: String[] | String;
  department_not_in?: String[] | String;
  department_lt?: String;
  department_lte?: String;
  department_gt?: String;
  department_gte?: String;
  department_contains?: String;
  department_not_contains?: String;
  department_starts_with?: String;
  department_not_starts_with?: String;
  department_ends_with?: String;
  department_not_ends_with?: String;
  post?: StationWhereInput;
  jobContent?: String;
  jobContent_not?: String;
  jobContent_in?: String[] | String;
  jobContent_not_in?: String[] | String;
  jobContent_lt?: String;
  jobContent_lte?: String;
  jobContent_gt?: String;
  jobContent_gte?: String;
  jobContent_contains?: String;
  jobContent_not_contains?: String;
  jobContent_starts_with?: String;
  jobContent_not_starts_with?: String;
  jobContent_ends_with?: String;
  jobContent_not_ends_with?: String;
  worker?: UserWhereInput;
  AND?: WorkWhereInput[] | WorkWhereInput;
  OR?: WorkWhereInput[] | WorkWhereInput;
  NOT?: WorkWhereInput[] | WorkWhereInput;
}

export interface ProvinceUpdateOneInput {
  create?: ProvinceCreateInput;
  update?: ProvinceUpdateDataInput;
  upsert?: ProvinceUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ProvinceWhereUniqueInput;
}

export interface LoveSignUpSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: LoveSignUpWhereInput;
  AND?: LoveSignUpSubscriptionWhereInput[] | LoveSignUpSubscriptionWhereInput;
  OR?: LoveSignUpSubscriptionWhereInput[] | LoveSignUpSubscriptionWhereInput;
  NOT?: LoveSignUpSubscriptionWhereInput[] | LoveSignUpSubscriptionWhereInput;
}

export interface ProvinceUpdateDataInput {
  code?: String;
  name?: String;
  cities?: CityUpdateManyWithoutProvinceInput;
}

export interface LoveSettingSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: LoveSettingWhereInput;
  AND?: LoveSettingSubscriptionWhereInput[] | LoveSettingSubscriptionWhereInput;
  OR?: LoveSettingSubscriptionWhereInput[] | LoveSettingSubscriptionWhereInput;
  NOT?: LoveSettingSubscriptionWhereInput[] | LoveSettingSubscriptionWhereInput;
}

export interface CityUpdateManyWithoutProvinceInput {
  create?: CityCreateWithoutProvinceInput[] | CityCreateWithoutProvinceInput;
  delete?: CityWhereUniqueInput[] | CityWhereUniqueInput;
  connect?: CityWhereUniqueInput[] | CityWhereUniqueInput;
  disconnect?: CityWhereUniqueInput[] | CityWhereUniqueInput;
  update?:
    | CityUpdateWithWhereUniqueWithoutProvinceInput[]
    | CityUpdateWithWhereUniqueWithoutProvinceInput;
  upsert?:
    | CityUpsertWithWhereUniqueWithoutProvinceInput[]
    | CityUpsertWithWhereUniqueWithoutProvinceInput;
  deleteMany?: CityScalarWhereInput[] | CityScalarWhereInput;
  updateMany?:
    | CityUpdateManyWithWhereNestedInput[]
    | CityUpdateManyWithWhereNestedInput;
}

export interface LoveMatchingSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: LoveMatchingWhereInput;
  AND?:
    | LoveMatchingSubscriptionWhereInput[]
    | LoveMatchingSubscriptionWhereInput;
  OR?:
    | LoveMatchingSubscriptionWhereInput[]
    | LoveMatchingSubscriptionWhereInput;
  NOT?:
    | LoveMatchingSubscriptionWhereInput[]
    | LoveMatchingSubscriptionWhereInput;
}

export interface CityUpdateWithWhereUniqueWithoutProvinceInput {
  where: CityWhereUniqueInput;
  data: CityUpdateWithoutProvinceDataInput;
}

export interface LocationWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  province?: ProvinceWhereInput;
  city?: CityWhereInput;
  area?: AreaWhereInput;
  street?: StreetWhereInput;
  village?: VillageWhereInput;
  schools_every?: SchoolWhereInput;
  schools_some?: SchoolWhereInput;
  schools_none?: SchoolWhereInput;
  companies_every?: CompanyWhereInput;
  companies_some?: CompanyWhereInput;
  companies_none?: CompanyWhereInput;
  universities_every?: UniversityWhereInput;
  universities_some?: UniversityWhereInput;
  universities_none?: UniversityWhereInput;
  borns_every?: UserWhereInput;
  borns_some?: UserWhereInput;
  borns_none?: UserWhereInput;
  lives_every?: UserWhereInput;
  lives_some?: UserWhereInput;
  lives_none?: UserWhereInput;
  AND?: LocationWhereInput[] | LocationWhereInput;
  OR?: LocationWhereInput[] | LocationWhereInput;
  NOT?: LocationWhereInput[] | LocationWhereInput;
}

export interface CityUpdateWithoutProvinceDataInput {
  code?: String;
  name?: String;
  areas?: AreaUpdateManyWithoutCityInput;
}

export interface PhotoWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  url?: String;
  url_not?: String;
  url_in?: String[] | String;
  url_not_in?: String[] | String;
  url_lt?: String;
  url_lte?: String;
  url_gt?: String;
  url_gte?: String;
  url_contains?: String;
  url_not_contains?: String;
  url_starts_with?: String;
  url_not_starts_with?: String;
  url_ends_with?: String;
  url_not_ends_with?: String;
  user?: UserWhereInput;
  AND?: PhotoWhereInput[] | PhotoWhereInput;
  OR?: PhotoWhereInput[] | PhotoWhereInput;
  NOT?: PhotoWhereInput[] | PhotoWhereInput;
}

export interface AreaUpdateManyWithoutCityInput {
  create?: AreaCreateWithoutCityInput[] | AreaCreateWithoutCityInput;
  delete?: AreaWhereUniqueInput[] | AreaWhereUniqueInput;
  connect?: AreaWhereUniqueInput[] | AreaWhereUniqueInput;
  disconnect?: AreaWhereUniqueInput[] | AreaWhereUniqueInput;
  update?:
    | AreaUpdateWithWhereUniqueWithoutCityInput[]
    | AreaUpdateWithWhereUniqueWithoutCityInput;
  upsert?:
    | AreaUpsertWithWhereUniqueWithoutCityInput[]
    | AreaUpsertWithWhereUniqueWithoutCityInput;
  deleteMany?: AreaScalarWhereInput[] | AreaScalarWhereInput;
  updateMany?:
    | AreaUpdateManyWithWhereNestedInput[]
    | AreaUpdateManyWithWhereNestedInput;
}

export interface GroupMessageSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: GroupMessageWhereInput;
  AND?:
    | GroupMessageSubscriptionWhereInput[]
    | GroupMessageSubscriptionWhereInput;
  OR?:
    | GroupMessageSubscriptionWhereInput[]
    | GroupMessageSubscriptionWhereInput;
  NOT?:
    | GroupMessageSubscriptionWhereInput[]
    | GroupMessageSubscriptionWhereInput;
}

export interface AreaUpdateWithWhereUniqueWithoutCityInput {
  where: AreaWhereUniqueInput;
  data: AreaUpdateWithoutCityDataInput;
}

export interface VillageWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  code?: String;
  code_not?: String;
  code_in?: String[] | String;
  code_not_in?: String[] | String;
  code_lt?: String;
  code_lte?: String;
  code_gt?: String;
  code_gte?: String;
  code_contains?: String;
  code_not_contains?: String;
  code_starts_with?: String;
  code_not_starts_with?: String;
  code_ends_with?: String;
  code_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  street?: StreetWhereInput;
  people_every?: UserWhereInput;
  people_some?: UserWhereInput;
  people_none?: UserWhereInput;
  AND?: VillageWhereInput[] | VillageWhereInput;
  OR?: VillageWhereInput[] | VillageWhereInput;
  NOT?: VillageWhereInput[] | VillageWhereInput;
}

export interface AreaUpdateWithoutCityDataInput {
  code?: String;
  name?: String;
  towns?: StreetUpdateManyWithoutAreaInput;
}

export interface FindPassWordSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: FindPassWordWhereInput;
  AND?:
    | FindPassWordSubscriptionWhereInput[]
    | FindPassWordSubscriptionWhereInput;
  OR?:
    | FindPassWordSubscriptionWhereInput[]
    | FindPassWordSubscriptionWhereInput;
  NOT?:
    | FindPassWordSubscriptionWhereInput[]
    | FindPassWordSubscriptionWhereInput;
}

export interface AreaUpsertWithWhereUniqueWithoutCityInput {
  where: AreaWhereUniqueInput;
  update: AreaUpdateWithoutCityDataInput;
  create: AreaCreateWithoutCityInput;
}

export interface FamilyGroupSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: FamilyGroupWhereInput;
  AND?: FamilyGroupSubscriptionWhereInput[] | FamilyGroupSubscriptionWhereInput;
  OR?: FamilyGroupSubscriptionWhereInput[] | FamilyGroupSubscriptionWhereInput;
  NOT?: FamilyGroupSubscriptionWhereInput[] | FamilyGroupSubscriptionWhereInput;
}

export interface AreaScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  code?: String;
  code_not?: String;
  code_in?: String[] | String;
  code_not_in?: String[] | String;
  code_lt?: String;
  code_lte?: String;
  code_gt?: String;
  code_gte?: String;
  code_contains?: String;
  code_not_contains?: String;
  code_starts_with?: String;
  code_not_starts_with?: String;
  code_ends_with?: String;
  code_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: AreaScalarWhereInput[] | AreaScalarWhereInput;
  OR?: AreaScalarWhereInput[] | AreaScalarWhereInput;
  NOT?: AreaScalarWhereInput[] | AreaScalarWhereInput;
}

export type BootCountWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface AreaUpdateManyWithWhereNestedInput {
  where: AreaScalarWhereInput;
  data: AreaUpdateManyDataInput;
}

export interface BootCountWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  bootUser?: UserWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  AND?: BootCountWhereInput[] | BootCountWhereInput;
  OR?: BootCountWhereInput[] | BootCountWhereInput;
  NOT?: BootCountWhereInput[] | BootCountWhereInput;
}

export interface AreaUpdateManyDataInput {
  code?: String;
  name?: String;
}

export interface CollegeEntranceExamSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CollegeEntranceExamWhereInput;
  AND?:
    | CollegeEntranceExamSubscriptionWhereInput[]
    | CollegeEntranceExamSubscriptionWhereInput;
  OR?:
    | CollegeEntranceExamSubscriptionWhereInput[]
    | CollegeEntranceExamSubscriptionWhereInput;
  NOT?:
    | CollegeEntranceExamSubscriptionWhereInput[]
    | CollegeEntranceExamSubscriptionWhereInput;
}

export interface CityUpsertWithWhereUniqueWithoutProvinceInput {
  where: CityWhereUniqueInput;
  update: CityUpdateWithoutProvinceDataInput;
  create: CityCreateWithoutProvinceInput;
}

export interface ClassMateSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ClassMateWhereInput;
  AND?: ClassMateSubscriptionWhereInput[] | ClassMateSubscriptionWhereInput;
  OR?: ClassMateSubscriptionWhereInput[] | ClassMateSubscriptionWhereInput;
  NOT?: ClassMateSubscriptionWhereInput[] | ClassMateSubscriptionWhereInput;
}

export interface CityScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  code?: String;
  code_not?: String;
  code_in?: String[] | String;
  code_not_in?: String[] | String;
  code_lt?: String;
  code_lte?: String;
  code_gt?: String;
  code_gte?: String;
  code_contains?: String;
  code_not_contains?: String;
  code_starts_with?: String;
  code_not_starts_with?: String;
  code_ends_with?: String;
  code_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: CityScalarWhereInput[] | CityScalarWhereInput;
  OR?: CityScalarWhereInput[] | CityScalarWhereInput;
  NOT?: CityScalarWhereInput[] | CityScalarWhereInput;
}

export interface ClassGroupSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ClassGroupWhereInput;
  AND?: ClassGroupSubscriptionWhereInput[] | ClassGroupSubscriptionWhereInput;
  OR?: ClassGroupSubscriptionWhereInput[] | ClassGroupSubscriptionWhereInput;
  NOT?: ClassGroupSubscriptionWhereInput[] | ClassGroupSubscriptionWhereInput;
}

export interface CityUpdateManyWithWhereNestedInput {
  where: CityScalarWhereInput;
  data: CityUpdateManyDataInput;
}

export interface BootCountSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: BootCountWhereInput;
  AND?: BootCountSubscriptionWhereInput[] | BootCountSubscriptionWhereInput;
  OR?: BootCountSubscriptionWhereInput[] | BootCountSubscriptionWhereInput;
  NOT?: BootCountSubscriptionWhereInput[] | BootCountSubscriptionWhereInput;
}

export interface CityUpdateManyDataInput {
  code?: String;
  name?: String;
}

export interface AreaWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  code?: String;
  code_not?: String;
  code_in?: String[] | String;
  code_not_in?: String[] | String;
  code_lt?: String;
  code_lte?: String;
  code_gt?: String;
  code_gte?: String;
  code_contains?: String;
  code_not_contains?: String;
  code_starts_with?: String;
  code_not_starts_with?: String;
  code_ends_with?: String;
  code_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  city?: CityWhereInput;
  towns_every?: StreetWhereInput;
  towns_some?: StreetWhereInput;
  towns_none?: StreetWhereInput;
  AND?: AreaWhereInput[] | AreaWhereInput;
  OR?: AreaWhereInput[] | AreaWhereInput;
  NOT?: AreaWhereInput[] | AreaWhereInput;
}

export interface ProvinceUpsertNestedInput {
  update: ProvinceUpdateDataInput;
  create: ProvinceCreateInput;
}

export interface AdvertisementSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AdvertisementWhereInput;
  AND?:
    | AdvertisementSubscriptionWhereInput[]
    | AdvertisementSubscriptionWhereInput;
  OR?:
    | AdvertisementSubscriptionWhereInput[]
    | AdvertisementSubscriptionWhereInput;
  NOT?:
    | AdvertisementSubscriptionWhereInput[]
    | AdvertisementSubscriptionWhereInput;
}

export interface CityUpdateOneInput {
  create?: CityCreateInput;
  update?: CityUpdateDataInput;
  upsert?: CityUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: CityWhereUniqueInput;
}

export type ClassMateWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CityUpdateDataInput {
  code?: String;
  name?: String;
  province?: ProvinceUpdateOneRequiredWithoutCitiesInput;
  areas?: AreaUpdateManyWithoutCityInput;
}

export interface WorkUpdateInput {
  startTime?: DateTimeInput;
  endTime?: DateTimeInput;
  company?: CompanyUpdateOneWithoutWorksInput;
  department?: String;
  post?: StationUpdateOneInput;
  jobContent?: String;
  worker?: UserUpdateOneWithoutWorksInput;
}

export interface CityUpsertNestedInput {
  update: CityUpdateDataInput;
  create: CityCreateInput;
}

export type ColleagueWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface AreaUpdateOneInput {
  create?: AreaCreateInput;
  update?: AreaUpdateDataInput;
  upsert?: AreaUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: AreaWhereUniqueInput;
}

export interface VillageUpdateInput {
  code?: String;
  name?: String;
  street?: StreetUpdateOneRequiredWithoutVillagesInput;
  people?: UserUpdateManyInput;
}

export interface AreaUpdateDataInput {
  code?: String;
  name?: String;
  city?: CityUpdateOneRequiredWithoutAreasInput;
  towns?: StreetUpdateManyWithoutAreaInput;
}

export type CollegeEntranceExamWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  candidatenum?: String;
}>;

export interface AreaUpsertNestedInput {
  update: AreaUpdateDataInput;
  create: AreaCreateInput;
}

export interface UserUpdateInput {
  username?: String;
  password?: String;
  name?: String;
  gender?: String;
  avatar?: PhotoUpdateOneWithoutUserInput;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationUpdateOneWithoutBornsInput;
  residence?: LocationUpdateOneWithoutLivesInput;
  uid?: String;
  token?: String;
  posts?: PostUpdateManyWithoutAuthorInput;
  regStatus?: RegStatusUpdateOneWithoutApplicantsInput;
  regTimes?: Int;
  maxRegTimes?: Int;
  families?: FamilyUpdateManyWithoutFromInput;
  studies?: SchoolEduUpdateManyWithoutStudentsInput;
  works?: WorkUpdateManyWithoutWorkerInput;
  exam?: CollegeEntranceExamUpdateOneWithoutStudentInput;
  sentMessages?: MessageUpdateManyWithoutFromInput;
  receiveMessages?: MessageUpdateManyWithoutToInput;
  groupMessages?: GroupMessageUpdateManyWithoutFromInput;
  groups?: GroupUpdateManyWithoutUsersInput;
  friends?: UserUpdateManyInput;
  familyGroup?: FamilyGroupUpdateOneWithoutUsersInput;
  creater?: FamilyGroupUpdateOneWithoutCreaterInput;
  classMate?: ClassMateUpdateManyWithoutStudentInput;
  workGroup?: WorkGroupUpdateOneInput;
  colleagues?: ColleagueUpdateManyWithoutWorkerInput;
  fromOldColleagues?: OldColleagueUpdateManyWithoutFromInput;
  toOldColleagues?: OldColleagueUpdateManyWithoutToInput;
  locationGroups?: LocationGroupUpdateManyWithoutUsersInput;
  forgetPassword?: FindPassWordUpdateOneWithoutForgetterInput;
  remmemberPassword?: FindPassWordUpdateManyWithoutRemmemberInput;
  loveSetting?: LoveSettingUpdateOneWithoutUserInput;
  loveWoman?: LoveMatchingUpdateManyWithoutWomanInput;
  loveMan?: LoveMatchingUpdateManyWithoutManInput;
  signUpLove?: LoveSignUpUpdateOneWithoutPersonInput;
  skills?: SkillUpdateManyWithoutPersonsInput;
  fitConditions?: PartnerConditionUpdateManyWithoutPartnersInput;
  nofitConditions?: PartnerConditionUpdateManyWithoutPassedPartnersInput;
  projects?: ProjectUpdateManyWithoutStarterInput;
  trades?: TradeUpdateManyWithoutUserInput;
}

export interface StreetUpdateOneInput {
  create?: StreetCreateInput;
  update?: StreetUpdateDataInput;
  upsert?: StreetUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: StreetWhereUniqueInput;
}

export interface UniversityUpdateInput {
  name?: String;
  education?: Educationkind;
  department?: String;
  location?: String;
  desc?: String;
}

export interface StreetUpdateDataInput {
  code?: String;
  name?: String;
  Area?: AreaUpdateOneRequiredWithoutTownsInput;
  villages?: VillageUpdateManyWithoutStreetInput;
}

export interface TradeUpdateManyMutationInput {
  number?: Int;
  amount?: Float;
  status?: String;
}

export interface AreaUpdateOneRequiredWithoutTownsInput {
  create?: AreaCreateWithoutTownsInput;
  update?: AreaUpdateWithoutTownsDataInput;
  upsert?: AreaUpsertWithoutTownsInput;
  connect?: AreaWhereUniqueInput;
}

export interface UserUpdateWithoutTradesDataInput {
  username?: String;
  password?: String;
  name?: String;
  gender?: String;
  avatar?: PhotoUpdateOneWithoutUserInput;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationUpdateOneWithoutBornsInput;
  residence?: LocationUpdateOneWithoutLivesInput;
  uid?: String;
  token?: String;
  posts?: PostUpdateManyWithoutAuthorInput;
  regStatus?: RegStatusUpdateOneWithoutApplicantsInput;
  regTimes?: Int;
  maxRegTimes?: Int;
  families?: FamilyUpdateManyWithoutFromInput;
  studies?: SchoolEduUpdateManyWithoutStudentsInput;
  works?: WorkUpdateManyWithoutWorkerInput;
  exam?: CollegeEntranceExamUpdateOneWithoutStudentInput;
  sentMessages?: MessageUpdateManyWithoutFromInput;
  receiveMessages?: MessageUpdateManyWithoutToInput;
  groupMessages?: GroupMessageUpdateManyWithoutFromInput;
  groups?: GroupUpdateManyWithoutUsersInput;
  friends?: UserUpdateManyInput;
  familyGroup?: FamilyGroupUpdateOneWithoutUsersInput;
  creater?: FamilyGroupUpdateOneWithoutCreaterInput;
  classMate?: ClassMateUpdateManyWithoutStudentInput;
  workGroup?: WorkGroupUpdateOneInput;
  colleagues?: ColleagueUpdateManyWithoutWorkerInput;
  fromOldColleagues?: OldColleagueUpdateManyWithoutFromInput;
  toOldColleagues?: OldColleagueUpdateManyWithoutToInput;
  locationGroups?: LocationGroupUpdateManyWithoutUsersInput;
  forgetPassword?: FindPassWordUpdateOneWithoutForgetterInput;
  remmemberPassword?: FindPassWordUpdateManyWithoutRemmemberInput;
  loveSetting?: LoveSettingUpdateOneWithoutUserInput;
  loveWoman?: LoveMatchingUpdateManyWithoutWomanInput;
  loveMan?: LoveMatchingUpdateManyWithoutManInput;
  signUpLove?: LoveSignUpUpdateOneWithoutPersonInput;
  skills?: SkillUpdateManyWithoutPersonsInput;
  fitConditions?: PartnerConditionUpdateManyWithoutPartnersInput;
  nofitConditions?: PartnerConditionUpdateManyWithoutPassedPartnersInput;
  projects?: ProjectUpdateManyWithoutStarterInput;
}

export interface AreaUpdateWithoutTownsDataInput {
  code?: String;
  name?: String;
  city?: CityUpdateOneRequiredWithoutAreasInput;
}

export interface UserUpdateOneWithoutTradesInput {
  create?: UserCreateWithoutTradesInput;
  update?: UserUpdateWithoutTradesDataInput;
  upsert?: UserUpsertWithoutTradesInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface AreaUpsertWithoutTownsInput {
  update: AreaUpdateWithoutTownsDataInput;
  create: AreaCreateWithoutTownsInput;
}

export interface UserCreateWithoutTradesInput {
  username: String;
  password: String;
  name?: String;
  gender?: String;
  avatar?: PhotoCreateOneWithoutUserInput;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationCreateOneWithoutBornsInput;
  residence?: LocationCreateOneWithoutLivesInput;
  uid: String;
  token: String;
  posts?: PostCreateManyWithoutAuthorInput;
  regStatus?: RegStatusCreateOneWithoutApplicantsInput;
  regTimes?: Int;
  maxRegTimes?: Int;
  families?: FamilyCreateManyWithoutFromInput;
  studies?: SchoolEduCreateManyWithoutStudentsInput;
  works?: WorkCreateManyWithoutWorkerInput;
  exam?: CollegeEntranceExamCreateOneWithoutStudentInput;
  sentMessages?: MessageCreateManyWithoutFromInput;
  receiveMessages?: MessageCreateManyWithoutToInput;
  groupMessages?: GroupMessageCreateManyWithoutFromInput;
  groups?: GroupCreateManyWithoutUsersInput;
  friends?: UserCreateManyInput;
  familyGroup?: FamilyGroupCreateOneWithoutUsersInput;
  creater?: FamilyGroupCreateOneWithoutCreaterInput;
  classMate?: ClassMateCreateManyWithoutStudentInput;
  workGroup?: WorkGroupCreateOneInput;
  colleagues?: ColleagueCreateManyWithoutWorkerInput;
  fromOldColleagues?: OldColleagueCreateManyWithoutFromInput;
  toOldColleagues?: OldColleagueCreateManyWithoutToInput;
  locationGroups?: LocationGroupCreateManyWithoutUsersInput;
  forgetPassword?: FindPassWordCreateOneWithoutForgetterInput;
  remmemberPassword?: FindPassWordCreateManyWithoutRemmemberInput;
  loveSetting?: LoveSettingCreateOneWithoutUserInput;
  loveWoman?: LoveMatchingCreateManyWithoutWomanInput;
  loveMan?: LoveMatchingCreateManyWithoutManInput;
  signUpLove?: LoveSignUpCreateOneWithoutPersonInput;
  skills?: SkillCreateManyWithoutPersonsInput;
  fitConditions?: PartnerConditionCreateManyWithoutPartnersInput;
  nofitConditions?: PartnerConditionCreateManyWithoutPassedPartnersInput;
  projects?: ProjectCreateManyWithoutStarterInput;
}

export interface StreetUpsertNestedInput {
  update: StreetUpdateDataInput;
  create: StreetCreateInput;
}

export interface UserCreateOneWithoutTradesInput {
  create?: UserCreateWithoutTradesInput;
  connect?: UserWhereUniqueInput;
}

export interface VillageUpdateOneInput {
  create?: VillageCreateInput;
  update?: VillageUpdateDataInput;
  upsert?: VillageUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: VillageWhereUniqueInput;
}

export interface StreetUpdateManyMutationInput {
  code?: String;
  name?: String;
}

export interface VillageUpdateDataInput {
  code?: String;
  name?: String;
  street?: StreetUpdateOneRequiredWithoutVillagesInput;
  people?: UserUpdateManyInput;
}

export interface StreetUpdateInput {
  code?: String;
  name?: String;
  Area?: AreaUpdateOneRequiredWithoutTownsInput;
  villages?: VillageUpdateManyWithoutStreetInput;
}

export interface StreetUpdateOneRequiredWithoutVillagesInput {
  create?: StreetCreateWithoutVillagesInput;
  update?: StreetUpdateWithoutVillagesDataInput;
  upsert?: StreetUpsertWithoutVillagesInput;
  connect?: StreetWhereUniqueInput;
}

export interface CityWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  code?: String;
  code_not?: String;
  code_in?: String[] | String;
  code_not_in?: String[] | String;
  code_lt?: String;
  code_lte?: String;
  code_gt?: String;
  code_gte?: String;
  code_contains?: String;
  code_not_contains?: String;
  code_starts_with?: String;
  code_not_starts_with?: String;
  code_ends_with?: String;
  code_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  province?: ProvinceWhereInput;
  areas_every?: AreaWhereInput;
  areas_some?: AreaWhereInput;
  areas_none?: AreaWhereInput;
  AND?: CityWhereInput[] | CityWhereInput;
  OR?: CityWhereInput[] | CityWhereInput;
  NOT?: CityWhereInput[] | CityWhereInput;
}

export interface StreetUpdateWithoutVillagesDataInput {
  code?: String;
  name?: String;
  Area?: AreaUpdateOneRequiredWithoutTownsInput;
}

export interface StationUpdateInput {
  code?: String;
  name?: String;
}

export interface StreetUpsertWithoutVillagesInput {
  update: StreetUpdateWithoutVillagesDataInput;
  create: StreetCreateWithoutVillagesInput;
}

export type FindPassWordWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface VillageUpsertNestedInput {
  update: VillageUpdateDataInput;
  create: VillageCreateInput;
}

export interface UserUpdateWithoutSkillsDataInput {
  username?: String;
  password?: String;
  name?: String;
  gender?: String;
  avatar?: PhotoUpdateOneWithoutUserInput;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationUpdateOneWithoutBornsInput;
  residence?: LocationUpdateOneWithoutLivesInput;
  uid?: String;
  token?: String;
  posts?: PostUpdateManyWithoutAuthorInput;
  regStatus?: RegStatusUpdateOneWithoutApplicantsInput;
  regTimes?: Int;
  maxRegTimes?: Int;
  families?: FamilyUpdateManyWithoutFromInput;
  studies?: SchoolEduUpdateManyWithoutStudentsInput;
  works?: WorkUpdateManyWithoutWorkerInput;
  exam?: CollegeEntranceExamUpdateOneWithoutStudentInput;
  sentMessages?: MessageUpdateManyWithoutFromInput;
  receiveMessages?: MessageUpdateManyWithoutToInput;
  groupMessages?: GroupMessageUpdateManyWithoutFromInput;
  groups?: GroupUpdateManyWithoutUsersInput;
  friends?: UserUpdateManyInput;
  familyGroup?: FamilyGroupUpdateOneWithoutUsersInput;
  creater?: FamilyGroupUpdateOneWithoutCreaterInput;
  classMate?: ClassMateUpdateManyWithoutStudentInput;
  workGroup?: WorkGroupUpdateOneInput;
  colleagues?: ColleagueUpdateManyWithoutWorkerInput;
  fromOldColleagues?: OldColleagueUpdateManyWithoutFromInput;
  toOldColleagues?: OldColleagueUpdateManyWithoutToInput;
  locationGroups?: LocationGroupUpdateManyWithoutUsersInput;
  forgetPassword?: FindPassWordUpdateOneWithoutForgetterInput;
  remmemberPassword?: FindPassWordUpdateManyWithoutRemmemberInput;
  loveSetting?: LoveSettingUpdateOneWithoutUserInput;
  loveWoman?: LoveMatchingUpdateManyWithoutWomanInput;
  loveMan?: LoveMatchingUpdateManyWithoutManInput;
  signUpLove?: LoveSignUpUpdateOneWithoutPersonInput;
  fitConditions?: PartnerConditionUpdateManyWithoutPartnersInput;
  nofitConditions?: PartnerConditionUpdateManyWithoutPassedPartnersInput;
  projects?: ProjectUpdateManyWithoutStarterInput;
  trades?: TradeUpdateManyWithoutUserInput;
}

export interface SchoolUpdateManyWithoutLocationInput {
  create?:
    | SchoolCreateWithoutLocationInput[]
    | SchoolCreateWithoutLocationInput;
  delete?: SchoolWhereUniqueInput[] | SchoolWhereUniqueInput;
  connect?: SchoolWhereUniqueInput[] | SchoolWhereUniqueInput;
  disconnect?: SchoolWhereUniqueInput[] | SchoolWhereUniqueInput;
  update?:
    | SchoolUpdateWithWhereUniqueWithoutLocationInput[]
    | SchoolUpdateWithWhereUniqueWithoutLocationInput;
  upsert?:
    | SchoolUpsertWithWhereUniqueWithoutLocationInput[]
    | SchoolUpsertWithWhereUniqueWithoutLocationInput;
  deleteMany?: SchoolScalarWhereInput[] | SchoolScalarWhereInput;
  updateMany?:
    | SchoolUpdateManyWithWhereNestedInput[]
    | SchoolUpdateManyWithWhereNestedInput;
}

export type GroupWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface SchoolUpdateWithWhereUniqueWithoutLocationInput {
  where: SchoolWhereUniqueInput;
  data: SchoolUpdateWithoutLocationDataInput;
}

export interface SkillUpdateInput {
  name?: String;
  persons?: UserUpdateManyWithoutSkillsInput;
}

export interface SchoolUpdateWithoutLocationDataInput {
  name?: String;
  kind?: Educationkind;
}

export type GroupMessageWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface SchoolUpsertWithWhereUniqueWithoutLocationInput {
  where: SchoolWhereUniqueInput;
  update: SchoolUpdateWithoutLocationDataInput;
  create: SchoolCreateWithoutLocationInput;
}

export interface SkillCreateInput {
  name?: String;
  persons?: UserCreateManyWithoutSkillsInput;
}

export interface SchoolScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  kind?: Educationkind;
  kind_not?: Educationkind;
  kind_in?: Educationkind[] | Educationkind;
  kind_not_in?: Educationkind[] | Educationkind;
  AND?: SchoolScalarWhereInput[] | SchoolScalarWhereInput;
  OR?: SchoolScalarWhereInput[] | SchoolScalarWhereInput;
  NOT?: SchoolScalarWhereInput[] | SchoolScalarWhereInput;
}

export type LocationWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  name?: String;
}>;

export interface SchoolUpdateManyWithWhereNestedInput {
  where: SchoolScalarWhereInput;
  data: SchoolUpdateManyDataInput;
}

export interface SchoolUpdateManyMutationInput {
  name?: String;
  kind?: Educationkind;
}

export interface SchoolUpdateManyDataInput {
  name?: String;
  kind?: Educationkind;
}

export interface RegisterCountUpdateManyMutationInput {
  deviceId?: String;
}

export interface CompanyUpdateManyWithoutLocationInput {
  create?:
    | CompanyCreateWithoutLocationInput[]
    | CompanyCreateWithoutLocationInput;
  delete?: CompanyWhereUniqueInput[] | CompanyWhereUniqueInput;
  connect?: CompanyWhereUniqueInput[] | CompanyWhereUniqueInput;
  disconnect?: CompanyWhereUniqueInput[] | CompanyWhereUniqueInput;
  update?:
    | CompanyUpdateWithWhereUniqueWithoutLocationInput[]
    | CompanyUpdateWithWhereUniqueWithoutLocationInput;
  upsert?:
    | CompanyUpsertWithWhereUniqueWithoutLocationInput[]
    | CompanyUpsertWithWhereUniqueWithoutLocationInput;
  deleteMany?: CompanyScalarWhereInput[] | CompanyScalarWhereInput;
  updateMany?:
    | CompanyUpdateManyWithWhereNestedInput[]
    | CompanyUpdateManyWithWhereNestedInput;
}

export interface RegisterCountUpdateInput {
  addUser?: UserUpdateOneInput;
  deviceId?: String;
}

export interface CompanyUpdateWithWhereUniqueWithoutLocationInput {
  where: CompanyWhereUniqueInput;
  data: CompanyUpdateWithoutLocationDataInput;
}

export interface RegStatusUpdateManyMutationInput {
  education?: Educationkind;
}

export interface CompanyUpdateWithoutLocationDataInput {
  name?: String;
  code?: String;
  establishmentDate?: DateTimeInput;
  representative?: String;
  BusinessScope?: String;
  works?: WorkUpdateManyWithoutCompanyInput;
  workGroup?: WorkGroupUpdateOneWithoutCompanyInput;
}

export interface UserUpsertWithWhereUniqueWithoutRegStatusInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutRegStatusDataInput;
  create: UserCreateWithoutRegStatusInput;
}

export interface WorkUpdateManyWithoutCompanyInput {
  create?: WorkCreateWithoutCompanyInput[] | WorkCreateWithoutCompanyInput;
  delete?: WorkWhereUniqueInput[] | WorkWhereUniqueInput;
  connect?: WorkWhereUniqueInput[] | WorkWhereUniqueInput;
  disconnect?: WorkWhereUniqueInput[] | WorkWhereUniqueInput;
  update?:
    | WorkUpdateWithWhereUniqueWithoutCompanyInput[]
    | WorkUpdateWithWhereUniqueWithoutCompanyInput;
  upsert?:
    | WorkUpsertWithWhereUniqueWithoutCompanyInput[]
    | WorkUpsertWithWhereUniqueWithoutCompanyInput;
  deleteMany?: WorkScalarWhereInput[] | WorkScalarWhereInput;
  updateMany?:
    | WorkUpdateManyWithWhereNestedInput[]
    | WorkUpdateManyWithWhereNestedInput;
}

export interface UserUpdateWithWhereUniqueWithoutRegStatusInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutRegStatusDataInput;
}

export interface WorkUpdateWithWhereUniqueWithoutCompanyInput {
  where: WorkWhereUniqueInput;
  data: WorkUpdateWithoutCompanyDataInput;
}

export interface RegStatusUpdateInput {
  education?: Educationkind;
  university?: UniversityUpdateOneInput;
  major?: MajorUpdateOneRequiredInput;
  applicants?: UserUpdateManyWithoutRegStatusInput;
}

export interface WorkUpdateWithoutCompanyDataInput {
  startTime?: DateTimeInput;
  endTime?: DateTimeInput;
  department?: String;
  post?: StationUpdateOneInput;
  jobContent?: String;
  worker?: UserUpdateOneWithoutWorksInput;
}

export interface UserCreateWithoutRegStatusInput {
  username: String;
  password: String;
  name?: String;
  gender?: String;
  avatar?: PhotoCreateOneWithoutUserInput;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationCreateOneWithoutBornsInput;
  residence?: LocationCreateOneWithoutLivesInput;
  uid: String;
  token: String;
  posts?: PostCreateManyWithoutAuthorInput;
  regTimes?: Int;
  maxRegTimes?: Int;
  families?: FamilyCreateManyWithoutFromInput;
  studies?: SchoolEduCreateManyWithoutStudentsInput;
  works?: WorkCreateManyWithoutWorkerInput;
  exam?: CollegeEntranceExamCreateOneWithoutStudentInput;
  sentMessages?: MessageCreateManyWithoutFromInput;
  receiveMessages?: MessageCreateManyWithoutToInput;
  groupMessages?: GroupMessageCreateManyWithoutFromInput;
  groups?: GroupCreateManyWithoutUsersInput;
  friends?: UserCreateManyInput;
  familyGroup?: FamilyGroupCreateOneWithoutUsersInput;
  creater?: FamilyGroupCreateOneWithoutCreaterInput;
  classMate?: ClassMateCreateManyWithoutStudentInput;
  workGroup?: WorkGroupCreateOneInput;
  colleagues?: ColleagueCreateManyWithoutWorkerInput;
  fromOldColleagues?: OldColleagueCreateManyWithoutFromInput;
  toOldColleagues?: OldColleagueCreateManyWithoutToInput;
  locationGroups?: LocationGroupCreateManyWithoutUsersInput;
  forgetPassword?: FindPassWordCreateOneWithoutForgetterInput;
  remmemberPassword?: FindPassWordCreateManyWithoutRemmemberInput;
  loveSetting?: LoveSettingCreateOneWithoutUserInput;
  loveWoman?: LoveMatchingCreateManyWithoutWomanInput;
  loveMan?: LoveMatchingCreateManyWithoutManInput;
  signUpLove?: LoveSignUpCreateOneWithoutPersonInput;
  skills?: SkillCreateManyWithoutPersonsInput;
  fitConditions?: PartnerConditionCreateManyWithoutPartnersInput;
  nofitConditions?: PartnerConditionCreateManyWithoutPassedPartnersInput;
  projects?: ProjectCreateManyWithoutStarterInput;
  trades?: TradeCreateManyWithoutUserInput;
}

export interface StationUpdateOneInput {
  create?: StationCreateInput;
  update?: StationUpdateDataInput;
  upsert?: StationUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: StationWhereUniqueInput;
}

export interface RegStatusCreateInput {
  education: Educationkind;
  university?: UniversityCreateOneInput;
  major: MajorCreateOneInput;
  applicants?: UserCreateManyWithoutRegStatusInput;
}

export interface StationUpdateDataInput {
  code?: String;
  name?: String;
}

export interface ProvinceUpdateManyMutationInput {
  code?: String;
  name?: String;
}

export interface StationUpsertNestedInput {
  update: StationUpdateDataInput;
  create: StationCreateInput;
}

export interface ProjectUpdateManyMutationInput {
  name?: String;
  content?: String;
}

export interface UserUpdateOneWithoutWorksInput {
  create?: UserCreateWithoutWorksInput;
  update?: UserUpdateWithoutWorksDataInput;
  upsert?: UserUpsertWithoutWorksInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: UserWhereUniqueInput;
}

export type LoveSignUpWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface UserUpdateWithoutWorksDataInput {
  username?: String;
  password?: String;
  name?: String;
  gender?: String;
  avatar?: PhotoUpdateOneWithoutUserInput;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationUpdateOneWithoutBornsInput;
  residence?: LocationUpdateOneWithoutLivesInput;
  uid?: String;
  token?: String;
  posts?: PostUpdateManyWithoutAuthorInput;
  regStatus?: RegStatusUpdateOneWithoutApplicantsInput;
  regTimes?: Int;
  maxRegTimes?: Int;
  families?: FamilyUpdateManyWithoutFromInput;
  studies?: SchoolEduUpdateManyWithoutStudentsInput;
  exam?: CollegeEntranceExamUpdateOneWithoutStudentInput;
  sentMessages?: MessageUpdateManyWithoutFromInput;
  receiveMessages?: MessageUpdateManyWithoutToInput;
  groupMessages?: GroupMessageUpdateManyWithoutFromInput;
  groups?: GroupUpdateManyWithoutUsersInput;
  friends?: UserUpdateManyInput;
  familyGroup?: FamilyGroupUpdateOneWithoutUsersInput;
  creater?: FamilyGroupUpdateOneWithoutCreaterInput;
  classMate?: ClassMateUpdateManyWithoutStudentInput;
  workGroup?: WorkGroupUpdateOneInput;
  colleagues?: ColleagueUpdateManyWithoutWorkerInput;
  fromOldColleagues?: OldColleagueUpdateManyWithoutFromInput;
  toOldColleagues?: OldColleagueUpdateManyWithoutToInput;
  locationGroups?: LocationGroupUpdateManyWithoutUsersInput;
  forgetPassword?: FindPassWordUpdateOneWithoutForgetterInput;
  remmemberPassword?: FindPassWordUpdateManyWithoutRemmemberInput;
  loveSetting?: LoveSettingUpdateOneWithoutUserInput;
  loveWoman?: LoveMatchingUpdateManyWithoutWomanInput;
  loveMan?: LoveMatchingUpdateManyWithoutManInput;
  signUpLove?: LoveSignUpUpdateOneWithoutPersonInput;
  skills?: SkillUpdateManyWithoutPersonsInput;
  fitConditions?: PartnerConditionUpdateManyWithoutPartnersInput;
  nofitConditions?: PartnerConditionUpdateManyWithoutPassedPartnersInput;
  projects?: ProjectUpdateManyWithoutStarterInput;
  trades?: TradeUpdateManyWithoutUserInput;
}

export interface ProjectCreateInput {
  name?: String;
  place?: CityCreateOneInput;
  content?: String;
  conditions?: PartnerConditionCreateManyWithoutProjectInput;
  starter?: UserCreateOneWithoutProjectsInput;
}

export interface LocationUpdateOneWithoutLivesInput {
  create?: LocationCreateWithoutLivesInput;
  update?: LocationUpdateWithoutLivesDataInput;
  upsert?: LocationUpsertWithoutLivesInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: LocationWhereUniqueInput;
}

export interface ProductUpdateInput {
  subject?: String;
  info?: String;
  price?: Float;
  kind?: String;
}

export interface LocationUpdateWithoutLivesDataInput {
  name?: String;
  province?: ProvinceUpdateOneInput;
  city?: CityUpdateOneInput;
  area?: AreaUpdateOneInput;
  street?: StreetUpdateOneInput;
  village?: VillageUpdateOneInput;
  schools?: SchoolUpdateManyWithoutLocationInput;
  companies?: CompanyUpdateManyWithoutLocationInput;
  universities?: UniversityUpdateManyInput;
  borns?: UserUpdateManyWithoutBirthplaceInput;
}

export interface PostUpdateManyMutationInput {
  isPublished?: Boolean;
  title?: String;
  content?: String;
}

export interface UniversityUpdateManyInput {
  create?: UniversityCreateInput[] | UniversityCreateInput;
  update?:
    | UniversityUpdateWithWhereUniqueNestedInput[]
    | UniversityUpdateWithWhereUniqueNestedInput;
  upsert?:
    | UniversityUpsertWithWhereUniqueNestedInput[]
    | UniversityUpsertWithWhereUniqueNestedInput;
  delete?: UniversityWhereUniqueInput[] | UniversityWhereUniqueInput;
  connect?: UniversityWhereUniqueInput[] | UniversityWhereUniqueInput;
  disconnect?: UniversityWhereUniqueInput[] | UniversityWhereUniqueInput;
  deleteMany?: UniversityScalarWhereInput[] | UniversityScalarWhereInput;
  updateMany?:
    | UniversityUpdateManyWithWhereNestedInput[]
    | UniversityUpdateManyWithWhereNestedInput;
}

export interface UserUpdateWithoutPostsDataInput {
  username?: String;
  password?: String;
  name?: String;
  gender?: String;
  avatar?: PhotoUpdateOneWithoutUserInput;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationUpdateOneWithoutBornsInput;
  residence?: LocationUpdateOneWithoutLivesInput;
  uid?: String;
  token?: String;
  regStatus?: RegStatusUpdateOneWithoutApplicantsInput;
  regTimes?: Int;
  maxRegTimes?: Int;
  families?: FamilyUpdateManyWithoutFromInput;
  studies?: SchoolEduUpdateManyWithoutStudentsInput;
  works?: WorkUpdateManyWithoutWorkerInput;
  exam?: CollegeEntranceExamUpdateOneWithoutStudentInput;
  sentMessages?: MessageUpdateManyWithoutFromInput;
  receiveMessages?: MessageUpdateManyWithoutToInput;
  groupMessages?: GroupMessageUpdateManyWithoutFromInput;
  groups?: GroupUpdateManyWithoutUsersInput;
  friends?: UserUpdateManyInput;
  familyGroup?: FamilyGroupUpdateOneWithoutUsersInput;
  creater?: FamilyGroupUpdateOneWithoutCreaterInput;
  classMate?: ClassMateUpdateManyWithoutStudentInput;
  workGroup?: WorkGroupUpdateOneInput;
  colleagues?: ColleagueUpdateManyWithoutWorkerInput;
  fromOldColleagues?: OldColleagueUpdateManyWithoutFromInput;
  toOldColleagues?: OldColleagueUpdateManyWithoutToInput;
  locationGroups?: LocationGroupUpdateManyWithoutUsersInput;
  forgetPassword?: FindPassWordUpdateOneWithoutForgetterInput;
  remmemberPassword?: FindPassWordUpdateManyWithoutRemmemberInput;
  loveSetting?: LoveSettingUpdateOneWithoutUserInput;
  loveWoman?: LoveMatchingUpdateManyWithoutWomanInput;
  loveMan?: LoveMatchingUpdateManyWithoutManInput;
  signUpLove?: LoveSignUpUpdateOneWithoutPersonInput;
  skills?: SkillUpdateManyWithoutPersonsInput;
  fitConditions?: PartnerConditionUpdateManyWithoutPartnersInput;
  nofitConditions?: PartnerConditionUpdateManyWithoutPassedPartnersInput;
  projects?: ProjectUpdateManyWithoutStarterInput;
  trades?: TradeUpdateManyWithoutUserInput;
}

export interface UniversityUpdateWithWhereUniqueNestedInput {
  where: UniversityWhereUniqueInput;
  data: UniversityUpdateDataInput;
}

export type MessageWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface UniversityUpdateDataInput {
  name?: String;
  education?: Educationkind;
  department?: String;
  location?: String;
  desc?: String;
}

export interface UserCreateWithoutPostsInput {
  username: String;
  password: String;
  name?: String;
  gender?: String;
  avatar?: PhotoCreateOneWithoutUserInput;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationCreateOneWithoutBornsInput;
  residence?: LocationCreateOneWithoutLivesInput;
  uid: String;
  token: String;
  regStatus?: RegStatusCreateOneWithoutApplicantsInput;
  regTimes?: Int;
  maxRegTimes?: Int;
  families?: FamilyCreateManyWithoutFromInput;
  studies?: SchoolEduCreateManyWithoutStudentsInput;
  works?: WorkCreateManyWithoutWorkerInput;
  exam?: CollegeEntranceExamCreateOneWithoutStudentInput;
  sentMessages?: MessageCreateManyWithoutFromInput;
  receiveMessages?: MessageCreateManyWithoutToInput;
  groupMessages?: GroupMessageCreateManyWithoutFromInput;
  groups?: GroupCreateManyWithoutUsersInput;
  friends?: UserCreateManyInput;
  familyGroup?: FamilyGroupCreateOneWithoutUsersInput;
  creater?: FamilyGroupCreateOneWithoutCreaterInput;
  classMate?: ClassMateCreateManyWithoutStudentInput;
  workGroup?: WorkGroupCreateOneInput;
  colleagues?: ColleagueCreateManyWithoutWorkerInput;
  fromOldColleagues?: OldColleagueCreateManyWithoutFromInput;
  toOldColleagues?: OldColleagueCreateManyWithoutToInput;
  locationGroups?: LocationGroupCreateManyWithoutUsersInput;
  forgetPassword?: FindPassWordCreateOneWithoutForgetterInput;
  remmemberPassword?: FindPassWordCreateManyWithoutRemmemberInput;
  loveSetting?: LoveSettingCreateOneWithoutUserInput;
  loveWoman?: LoveMatchingCreateManyWithoutWomanInput;
  loveMan?: LoveMatchingCreateManyWithoutManInput;
  signUpLove?: LoveSignUpCreateOneWithoutPersonInput;
  skills?: SkillCreateManyWithoutPersonsInput;
  fitConditions?: PartnerConditionCreateManyWithoutPartnersInput;
  nofitConditions?: PartnerConditionCreateManyWithoutPassedPartnersInput;
  projects?: ProjectCreateManyWithoutStarterInput;
  trades?: TradeCreateManyWithoutUserInput;
}

export interface UniversityUpsertWithWhereUniqueNestedInput {
  where: UniversityWhereUniqueInput;
  update: UniversityUpdateDataInput;
  create: UniversityCreateInput;
}

export type OldColleagueWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface UniversityScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  education?: Educationkind;
  education_not?: Educationkind;
  education_in?: Educationkind[] | Educationkind;
  education_not_in?: Educationkind[] | Educationkind;
  department?: String;
  department_not?: String;
  department_in?: String[] | String;
  department_not_in?: String[] | String;
  department_lt?: String;
  department_lte?: String;
  department_gt?: String;
  department_gte?: String;
  department_contains?: String;
  department_not_contains?: String;
  department_starts_with?: String;
  department_not_starts_with?: String;
  department_ends_with?: String;
  department_not_ends_with?: String;
  location?: String;
  location_not?: String;
  location_in?: String[] | String;
  location_not_in?: String[] | String;
  location_lt?: String;
  location_lte?: String;
  location_gt?: String;
  location_gte?: String;
  location_contains?: String;
  location_not_contains?: String;
  location_starts_with?: String;
  location_not_starts_with?: String;
  location_ends_with?: String;
  location_not_ends_with?: String;
  desc?: String;
  desc_not?: String;
  desc_in?: String[] | String;
  desc_not_in?: String[] | String;
  desc_lt?: String;
  desc_lte?: String;
  desc_gt?: String;
  desc_gte?: String;
  desc_contains?: String;
  desc_not_contains?: String;
  desc_starts_with?: String;
  desc_not_starts_with?: String;
  desc_ends_with?: String;
  desc_not_ends_with?: String;
  AND?: UniversityScalarWhereInput[] | UniversityScalarWhereInput;
  OR?: UniversityScalarWhereInput[] | UniversityScalarWhereInput;
  NOT?: UniversityScalarWhereInput[] | UniversityScalarWhereInput;
}

export interface PhotoUpdateManyMutationInput {
  name?: String;
  url?: String;
}

export interface UniversityUpdateManyWithWhereNestedInput {
  where: UniversityScalarWhereInput;
  data: UniversityUpdateManyDataInput;
}

export type PartnerConditionWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface UniversityUpdateManyDataInput {
  name?: String;
  education?: Educationkind;
  department?: String;
  location?: String;
  desc?: String;
}

export interface PersonUpdateInput {
  name?: String;
  user?: UserUpdateOneInput;
  families?: FamilyUpdateManyWithoutToInput;
  asFather?: FamilyGroupUpdateManyWithoutFatherInput;
  asMother?: FamilyGroupUpdateManyWithoutMotherInput;
}

export interface UserUpdateManyWithoutBirthplaceInput {
  create?:
    | UserCreateWithoutBirthplaceInput[]
    | UserCreateWithoutBirthplaceInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueWithoutBirthplaceInput[]
    | UserUpdateWithWhereUniqueWithoutBirthplaceInput;
  upsert?:
    | UserUpsertWithWhereUniqueWithoutBirthplaceInput[]
    | UserUpsertWithWhereUniqueWithoutBirthplaceInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export type PersonWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface UserUpdateWithWhereUniqueWithoutBirthplaceInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutBirthplaceDataInput;
}

export interface PartnerConditionUpdateInput {
  skillName?: String;
  place?: String;
  number?: Int;
  partners?: UserUpdateManyWithoutFitConditionsInput;
  passedPartners?: UserUpdateManyWithoutNofitConditionsInput;
  project?: ProjectUpdateOneWithoutConditionsInput;
}

export interface UserUpdateWithoutBirthplaceDataInput {
  username?: String;
  password?: String;
  name?: String;
  gender?: String;
  avatar?: PhotoUpdateOneWithoutUserInput;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  residence?: LocationUpdateOneWithoutLivesInput;
  uid?: String;
  token?: String;
  posts?: PostUpdateManyWithoutAuthorInput;
  regStatus?: RegStatusUpdateOneWithoutApplicantsInput;
  regTimes?: Int;
  maxRegTimes?: Int;
  families?: FamilyUpdateManyWithoutFromInput;
  studies?: SchoolEduUpdateManyWithoutStudentsInput;
  works?: WorkUpdateManyWithoutWorkerInput;
  exam?: CollegeEntranceExamUpdateOneWithoutStudentInput;
  sentMessages?: MessageUpdateManyWithoutFromInput;
  receiveMessages?: MessageUpdateManyWithoutToInput;
  groupMessages?: GroupMessageUpdateManyWithoutFromInput;
  groups?: GroupUpdateManyWithoutUsersInput;
  friends?: UserUpdateManyInput;
  familyGroup?: FamilyGroupUpdateOneWithoutUsersInput;
  creater?: FamilyGroupUpdateOneWithoutCreaterInput;
  classMate?: ClassMateUpdateManyWithoutStudentInput;
  workGroup?: WorkGroupUpdateOneInput;
  colleagues?: ColleagueUpdateManyWithoutWorkerInput;
  fromOldColleagues?: OldColleagueUpdateManyWithoutFromInput;
  toOldColleagues?: OldColleagueUpdateManyWithoutToInput;
  locationGroups?: LocationGroupUpdateManyWithoutUsersInput;
  forgetPassword?: FindPassWordUpdateOneWithoutForgetterInput;
  remmemberPassword?: FindPassWordUpdateManyWithoutRemmemberInput;
  loveSetting?: LoveSettingUpdateOneWithoutUserInput;
  loveWoman?: LoveMatchingUpdateManyWithoutWomanInput;
  loveMan?: LoveMatchingUpdateManyWithoutManInput;
  signUpLove?: LoveSignUpUpdateOneWithoutPersonInput;
  skills?: SkillUpdateManyWithoutPersonsInput;
  fitConditions?: PartnerConditionUpdateManyWithoutPartnersInput;
  nofitConditions?: PartnerConditionUpdateManyWithoutPassedPartnersInput;
  projects?: ProjectUpdateManyWithoutStarterInput;
  trades?: TradeUpdateManyWithoutUserInput;
}

export interface OldColleagueUpdateManyMutationInput {
  status?: String;
}

export interface PostUpdateManyWithoutAuthorInput {
  create?: PostCreateWithoutAuthorInput[] | PostCreateWithoutAuthorInput;
  delete?: PostWhereUniqueInput[] | PostWhereUniqueInput;
  connect?: PostWhereUniqueInput[] | PostWhereUniqueInput;
  disconnect?: PostWhereUniqueInput[] | PostWhereUniqueInput;
  update?:
    | PostUpdateWithWhereUniqueWithoutAuthorInput[]
    | PostUpdateWithWhereUniqueWithoutAuthorInput;
  upsert?:
    | PostUpsertWithWhereUniqueWithoutAuthorInput[]
    | PostUpsertWithWhereUniqueWithoutAuthorInput;
  deleteMany?: PostScalarWhereInput[] | PostScalarWhereInput;
  updateMany?:
    | PostUpdateManyWithWhereNestedInput[]
    | PostUpdateManyWithWhereNestedInput;
}

export interface OldColleagueUpdateInput {
  from?: UserUpdateOneWithoutFromOldColleaguesInput;
  to?: UserUpdateOneWithoutToOldColleaguesInput;
  company?: CompanyUpdateOneInput;
  status?: String;
}

export interface PostUpdateWithWhereUniqueWithoutAuthorInput {
  where: PostWhereUniqueInput;
  data: PostUpdateWithoutAuthorDataInput;
}

export interface MessageUpdateManyMutationInput {
  text?: String;
}

export interface PostUpdateWithoutAuthorDataInput {
  isPublished?: Boolean;
  title?: String;
  content?: String;
}

export type PostWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface PostUpsertWithWhereUniqueWithoutAuthorInput {
  where: PostWhereUniqueInput;
  update: PostUpdateWithoutAuthorDataInput;
  create: PostCreateWithoutAuthorInput;
}

export interface MajorUpdateInput {
  name?: String;
  category?: String;
  education?: Educationkind;
}

export interface PostScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  isPublished?: Boolean;
  isPublished_not?: Boolean;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  content?: String;
  content_not?: String;
  content_in?: String[] | String;
  content_not_in?: String[] | String;
  content_lt?: String;
  content_lte?: String;
  content_gt?: String;
  content_gte?: String;
  content_contains?: String;
  content_not_contains?: String;
  content_starts_with?: String;
  content_not_starts_with?: String;
  content_ends_with?: String;
  content_not_ends_with?: String;
  AND?: PostScalarWhereInput[] | PostScalarWhereInput;
  OR?: PostScalarWhereInput[] | PostScalarWhereInput;
  NOT?: PostScalarWhereInput[] | PostScalarWhereInput;
}

export type ProductWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface PostUpdateManyWithWhereNestedInput {
  where: PostScalarWhereInput;
  data: PostUpdateManyDataInput;
}

export interface UserUpdateWithoutSignUpLoveDataInput {
  username?: String;
  password?: String;
  name?: String;
  gender?: String;
  avatar?: PhotoUpdateOneWithoutUserInput;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationUpdateOneWithoutBornsInput;
  residence?: LocationUpdateOneWithoutLivesInput;
  uid?: String;
  token?: String;
  posts?: PostUpdateManyWithoutAuthorInput;
  regStatus?: RegStatusUpdateOneWithoutApplicantsInput;
  regTimes?: Int;
  maxRegTimes?: Int;
  families?: FamilyUpdateManyWithoutFromInput;
  studies?: SchoolEduUpdateManyWithoutStudentsInput;
  works?: WorkUpdateManyWithoutWorkerInput;
  exam?: CollegeEntranceExamUpdateOneWithoutStudentInput;
  sentMessages?: MessageUpdateManyWithoutFromInput;
  receiveMessages?: MessageUpdateManyWithoutToInput;
  groupMessages?: GroupMessageUpdateManyWithoutFromInput;
  groups?: GroupUpdateManyWithoutUsersInput;
  friends?: UserUpdateManyInput;
  familyGroup?: FamilyGroupUpdateOneWithoutUsersInput;
  creater?: FamilyGroupUpdateOneWithoutCreaterInput;
  classMate?: ClassMateUpdateManyWithoutStudentInput;
  workGroup?: WorkGroupUpdateOneInput;
  colleagues?: ColleagueUpdateManyWithoutWorkerInput;
  fromOldColleagues?: OldColleagueUpdateManyWithoutFromInput;
  toOldColleagues?: OldColleagueUpdateManyWithoutToInput;
  locationGroups?: LocationGroupUpdateManyWithoutUsersInput;
  forgetPassword?: FindPassWordUpdateOneWithoutForgetterInput;
  remmemberPassword?: FindPassWordUpdateManyWithoutRemmemberInput;
  loveSetting?: LoveSettingUpdateOneWithoutUserInput;
  loveWoman?: LoveMatchingUpdateManyWithoutWomanInput;
  loveMan?: LoveMatchingUpdateManyWithoutManInput;
  skills?: SkillUpdateManyWithoutPersonsInput;
  fitConditions?: PartnerConditionUpdateManyWithoutPartnersInput;
  nofitConditions?: PartnerConditionUpdateManyWithoutPassedPartnersInput;
  projects?: ProjectUpdateManyWithoutStarterInput;
  trades?: TradeUpdateManyWithoutUserInput;
}

export interface PostUpdateManyDataInput {
  isPublished?: Boolean;
  title?: String;
  content?: String;
}

export interface LoveSignUpUpdateInput {
  period?: String;
  city?: CityUpdateOneInput;
  person?: UserUpdateOneWithoutSignUpLoveInput;
}

export interface RegStatusUpdateOneWithoutApplicantsInput {
  create?: RegStatusCreateWithoutApplicantsInput;
  update?: RegStatusUpdateWithoutApplicantsDataInput;
  upsert?: RegStatusUpsertWithoutApplicantsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: RegStatusWhereUniqueInput;
}

export interface UserCreateWithoutSignUpLoveInput {
  username: String;
  password: String;
  name?: String;
  gender?: String;
  avatar?: PhotoCreateOneWithoutUserInput;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationCreateOneWithoutBornsInput;
  residence?: LocationCreateOneWithoutLivesInput;
  uid: String;
  token: String;
  posts?: PostCreateManyWithoutAuthorInput;
  regStatus?: RegStatusCreateOneWithoutApplicantsInput;
  regTimes?: Int;
  maxRegTimes?: Int;
  families?: FamilyCreateManyWithoutFromInput;
  studies?: SchoolEduCreateManyWithoutStudentsInput;
  works?: WorkCreateManyWithoutWorkerInput;
  exam?: CollegeEntranceExamCreateOneWithoutStudentInput;
  sentMessages?: MessageCreateManyWithoutFromInput;
  receiveMessages?: MessageCreateManyWithoutToInput;
  groupMessages?: GroupMessageCreateManyWithoutFromInput;
  groups?: GroupCreateManyWithoutUsersInput;
  friends?: UserCreateManyInput;
  familyGroup?: FamilyGroupCreateOneWithoutUsersInput;
  creater?: FamilyGroupCreateOneWithoutCreaterInput;
  classMate?: ClassMateCreateManyWithoutStudentInput;
  workGroup?: WorkGroupCreateOneInput;
  colleagues?: ColleagueCreateManyWithoutWorkerInput;
  fromOldColleagues?: OldColleagueCreateManyWithoutFromInput;
  toOldColleagues?: OldColleagueCreateManyWithoutToInput;
  locationGroups?: LocationGroupCreateManyWithoutUsersInput;
  forgetPassword?: FindPassWordCreateOneWithoutForgetterInput;
  remmemberPassword?: FindPassWordCreateManyWithoutRemmemberInput;
  loveSetting?: LoveSettingCreateOneWithoutUserInput;
  loveWoman?: LoveMatchingCreateManyWithoutWomanInput;
  loveMan?: LoveMatchingCreateManyWithoutManInput;
  skills?: SkillCreateManyWithoutPersonsInput;
  fitConditions?: PartnerConditionCreateManyWithoutPartnersInput;
  nofitConditions?: PartnerConditionCreateManyWithoutPassedPartnersInput;
  projects?: ProjectCreateManyWithoutStarterInput;
  trades?: TradeCreateManyWithoutUserInput;
}

export interface RegStatusUpdateWithoutApplicantsDataInput {
  education?: Educationkind;
  university?: UniversityUpdateOneInput;
  major?: MajorUpdateOneRequiredInput;
}

export interface LoveSignUpCreateInput {
  period?: String;
  city?: CityCreateOneInput;
  person?: UserCreateOneWithoutSignUpLoveInput;
}

export interface UniversityUpdateOneInput {
  create?: UniversityCreateInput;
  update?: UniversityUpdateDataInput;
  upsert?: UniversityUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: UniversityWhereUniqueInput;
}

export interface LoveSettingUpdateManyMutationInput {
  myHeight?: Int;
  myWeight?: Int;
  otherHeightMin?: Int;
  otherHeightMax?: Int;
  otherWeightMin?: Int;
  otherWeightMax?: Int;
  otherAgeMin?: Int;
  otherAgeMax?: Int;
  dateTime?: String;
  datePlace?: String;
  memeberGrade?: Int;
  memeberGradeEndTime?: String;
}

export interface UniversityUpsertNestedInput {
  update: UniversityUpdateDataInput;
  create: UniversityCreateInput;
}

export interface UserUpdateWithoutLoveSettingDataInput {
  username?: String;
  password?: String;
  name?: String;
  gender?: String;
  avatar?: PhotoUpdateOneWithoutUserInput;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationUpdateOneWithoutBornsInput;
  residence?: LocationUpdateOneWithoutLivesInput;
  uid?: String;
  token?: String;
  posts?: PostUpdateManyWithoutAuthorInput;
  regStatus?: RegStatusUpdateOneWithoutApplicantsInput;
  regTimes?: Int;
  maxRegTimes?: Int;
  families?: FamilyUpdateManyWithoutFromInput;
  studies?: SchoolEduUpdateManyWithoutStudentsInput;
  works?: WorkUpdateManyWithoutWorkerInput;
  exam?: CollegeEntranceExamUpdateOneWithoutStudentInput;
  sentMessages?: MessageUpdateManyWithoutFromInput;
  receiveMessages?: MessageUpdateManyWithoutToInput;
  groupMessages?: GroupMessageUpdateManyWithoutFromInput;
  groups?: GroupUpdateManyWithoutUsersInput;
  friends?: UserUpdateManyInput;
  familyGroup?: FamilyGroupUpdateOneWithoutUsersInput;
  creater?: FamilyGroupUpdateOneWithoutCreaterInput;
  classMate?: ClassMateUpdateManyWithoutStudentInput;
  workGroup?: WorkGroupUpdateOneInput;
  colleagues?: ColleagueUpdateManyWithoutWorkerInput;
  fromOldColleagues?: OldColleagueUpdateManyWithoutFromInput;
  toOldColleagues?: OldColleagueUpdateManyWithoutToInput;
  locationGroups?: LocationGroupUpdateManyWithoutUsersInput;
  forgetPassword?: FindPassWordUpdateOneWithoutForgetterInput;
  remmemberPassword?: FindPassWordUpdateManyWithoutRemmemberInput;
  loveWoman?: LoveMatchingUpdateManyWithoutWomanInput;
  loveMan?: LoveMatchingUpdateManyWithoutManInput;
  signUpLove?: LoveSignUpUpdateOneWithoutPersonInput;
  skills?: SkillUpdateManyWithoutPersonsInput;
  fitConditions?: PartnerConditionUpdateManyWithoutPartnersInput;
  nofitConditions?: PartnerConditionUpdateManyWithoutPassedPartnersInput;
  projects?: ProjectUpdateManyWithoutStarterInput;
  trades?: TradeUpdateManyWithoutUserInput;
}

export interface MajorUpdateOneRequiredInput {
  create?: MajorCreateInput;
  update?: MajorUpdateDataInput;
  upsert?: MajorUpsertNestedInput;
  connect?: MajorWhereUniqueInput;
}

export type RegStatusWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface MajorUpdateDataInput {
  name?: String;
  category?: String;
  education?: Educationkind;
}

export interface UserCreateWithoutLoveSettingInput {
  username: String;
  password: String;
  name?: String;
  gender?: String;
  avatar?: PhotoCreateOneWithoutUserInput;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationCreateOneWithoutBornsInput;
  residence?: LocationCreateOneWithoutLivesInput;
  uid: String;
  token: String;
  posts?: PostCreateManyWithoutAuthorInput;
  regStatus?: RegStatusCreateOneWithoutApplicantsInput;
  regTimes?: Int;
  maxRegTimes?: Int;
  families?: FamilyCreateManyWithoutFromInput;
  studies?: SchoolEduCreateManyWithoutStudentsInput;
  works?: WorkCreateManyWithoutWorkerInput;
  exam?: CollegeEntranceExamCreateOneWithoutStudentInput;
  sentMessages?: MessageCreateManyWithoutFromInput;
  receiveMessages?: MessageCreateManyWithoutToInput;
  groupMessages?: GroupMessageCreateManyWithoutFromInput;
  groups?: GroupCreateManyWithoutUsersInput;
  friends?: UserCreateManyInput;
  familyGroup?: FamilyGroupCreateOneWithoutUsersInput;
  creater?: FamilyGroupCreateOneWithoutCreaterInput;
  classMate?: ClassMateCreateManyWithoutStudentInput;
  workGroup?: WorkGroupCreateOneInput;
  colleagues?: ColleagueCreateManyWithoutWorkerInput;
  fromOldColleagues?: OldColleagueCreateManyWithoutFromInput;
  toOldColleagues?: OldColleagueCreateManyWithoutToInput;
  locationGroups?: LocationGroupCreateManyWithoutUsersInput;
  forgetPassword?: FindPassWordCreateOneWithoutForgetterInput;
  remmemberPassword?: FindPassWordCreateManyWithoutRemmemberInput;
  loveWoman?: LoveMatchingCreateManyWithoutWomanInput;
  loveMan?: LoveMatchingCreateManyWithoutManInput;
  signUpLove?: LoveSignUpCreateOneWithoutPersonInput;
  skills?: SkillCreateManyWithoutPersonsInput;
  fitConditions?: PartnerConditionCreateManyWithoutPartnersInput;
  nofitConditions?: PartnerConditionCreateManyWithoutPassedPartnersInput;
  projects?: ProjectCreateManyWithoutStarterInput;
  trades?: TradeCreateManyWithoutUserInput;
}

export interface MajorUpsertNestedInput {
  update: MajorUpdateDataInput;
  create: MajorCreateInput;
}

export interface LoveSettingCreateInput {
  myHeight?: Int;
  myWeight?: Int;
  otherHeightMin?: Int;
  otherHeightMax?: Int;
  otherWeightMin?: Int;
  otherWeightMax?: Int;
  otherAgeMin?: Int;
  otherAgeMax?: Int;
  dateTime?: String;
  datePlace?: String;
  memeberGrade?: Int;
  memeberGradeEndTime?: String;
  user: UserCreateOneWithoutLoveSettingInput;
}

export interface RegStatusUpsertWithoutApplicantsInput {
  update: RegStatusUpdateWithoutApplicantsDataInput;
  create: RegStatusCreateWithoutApplicantsInput;
}

export interface LoveMatchingUpdateManyMutationInput {
  period?: String;
}

export interface FamilyUpdateManyWithoutFromInput {
  create?: FamilyCreateWithoutFromInput[] | FamilyCreateWithoutFromInput;
  delete?: FamilyWhereUniqueInput[] | FamilyWhereUniqueInput;
  connect?: FamilyWhereUniqueInput[] | FamilyWhereUniqueInput;
  disconnect?: FamilyWhereUniqueInput[] | FamilyWhereUniqueInput;
  update?:
    | FamilyUpdateWithWhereUniqueWithoutFromInput[]
    | FamilyUpdateWithWhereUniqueWithoutFromInput;
  upsert?:
    | FamilyUpsertWithWhereUniqueWithoutFromInput[]
    | FamilyUpsertWithWhereUniqueWithoutFromInput;
  deleteMany?: FamilyScalarWhereInput[] | FamilyScalarWhereInput;
  updateMany?:
    | FamilyUpdateManyWithWhereNestedInput[]
    | FamilyUpdateManyWithWhereNestedInput;
}

export interface AdvertisementWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  image1?: String;
  image1_not?: String;
  image1_in?: String[] | String;
  image1_not_in?: String[] | String;
  image1_lt?: String;
  image1_lte?: String;
  image1_gt?: String;
  image1_gte?: String;
  image1_contains?: String;
  image1_not_contains?: String;
  image1_starts_with?: String;
  image1_not_starts_with?: String;
  image1_ends_with?: String;
  image1_not_ends_with?: String;
  image2?: String;
  image2_not?: String;
  image2_in?: String[] | String;
  image2_not_in?: String[] | String;
  image2_lt?: String;
  image2_lte?: String;
  image2_gt?: String;
  image2_gte?: String;
  image2_contains?: String;
  image2_not_contains?: String;
  image2_starts_with?: String;
  image2_not_starts_with?: String;
  image2_ends_with?: String;
  image2_not_ends_with?: String;
  image3?: String;
  image3_not?: String;
  image3_in?: String[] | String;
  image3_not_in?: String[] | String;
  image3_lt?: String;
  image3_lte?: String;
  image3_gt?: String;
  image3_gte?: String;
  image3_contains?: String;
  image3_not_contains?: String;
  image3_starts_with?: String;
  image3_not_starts_with?: String;
  image3_ends_with?: String;
  image3_not_ends_with?: String;
  image4?: String;
  image4_not?: String;
  image4_in?: String[] | String;
  image4_not_in?: String[] | String;
  image4_lt?: String;
  image4_lte?: String;
  image4_gt?: String;
  image4_gte?: String;
  image4_contains?: String;
  image4_not_contains?: String;
  image4_starts_with?: String;
  image4_not_starts_with?: String;
  image4_ends_with?: String;
  image4_not_ends_with?: String;
  image5?: String;
  image5_not?: String;
  image5_in?: String[] | String;
  image5_not_in?: String[] | String;
  image5_lt?: String;
  image5_lte?: String;
  image5_gt?: String;
  image5_gte?: String;
  image5_contains?: String;
  image5_not_contains?: String;
  image5_starts_with?: String;
  image5_not_starts_with?: String;
  image5_ends_with?: String;
  image5_not_ends_with?: String;
  startTime?: DateTimeInput;
  startTime_not?: DateTimeInput;
  startTime_in?: DateTimeInput[] | DateTimeInput;
  startTime_not_in?: DateTimeInput[] | DateTimeInput;
  startTime_lt?: DateTimeInput;
  startTime_lte?: DateTimeInput;
  startTime_gt?: DateTimeInput;
  startTime_gte?: DateTimeInput;
  endTime?: DateTimeInput;
  endTime_not?: DateTimeInput;
  endTime_in?: DateTimeInput[] | DateTimeInput;
  endTime_not_in?: DateTimeInput[] | DateTimeInput;
  endTime_lt?: DateTimeInput;
  endTime_lte?: DateTimeInput;
  endTime_gt?: DateTimeInput;
  endTime_gte?: DateTimeInput;
  AND?: AdvertisementWhereInput[] | AdvertisementWhereInput;
  OR?: AdvertisementWhereInput[] | AdvertisementWhereInput;
  NOT?: AdvertisementWhereInput[] | AdvertisementWhereInput;
}

export interface FamilyUpdateWithWhereUniqueWithoutFromInput {
  where: FamilyWhereUniqueInput;
  data: FamilyUpdateWithoutFromDataInput;
}

export interface LoveMatchingCreateInput {
  period?: String;
  city?: CityCreateOneInput;
  woman?: UserCreateOneWithoutLoveWomanInput;
  man?: UserCreateOneWithoutLoveManInput;
}

export interface FamilyUpdateWithoutFromDataInput {
  to?: PersonUpdateOneRequiredWithoutFamiliesInput;
  relationship?: String;
  spouse?: FamilyUpdateOneInput;
  status?: String;
}

export interface ClassGroupWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  study?: SchoolEduWhereInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  members_every?: ClassMateWhereInput;
  members_some?: ClassMateWhereInput;
  members_none?: ClassMateWhereInput;
  AND?: ClassGroupWhereInput[] | ClassGroupWhereInput;
  OR?: ClassGroupWhereInput[] | ClassGroupWhereInput;
  NOT?: ClassGroupWhereInput[] | ClassGroupWhereInput;
}

export interface PersonUpdateOneRequiredWithoutFamiliesInput {
  create?: PersonCreateWithoutFamiliesInput;
  update?: PersonUpdateWithoutFamiliesDataInput;
  upsert?: PersonUpsertWithoutFamiliesInput;
  connect?: PersonWhereUniqueInput;
}

export interface LocationGroupUpdateManyMutationInput {
  kind?: LocationGroupKind;
  code?: String;
  name?: String;
}

export interface PersonUpdateWithoutFamiliesDataInput {
  name?: String;
  user?: UserUpdateOneInput;
  asFather?: FamilyGroupUpdateManyWithoutFatherInput;
  asMother?: FamilyGroupUpdateManyWithoutMotherInput;
}

export type SchoolEduWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface UserUpdateOneInput {
  create?: UserCreateInput;
  update?: UserUpdateDataInput;
  upsert?: UserUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateWithWhereUniqueWithoutLocationGroupsInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutLocationGroupsDataInput;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export type SkillWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  name?: String;
}>;

export interface FamilyGroupUpdateManyWithoutFatherInput {
  create?:
    | FamilyGroupCreateWithoutFatherInput[]
    | FamilyGroupCreateWithoutFatherInput;
  delete?: FamilyGroupWhereUniqueInput[] | FamilyGroupWhereUniqueInput;
  connect?: FamilyGroupWhereUniqueInput[] | FamilyGroupWhereUniqueInput;
  disconnect?: FamilyGroupWhereUniqueInput[] | FamilyGroupWhereUniqueInput;
  update?:
    | FamilyGroupUpdateWithWhereUniqueWithoutFatherInput[]
    | FamilyGroupUpdateWithWhereUniqueWithoutFatherInput;
  upsert?:
    | FamilyGroupUpsertWithWhereUniqueWithoutFatherInput[]
    | FamilyGroupUpsertWithWhereUniqueWithoutFatherInput;
  deleteMany?: FamilyGroupScalarWhereInput[] | FamilyGroupScalarWhereInput;
  updateMany?:
    | FamilyGroupUpdateManyWithWhereNestedInput[]
    | FamilyGroupUpdateManyWithWhereNestedInput;
}

export interface UserCreateWithoutLocationGroupsInput {
  username: String;
  password: String;
  name?: String;
  gender?: String;
  avatar?: PhotoCreateOneWithoutUserInput;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationCreateOneWithoutBornsInput;
  residence?: LocationCreateOneWithoutLivesInput;
  uid: String;
  token: String;
  posts?: PostCreateManyWithoutAuthorInput;
  regStatus?: RegStatusCreateOneWithoutApplicantsInput;
  regTimes?: Int;
  maxRegTimes?: Int;
  families?: FamilyCreateManyWithoutFromInput;
  studies?: SchoolEduCreateManyWithoutStudentsInput;
  works?: WorkCreateManyWithoutWorkerInput;
  exam?: CollegeEntranceExamCreateOneWithoutStudentInput;
  sentMessages?: MessageCreateManyWithoutFromInput;
  receiveMessages?: MessageCreateManyWithoutToInput;
  groupMessages?: GroupMessageCreateManyWithoutFromInput;
  groups?: GroupCreateManyWithoutUsersInput;
  friends?: UserCreateManyInput;
  familyGroup?: FamilyGroupCreateOneWithoutUsersInput;
  creater?: FamilyGroupCreateOneWithoutCreaterInput;
  classMate?: ClassMateCreateManyWithoutStudentInput;
  workGroup?: WorkGroupCreateOneInput;
  colleagues?: ColleagueCreateManyWithoutWorkerInput;
  fromOldColleagues?: OldColleagueCreateManyWithoutFromInput;
  toOldColleagues?: OldColleagueCreateManyWithoutToInput;
  forgetPassword?: FindPassWordCreateOneWithoutForgetterInput;
  remmemberPassword?: FindPassWordCreateManyWithoutRemmemberInput;
  loveSetting?: LoveSettingCreateOneWithoutUserInput;
  loveWoman?: LoveMatchingCreateManyWithoutWomanInput;
  loveMan?: LoveMatchingCreateManyWithoutManInput;
  signUpLove?: LoveSignUpCreateOneWithoutPersonInput;
  skills?: SkillCreateManyWithoutPersonsInput;
  fitConditions?: PartnerConditionCreateManyWithoutPartnersInput;
  nofitConditions?: PartnerConditionCreateManyWithoutPassedPartnersInput;
  projects?: ProjectCreateManyWithoutStarterInput;
  trades?: TradeCreateManyWithoutUserInput;
}

export interface FamilyGroupUpdateWithWhereUniqueWithoutFatherInput {
  where: FamilyGroupWhereUniqueInput;
  data: FamilyGroupUpdateWithoutFatherDataInput;
}

export type StationWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  code?: String;
  name?: String;
}>;

export interface FamilyGroupUpdateWithoutFatherDataInput {
  mother?: PersonUpdateOneWithoutAsMotherInput;
  creater?: UserUpdateOneWithoutCreaterInput;
  name?: String;
  families?: FamilyUpdateManyInput;
  users?: UserUpdateManyWithoutFamilyGroupInput;
}

export interface LocationUpdateManyMutationInput {
  name?: String;
}

export interface PersonUpdateOneWithoutAsMotherInput {
  create?: PersonCreateWithoutAsMotherInput;
  update?: PersonUpdateWithoutAsMotherDataInput;
  upsert?: PersonUpsertWithoutAsMotherInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: PersonWhereUniqueInput;
}

export interface LocationCreateInput {
  name?: String;
  province?: ProvinceCreateOneInput;
  city?: CityCreateOneInput;
  area?: AreaCreateOneInput;
  street?: StreetCreateOneInput;
  village?: VillageCreateOneInput;
  schools?: SchoolCreateManyWithoutLocationInput;
  companies?: CompanyCreateManyWithoutLocationInput;
  universities?: UniversityCreateManyInput;
  borns?: UserCreateManyWithoutBirthplaceInput;
  lives?: UserCreateManyWithoutResidenceInput;
}

export interface PersonUpdateWithoutAsMotherDataInput {
  name?: String;
  user?: UserUpdateOneInput;
  families?: FamilyUpdateManyWithoutToInput;
  asFather?: FamilyGroupUpdateManyWithoutFatherInput;
}

export interface GroupMessageUpdateManyMutationInput {
  type?: GroupKind;
  to?: String;
  text?: String;
}

export interface FamilyUpdateManyWithoutToInput {
  create?: FamilyCreateWithoutToInput[] | FamilyCreateWithoutToInput;
  delete?: FamilyWhereUniqueInput[] | FamilyWhereUniqueInput;
  connect?: FamilyWhereUniqueInput[] | FamilyWhereUniqueInput;
  disconnect?: FamilyWhereUniqueInput[] | FamilyWhereUniqueInput;
  update?:
    | FamilyUpdateWithWhereUniqueWithoutToInput[]
    | FamilyUpdateWithWhereUniqueWithoutToInput;
  upsert?:
    | FamilyUpsertWithWhereUniqueWithoutToInput[]
    | FamilyUpsertWithWhereUniqueWithoutToInput;
  deleteMany?: FamilyScalarWhereInput[] | FamilyScalarWhereInput;
  updateMany?:
    | FamilyUpdateManyWithWhereNestedInput[]
    | FamilyUpdateManyWithWhereNestedInput;
}

export interface UserUpdateWithoutGroupMessagesDataInput {
  username?: String;
  password?: String;
  name?: String;
  gender?: String;
  avatar?: PhotoUpdateOneWithoutUserInput;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationUpdateOneWithoutBornsInput;
  residence?: LocationUpdateOneWithoutLivesInput;
  uid?: String;
  token?: String;
  posts?: PostUpdateManyWithoutAuthorInput;
  regStatus?: RegStatusUpdateOneWithoutApplicantsInput;
  regTimes?: Int;
  maxRegTimes?: Int;
  families?: FamilyUpdateManyWithoutFromInput;
  studies?: SchoolEduUpdateManyWithoutStudentsInput;
  works?: WorkUpdateManyWithoutWorkerInput;
  exam?: CollegeEntranceExamUpdateOneWithoutStudentInput;
  sentMessages?: MessageUpdateManyWithoutFromInput;
  receiveMessages?: MessageUpdateManyWithoutToInput;
  groups?: GroupUpdateManyWithoutUsersInput;
  friends?: UserUpdateManyInput;
  familyGroup?: FamilyGroupUpdateOneWithoutUsersInput;
  creater?: FamilyGroupUpdateOneWithoutCreaterInput;
  classMate?: ClassMateUpdateManyWithoutStudentInput;
  workGroup?: WorkGroupUpdateOneInput;
  colleagues?: ColleagueUpdateManyWithoutWorkerInput;
  fromOldColleagues?: OldColleagueUpdateManyWithoutFromInput;
  toOldColleagues?: OldColleagueUpdateManyWithoutToInput;
  locationGroups?: LocationGroupUpdateManyWithoutUsersInput;
  forgetPassword?: FindPassWordUpdateOneWithoutForgetterInput;
  remmemberPassword?: FindPassWordUpdateManyWithoutRemmemberInput;
  loveSetting?: LoveSettingUpdateOneWithoutUserInput;
  loveWoman?: LoveMatchingUpdateManyWithoutWomanInput;
  loveMan?: LoveMatchingUpdateManyWithoutManInput;
  signUpLove?: LoveSignUpUpdateOneWithoutPersonInput;
  skills?: SkillUpdateManyWithoutPersonsInput;
  fitConditions?: PartnerConditionUpdateManyWithoutPartnersInput;
  nofitConditions?: PartnerConditionUpdateManyWithoutPassedPartnersInput;
  projects?: ProjectUpdateManyWithoutStarterInput;
  trades?: TradeUpdateManyWithoutUserInput;
}

export interface FamilyUpdateWithWhereUniqueWithoutToInput {
  where: FamilyWhereUniqueInput;
  data: FamilyUpdateWithoutToDataInput;
}

export interface UserUpdateOneRequiredWithoutGroupMessagesInput {
  create?: UserCreateWithoutGroupMessagesInput;
  update?: UserUpdateWithoutGroupMessagesDataInput;
  upsert?: UserUpsertWithoutGroupMessagesInput;
  connect?: UserWhereUniqueInput;
}

export interface FamilyUpdateWithoutToDataInput {
  from?: UserUpdateOneRequiredWithoutFamiliesInput;
  relationship?: String;
  spouse?: FamilyUpdateOneInput;
  status?: String;
}

export interface UserCreateWithoutGroupMessagesInput {
  username: String;
  password: String;
  name?: String;
  gender?: String;
  avatar?: PhotoCreateOneWithoutUserInput;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationCreateOneWithoutBornsInput;
  residence?: LocationCreateOneWithoutLivesInput;
  uid: String;
  token: String;
  posts?: PostCreateManyWithoutAuthorInput;
  regStatus?: RegStatusCreateOneWithoutApplicantsInput;
  regTimes?: Int;
  maxRegTimes?: Int;
  families?: FamilyCreateManyWithoutFromInput;
  studies?: SchoolEduCreateManyWithoutStudentsInput;
  works?: WorkCreateManyWithoutWorkerInput;
  exam?: CollegeEntranceExamCreateOneWithoutStudentInput;
  sentMessages?: MessageCreateManyWithoutFromInput;
  receiveMessages?: MessageCreateManyWithoutToInput;
  groups?: GroupCreateManyWithoutUsersInput;
  friends?: UserCreateManyInput;
  familyGroup?: FamilyGroupCreateOneWithoutUsersInput;
  creater?: FamilyGroupCreateOneWithoutCreaterInput;
  classMate?: ClassMateCreateManyWithoutStudentInput;
  workGroup?: WorkGroupCreateOneInput;
  colleagues?: ColleagueCreateManyWithoutWorkerInput;
  fromOldColleagues?: OldColleagueCreateManyWithoutFromInput;
  toOldColleagues?: OldColleagueCreateManyWithoutToInput;
  locationGroups?: LocationGroupCreateManyWithoutUsersInput;
  forgetPassword?: FindPassWordCreateOneWithoutForgetterInput;
  remmemberPassword?: FindPassWordCreateManyWithoutRemmemberInput;
  loveSetting?: LoveSettingCreateOneWithoutUserInput;
  loveWoman?: LoveMatchingCreateManyWithoutWomanInput;
  loveMan?: LoveMatchingCreateManyWithoutManInput;
  signUpLove?: LoveSignUpCreateOneWithoutPersonInput;
  skills?: SkillCreateManyWithoutPersonsInput;
  fitConditions?: PartnerConditionCreateManyWithoutPartnersInput;
  nofitConditions?: PartnerConditionCreateManyWithoutPassedPartnersInput;
  projects?: ProjectCreateManyWithoutStarterInput;
  trades?: TradeCreateManyWithoutUserInput;
}

export interface UserUpdateOneRequiredWithoutFamiliesInput {
  create?: UserCreateWithoutFamiliesInput;
  update?: UserUpdateWithoutFamiliesDataInput;
  upsert?: UserUpsertWithoutFamiliesInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateOneWithoutGroupMessagesInput {
  create?: UserCreateWithoutGroupMessagesInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateWithoutFamiliesDataInput {
  username?: String;
  password?: String;
  name?: String;
  gender?: String;
  avatar?: PhotoUpdateOneWithoutUserInput;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationUpdateOneWithoutBornsInput;
  residence?: LocationUpdateOneWithoutLivesInput;
  uid?: String;
  token?: String;
  posts?: PostUpdateManyWithoutAuthorInput;
  regStatus?: RegStatusUpdateOneWithoutApplicantsInput;
  regTimes?: Int;
  maxRegTimes?: Int;
  studies?: SchoolEduUpdateManyWithoutStudentsInput;
  works?: WorkUpdateManyWithoutWorkerInput;
  exam?: CollegeEntranceExamUpdateOneWithoutStudentInput;
  sentMessages?: MessageUpdateManyWithoutFromInput;
  receiveMessages?: MessageUpdateManyWithoutToInput;
  groupMessages?: GroupMessageUpdateManyWithoutFromInput;
  groups?: GroupUpdateManyWithoutUsersInput;
  friends?: UserUpdateManyInput;
  familyGroup?: FamilyGroupUpdateOneWithoutUsersInput;
  creater?: FamilyGroupUpdateOneWithoutCreaterInput;
  classMate?: ClassMateUpdateManyWithoutStudentInput;
  workGroup?: WorkGroupUpdateOneInput;
  colleagues?: ColleagueUpdateManyWithoutWorkerInput;
  fromOldColleagues?: OldColleagueUpdateManyWithoutFromInput;
  toOldColleagues?: OldColleagueUpdateManyWithoutToInput;
  locationGroups?: LocationGroupUpdateManyWithoutUsersInput;
  forgetPassword?: FindPassWordUpdateOneWithoutForgetterInput;
  remmemberPassword?: FindPassWordUpdateManyWithoutRemmemberInput;
  loveSetting?: LoveSettingUpdateOneWithoutUserInput;
  loveWoman?: LoveMatchingUpdateManyWithoutWomanInput;
  loveMan?: LoveMatchingUpdateManyWithoutManInput;
  signUpLove?: LoveSignUpUpdateOneWithoutPersonInput;
  skills?: SkillUpdateManyWithoutPersonsInput;
  fitConditions?: PartnerConditionUpdateManyWithoutPartnersInput;
  nofitConditions?: PartnerConditionUpdateManyWithoutPassedPartnersInput;
  projects?: ProjectUpdateManyWithoutStarterInput;
  trades?: TradeUpdateManyWithoutUserInput;
}

export interface GroupUpdateManyMutationInput {
  type?: GroupKind;
  name?: String;
}

export interface SchoolEduUpdateManyWithoutStudentsInput {
  create?:
    | SchoolEduCreateWithoutStudentsInput[]
    | SchoolEduCreateWithoutStudentsInput;
  delete?: SchoolEduWhereUniqueInput[] | SchoolEduWhereUniqueInput;
  connect?: SchoolEduWhereUniqueInput[] | SchoolEduWhereUniqueInput;
  disconnect?: SchoolEduWhereUniqueInput[] | SchoolEduWhereUniqueInput;
  update?:
    | SchoolEduUpdateWithWhereUniqueWithoutStudentsInput[]
    | SchoolEduUpdateWithWhereUniqueWithoutStudentsInput;
  upsert?:
    | SchoolEduUpsertWithWhereUniqueWithoutStudentsInput[]
    | SchoolEduUpsertWithWhereUniqueWithoutStudentsInput;
  deleteMany?: SchoolEduScalarWhereInput[] | SchoolEduScalarWhereInput;
  updateMany?:
    | SchoolEduUpdateManyWithWhereNestedInput[]
    | SchoolEduUpdateManyWithWhereNestedInput;
}

export interface UserUpsertWithWhereUniqueWithoutGroupsInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutGroupsDataInput;
  create: UserCreateWithoutGroupsInput;
}

export interface SchoolEduUpdateWithWhereUniqueWithoutStudentsInput {
  where: SchoolEduWhereUniqueInput;
  data: SchoolEduUpdateWithoutStudentsDataInput;
}

export interface UserUpdateWithWhereUniqueWithoutGroupsInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutGroupsDataInput;
}

export interface SchoolEduUpdateWithoutStudentsDataInput {
  school?: SchoolUpdateOneInput;
  startTime?: DateTimeInput;
  major?: MajorUpdateOneInput;
  grade?: Int;
  className?: String;
}

export interface UserUpdateManyWithoutGroupsInput {
  create?: UserCreateWithoutGroupsInput[] | UserCreateWithoutGroupsInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueWithoutGroupsInput[]
    | UserUpdateWithWhereUniqueWithoutGroupsInput;
  upsert?:
    | UserUpsertWithWhereUniqueWithoutGroupsInput[]
    | UserUpsertWithWhereUniqueWithoutGroupsInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export interface SchoolUpdateOneInput {
  create?: SchoolCreateInput;
  update?: SchoolUpdateDataInput;
  upsert?: SchoolUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: SchoolWhereUniqueInput;
}

export interface UserCreateWithoutGroupsInput {
  username: String;
  password: String;
  name?: String;
  gender?: String;
  avatar?: PhotoCreateOneWithoutUserInput;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationCreateOneWithoutBornsInput;
  residence?: LocationCreateOneWithoutLivesInput;
  uid: String;
  token: String;
  posts?: PostCreateManyWithoutAuthorInput;
  regStatus?: RegStatusCreateOneWithoutApplicantsInput;
  regTimes?: Int;
  maxRegTimes?: Int;
  families?: FamilyCreateManyWithoutFromInput;
  studies?: SchoolEduCreateManyWithoutStudentsInput;
  works?: WorkCreateManyWithoutWorkerInput;
  exam?: CollegeEntranceExamCreateOneWithoutStudentInput;
  sentMessages?: MessageCreateManyWithoutFromInput;
  receiveMessages?: MessageCreateManyWithoutToInput;
  groupMessages?: GroupMessageCreateManyWithoutFromInput;
  friends?: UserCreateManyInput;
  familyGroup?: FamilyGroupCreateOneWithoutUsersInput;
  creater?: FamilyGroupCreateOneWithoutCreaterInput;
  classMate?: ClassMateCreateManyWithoutStudentInput;
  workGroup?: WorkGroupCreateOneInput;
  colleagues?: ColleagueCreateManyWithoutWorkerInput;
  fromOldColleagues?: OldColleagueCreateManyWithoutFromInput;
  toOldColleagues?: OldColleagueCreateManyWithoutToInput;
  locationGroups?: LocationGroupCreateManyWithoutUsersInput;
  forgetPassword?: FindPassWordCreateOneWithoutForgetterInput;
  remmemberPassword?: FindPassWordCreateManyWithoutRemmemberInput;
  loveSetting?: LoveSettingCreateOneWithoutUserInput;
  loveWoman?: LoveMatchingCreateManyWithoutWomanInput;
  loveMan?: LoveMatchingCreateManyWithoutManInput;
  signUpLove?: LoveSignUpCreateOneWithoutPersonInput;
  skills?: SkillCreateManyWithoutPersonsInput;
  fitConditions?: PartnerConditionCreateManyWithoutPartnersInput;
  nofitConditions?: PartnerConditionCreateManyWithoutPassedPartnersInput;
  projects?: ProjectCreateManyWithoutStarterInput;
  trades?: TradeCreateManyWithoutUserInput;
}

export interface SchoolUpdateDataInput {
  name?: String;
  kind?: Educationkind;
  location?: LocationUpdateOneWithoutSchoolsInput;
}

export interface UserCreateManyWithoutGroupsInput {
  create?: UserCreateWithoutGroupsInput[] | UserCreateWithoutGroupsInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface LocationUpdateOneWithoutSchoolsInput {
  create?: LocationCreateWithoutSchoolsInput;
  update?: LocationUpdateWithoutSchoolsDataInput;
  upsert?: LocationUpsertWithoutSchoolsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: LocationWhereUniqueInput;
}

export interface FindPassWordUpdateManyMutationInput {
  times?: Int;
}

export interface LocationUpdateWithoutSchoolsDataInput {
  name?: String;
  province?: ProvinceUpdateOneInput;
  city?: CityUpdateOneInput;
  area?: AreaUpdateOneInput;
  street?: StreetUpdateOneInput;
  village?: VillageUpdateOneInput;
  companies?: CompanyUpdateManyWithoutLocationInput;
  universities?: UniversityUpdateManyInput;
  borns?: UserUpdateManyWithoutBirthplaceInput;
  lives?: UserUpdateManyWithoutResidenceInput;
}

export interface FindPassWordUpdateInput {
  times?: Int;
  forgetter?: UserUpdateOneWithoutForgetPasswordInput;
  remmember?: UserUpdateManyWithoutRemmemberPasswordInput;
}

export interface UserUpdateManyWithoutResidenceInput {
  create?: UserCreateWithoutResidenceInput[] | UserCreateWithoutResidenceInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueWithoutResidenceInput[]
    | UserUpdateWithWhereUniqueWithoutResidenceInput;
  upsert?:
    | UserUpsertWithWhereUniqueWithoutResidenceInput[]
    | UserUpsertWithWhereUniqueWithoutResidenceInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export interface FeeSettingUpdateManyMutationInput {
  name?: String;
  fee?: Boolean;
}

export interface UserUpdateWithWhereUniqueWithoutResidenceInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutResidenceDataInput;
}

export interface AdvertisementUpdateInput {
  image1?: String;
  image2?: String;
  image3?: String;
  image4?: String;
  image5?: String;
  startTime?: DateTimeInput;
  endTime?: DateTimeInput;
}

export interface UserUpdateWithoutResidenceDataInput {
  username?: String;
  password?: String;
  name?: String;
  gender?: String;
  avatar?: PhotoUpdateOneWithoutUserInput;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationUpdateOneWithoutBornsInput;
  uid?: String;
  token?: String;
  posts?: PostUpdateManyWithoutAuthorInput;
  regStatus?: RegStatusUpdateOneWithoutApplicantsInput;
  regTimes?: Int;
  maxRegTimes?: Int;
  families?: FamilyUpdateManyWithoutFromInput;
  studies?: SchoolEduUpdateManyWithoutStudentsInput;
  works?: WorkUpdateManyWithoutWorkerInput;
  exam?: CollegeEntranceExamUpdateOneWithoutStudentInput;
  sentMessages?: MessageUpdateManyWithoutFromInput;
  receiveMessages?: MessageUpdateManyWithoutToInput;
  groupMessages?: GroupMessageUpdateManyWithoutFromInput;
  groups?: GroupUpdateManyWithoutUsersInput;
  friends?: UserUpdateManyInput;
  familyGroup?: FamilyGroupUpdateOneWithoutUsersInput;
  creater?: FamilyGroupUpdateOneWithoutCreaterInput;
  classMate?: ClassMateUpdateManyWithoutStudentInput;
  workGroup?: WorkGroupUpdateOneInput;
  colleagues?: ColleagueUpdateManyWithoutWorkerInput;
  fromOldColleagues?: OldColleagueUpdateManyWithoutFromInput;
  toOldColleagues?: OldColleagueUpdateManyWithoutToInput;
  locationGroups?: LocationGroupUpdateManyWithoutUsersInput;
  forgetPassword?: FindPassWordUpdateOneWithoutForgetterInput;
  remmemberPassword?: FindPassWordUpdateManyWithoutRemmemberInput;
  loveSetting?: LoveSettingUpdateOneWithoutUserInput;
  loveWoman?: LoveMatchingUpdateManyWithoutWomanInput;
  loveMan?: LoveMatchingUpdateManyWithoutManInput;
  signUpLove?: LoveSignUpUpdateOneWithoutPersonInput;
  skills?: SkillUpdateManyWithoutPersonsInput;
  fitConditions?: PartnerConditionUpdateManyWithoutPartnersInput;
  nofitConditions?: PartnerConditionUpdateManyWithoutPassedPartnersInput;
  projects?: ProjectUpdateManyWithoutStarterInput;
  trades?: TradeUpdateManyWithoutUserInput;
}

export interface FeeSettingCreateInput {
  name?: String;
  fee?: Boolean;
}

export interface WorkUpdateManyWithoutWorkerInput {
  create?: WorkCreateWithoutWorkerInput[] | WorkCreateWithoutWorkerInput;
  delete?: WorkWhereUniqueInput[] | WorkWhereUniqueInput;
  connect?: WorkWhereUniqueInput[] | WorkWhereUniqueInput;
  disconnect?: WorkWhereUniqueInput[] | WorkWhereUniqueInput;
  update?:
    | WorkUpdateWithWhereUniqueWithoutWorkerInput[]
    | WorkUpdateWithWhereUniqueWithoutWorkerInput;
  upsert?:
    | WorkUpsertWithWhereUniqueWithoutWorkerInput[]
    | WorkUpsertWithWhereUniqueWithoutWorkerInput;
  deleteMany?: WorkScalarWhereInput[] | WorkScalarWhereInput;
  updateMany?:
    | WorkUpdateManyWithWhereNestedInput[]
    | WorkUpdateManyWithWhereNestedInput;
}

export interface AreaCreateInput {
  code: String;
  name: String;
  city: CityCreateOneWithoutAreasInput;
  towns?: StreetCreateManyWithoutAreaInput;
}

export interface WorkUpdateWithWhereUniqueWithoutWorkerInput {
  where: WorkWhereUniqueInput;
  data: WorkUpdateWithoutWorkerDataInput;
}

export interface CityCreateWithoutAreasInput {
  code: String;
  name: String;
  province: ProvinceCreateOneWithoutCitiesInput;
}

export interface WorkUpdateWithoutWorkerDataInput {
  startTime?: DateTimeInput;
  endTime?: DateTimeInput;
  company?: CompanyUpdateOneWithoutWorksInput;
  department?: String;
  post?: StationUpdateOneInput;
  jobContent?: String;
}

export interface ProvinceCreateWithoutCitiesInput {
  code: String;
  name: String;
}

export interface CompanyUpdateOneWithoutWorksInput {
  create?: CompanyCreateWithoutWorksInput;
  update?: CompanyUpdateWithoutWorksDataInput;
  upsert?: CompanyUpsertWithoutWorksInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: CompanyWhereUniqueInput;
}

export interface StreetCreateWithoutAreaInput {
  code: String;
  name: String;
  villages?: VillageCreateManyWithoutStreetInput;
}

export interface CompanyUpdateWithoutWorksDataInput {
  name?: String;
  code?: String;
  establishmentDate?: DateTimeInput;
  representative?: String;
  location?: LocationUpdateOneWithoutCompaniesInput;
  BusinessScope?: String;
  workGroup?: WorkGroupUpdateOneWithoutCompanyInput;
}

export interface VillageCreateWithoutStreetInput {
  code: String;
  name: String;
  people?: UserCreateManyInput;
}

export interface LocationUpdateOneWithoutCompaniesInput {
  create?: LocationCreateWithoutCompaniesInput;
  update?: LocationUpdateWithoutCompaniesDataInput;
  upsert?: LocationUpsertWithoutCompaniesInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: LocationWhereUniqueInput;
}

export interface UserCreateInput {
  username: String;
  password: String;
  name?: String;
  gender?: String;
  avatar?: PhotoCreateOneWithoutUserInput;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationCreateOneWithoutBornsInput;
  residence?: LocationCreateOneWithoutLivesInput;
  uid: String;
  token: String;
  posts?: PostCreateManyWithoutAuthorInput;
  regStatus?: RegStatusCreateOneWithoutApplicantsInput;
  regTimes?: Int;
  maxRegTimes?: Int;
  families?: FamilyCreateManyWithoutFromInput;
  studies?: SchoolEduCreateManyWithoutStudentsInput;
  works?: WorkCreateManyWithoutWorkerInput;
  exam?: CollegeEntranceExamCreateOneWithoutStudentInput;
  sentMessages?: MessageCreateManyWithoutFromInput;
  receiveMessages?: MessageCreateManyWithoutToInput;
  groupMessages?: GroupMessageCreateManyWithoutFromInput;
  groups?: GroupCreateManyWithoutUsersInput;
  friends?: UserCreateManyInput;
  familyGroup?: FamilyGroupCreateOneWithoutUsersInput;
  creater?: FamilyGroupCreateOneWithoutCreaterInput;
  classMate?: ClassMateCreateManyWithoutStudentInput;
  workGroup?: WorkGroupCreateOneInput;
  colleagues?: ColleagueCreateManyWithoutWorkerInput;
  fromOldColleagues?: OldColleagueCreateManyWithoutFromInput;
  toOldColleagues?: OldColleagueCreateManyWithoutToInput;
  locationGroups?: LocationGroupCreateManyWithoutUsersInput;
  forgetPassword?: FindPassWordCreateOneWithoutForgetterInput;
  remmemberPassword?: FindPassWordCreateManyWithoutRemmemberInput;
  loveSetting?: LoveSettingCreateOneWithoutUserInput;
  loveWoman?: LoveMatchingCreateManyWithoutWomanInput;
  loveMan?: LoveMatchingCreateManyWithoutManInput;
  signUpLove?: LoveSignUpCreateOneWithoutPersonInput;
  skills?: SkillCreateManyWithoutPersonsInput;
  fitConditions?: PartnerConditionCreateManyWithoutPartnersInput;
  nofitConditions?: PartnerConditionCreateManyWithoutPassedPartnersInput;
  projects?: ProjectCreateManyWithoutStarterInput;
  trades?: TradeCreateManyWithoutUserInput;
}

export interface LocationUpdateWithoutCompaniesDataInput {
  name?: String;
  province?: ProvinceUpdateOneInput;
  city?: CityUpdateOneInput;
  area?: AreaUpdateOneInput;
  street?: StreetUpdateOneInput;
  village?: VillageUpdateOneInput;
  schools?: SchoolUpdateManyWithoutLocationInput;
  universities?: UniversityUpdateManyInput;
  borns?: UserUpdateManyWithoutBirthplaceInput;
  lives?: UserUpdateManyWithoutResidenceInput;
}

export interface PhotoCreateWithoutUserInput {
  name?: String;
  url?: String;
}

export interface LocationUpsertWithoutCompaniesInput {
  update: LocationUpdateWithoutCompaniesDataInput;
  create: LocationCreateWithoutCompaniesInput;
}

export interface LocationCreateWithoutBornsInput {
  name?: String;
  province?: ProvinceCreateOneInput;
  city?: CityCreateOneInput;
  area?: AreaCreateOneInput;
  street?: StreetCreateOneInput;
  village?: VillageCreateOneInput;
  schools?: SchoolCreateManyWithoutLocationInput;
  companies?: CompanyCreateManyWithoutLocationInput;
  universities?: UniversityCreateManyInput;
  lives?: UserCreateManyWithoutResidenceInput;
}

export interface WorkGroupUpdateOneWithoutCompanyInput {
  create?: WorkGroupCreateWithoutCompanyInput;
  update?: WorkGroupUpdateWithoutCompanyDataInput;
  upsert?: WorkGroupUpsertWithoutCompanyInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: WorkGroupWhereUniqueInput;
}

export interface ProvinceCreateInput {
  code: String;
  name: String;
  cities?: CityCreateManyWithoutProvinceInput;
}

export interface WorkGroupUpdateWithoutCompanyDataInput {
  colleagues?: ColleagueUpdateManyWithoutGroupInput;
}

export interface CityCreateWithoutProvinceInput {
  code: String;
  name: String;
  areas?: AreaCreateManyWithoutCityInput;
}

export interface ColleagueUpdateManyWithoutGroupInput {
  create?:
    | ColleagueCreateWithoutGroupInput[]
    | ColleagueCreateWithoutGroupInput;
  delete?: ColleagueWhereUniqueInput[] | ColleagueWhereUniqueInput;
  connect?: ColleagueWhereUniqueInput[] | ColleagueWhereUniqueInput;
  disconnect?: ColleagueWhereUniqueInput[] | ColleagueWhereUniqueInput;
  update?:
    | ColleagueUpdateWithWhereUniqueWithoutGroupInput[]
    | ColleagueUpdateWithWhereUniqueWithoutGroupInput;
  upsert?:
    | ColleagueUpsertWithWhereUniqueWithoutGroupInput[]
    | ColleagueUpsertWithWhereUniqueWithoutGroupInput;
  deleteMany?: ColleagueScalarWhereInput[] | ColleagueScalarWhereInput;
  updateMany?:
    | ColleagueUpdateManyWithWhereNestedInput[]
    | ColleagueUpdateManyWithWhereNestedInput;
}

export interface AreaCreateWithoutCityInput {
  code: String;
  name: String;
  towns?: StreetCreateManyWithoutAreaInput;
}

export interface ColleagueUpdateWithWhereUniqueWithoutGroupInput {
  where: ColleagueWhereUniqueInput;
  data: ColleagueUpdateWithoutGroupDataInput;
}

export interface CityCreateInput {
  code: String;
  name: String;
  province: ProvinceCreateOneWithoutCitiesInput;
  areas?: AreaCreateManyWithoutCityInput;
}

export interface ColleagueUpdateWithoutGroupDataInput {
  worker?: UserUpdateOneWithoutColleaguesInput;
  status?: String;
}

export interface StreetCreateOneInput {
  create?: StreetCreateInput;
  connect?: StreetWhereUniqueInput;
}

export interface UserUpdateOneWithoutColleaguesInput {
  create?: UserCreateWithoutColleaguesInput;
  update?: UserUpdateWithoutColleaguesDataInput;
  upsert?: UserUpsertWithoutColleaguesInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface AreaCreateOneWithoutTownsInput {
  create?: AreaCreateWithoutTownsInput;
  connect?: AreaWhereUniqueInput;
}

export interface UserUpdateWithoutColleaguesDataInput {
  username?: String;
  password?: String;
  name?: String;
  gender?: String;
  avatar?: PhotoUpdateOneWithoutUserInput;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationUpdateOneWithoutBornsInput;
  residence?: LocationUpdateOneWithoutLivesInput;
  uid?: String;
  token?: String;
  posts?: PostUpdateManyWithoutAuthorInput;
  regStatus?: RegStatusUpdateOneWithoutApplicantsInput;
  regTimes?: Int;
  maxRegTimes?: Int;
  families?: FamilyUpdateManyWithoutFromInput;
  studies?: SchoolEduUpdateManyWithoutStudentsInput;
  works?: WorkUpdateManyWithoutWorkerInput;
  exam?: CollegeEntranceExamUpdateOneWithoutStudentInput;
  sentMessages?: MessageUpdateManyWithoutFromInput;
  receiveMessages?: MessageUpdateManyWithoutToInput;
  groupMessages?: GroupMessageUpdateManyWithoutFromInput;
  groups?: GroupUpdateManyWithoutUsersInput;
  friends?: UserUpdateManyInput;
  familyGroup?: FamilyGroupUpdateOneWithoutUsersInput;
  creater?: FamilyGroupUpdateOneWithoutCreaterInput;
  classMate?: ClassMateUpdateManyWithoutStudentInput;
  workGroup?: WorkGroupUpdateOneInput;
  fromOldColleagues?: OldColleagueUpdateManyWithoutFromInput;
  toOldColleagues?: OldColleagueUpdateManyWithoutToInput;
  locationGroups?: LocationGroupUpdateManyWithoutUsersInput;
  forgetPassword?: FindPassWordUpdateOneWithoutForgetterInput;
  remmemberPassword?: FindPassWordUpdateManyWithoutRemmemberInput;
  loveSetting?: LoveSettingUpdateOneWithoutUserInput;
  loveWoman?: LoveMatchingUpdateManyWithoutWomanInput;
  loveMan?: LoveMatchingUpdateManyWithoutManInput;
  signUpLove?: LoveSignUpUpdateOneWithoutPersonInput;
  skills?: SkillUpdateManyWithoutPersonsInput;
  fitConditions?: PartnerConditionUpdateManyWithoutPartnersInput;
  nofitConditions?: PartnerConditionUpdateManyWithoutPassedPartnersInput;
  projects?: ProjectUpdateManyWithoutStarterInput;
  trades?: TradeUpdateManyWithoutUserInput;
}

export interface VillageCreateOneInput {
  create?: VillageCreateInput;
  connect?: VillageWhereUniqueInput;
}

export interface CollegeEntranceExamUpdateOneWithoutStudentInput {
  create?: CollegeEntranceExamCreateWithoutStudentInput;
  update?: CollegeEntranceExamUpdateWithoutStudentDataInput;
  upsert?: CollegeEntranceExamUpsertWithoutStudentInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: CollegeEntranceExamWhereUniqueInput;
}

export interface StreetCreateOneWithoutVillagesInput {
  create?: StreetCreateWithoutVillagesInput;
  connect?: StreetWhereUniqueInput;
}

export interface CollegeEntranceExamUpdateWithoutStudentDataInput {
  province?: ProvinceUpdateOneRequiredInput;
  subject?: String;
  culscore?: Float;
  proscore?: Float;
  candidatenum?: String;
  times?: Int;
}

export interface SchoolCreateManyWithoutLocationInput {
  create?:
    | SchoolCreateWithoutLocationInput[]
    | SchoolCreateWithoutLocationInput;
  connect?: SchoolWhereUniqueInput[] | SchoolWhereUniqueInput;
}

export interface ProvinceUpdateOneRequiredInput {
  create?: ProvinceCreateInput;
  update?: ProvinceUpdateDataInput;
  upsert?: ProvinceUpsertNestedInput;
  connect?: ProvinceWhereUniqueInput;
}

export interface CompanyCreateManyWithoutLocationInput {
  create?:
    | CompanyCreateWithoutLocationInput[]
    | CompanyCreateWithoutLocationInput;
  connect?: CompanyWhereUniqueInput[] | CompanyWhereUniqueInput;
}

export interface CollegeEntranceExamUpsertWithoutStudentInput {
  update: CollegeEntranceExamUpdateWithoutStudentDataInput;
  create: CollegeEntranceExamCreateWithoutStudentInput;
}

export interface WorkCreateManyWithoutCompanyInput {
  create?: WorkCreateWithoutCompanyInput[] | WorkCreateWithoutCompanyInput;
  connect?: WorkWhereUniqueInput[] | WorkWhereUniqueInput;
}

export interface MessageUpdateManyWithoutFromInput {
  create?: MessageCreateWithoutFromInput[] | MessageCreateWithoutFromInput;
  delete?: MessageWhereUniqueInput[] | MessageWhereUniqueInput;
  connect?: MessageWhereUniqueInput[] | MessageWhereUniqueInput;
  disconnect?: MessageWhereUniqueInput[] | MessageWhereUniqueInput;
  update?:
    | MessageUpdateWithWhereUniqueWithoutFromInput[]
    | MessageUpdateWithWhereUniqueWithoutFromInput;
  upsert?:
    | MessageUpsertWithWhereUniqueWithoutFromInput[]
    | MessageUpsertWithWhereUniqueWithoutFromInput;
  deleteMany?: MessageScalarWhereInput[] | MessageScalarWhereInput;
  updateMany?:
    | MessageUpdateManyWithWhereNestedInput[]
    | MessageUpdateManyWithWhereNestedInput;
}

export interface StationCreateOneInput {
  create?: StationCreateInput;
  connect?: StationWhereUniqueInput;
}

export interface MessageUpdateWithWhereUniqueWithoutFromInput {
  where: MessageWhereUniqueInput;
  data: MessageUpdateWithoutFromDataInput;
}

export interface UserCreateOneWithoutWorksInput {
  create?: UserCreateWithoutWorksInput;
  connect?: UserWhereUniqueInput;
}

export interface MessageUpdateWithoutFromDataInput {
  to?: UserUpdateOneRequiredWithoutReceiveMessagesInput;
  text?: String;
  image?: PhotoUpdateOneInput;
}

export interface LocationCreateOneWithoutLivesInput {
  create?: LocationCreateWithoutLivesInput;
  connect?: LocationWhereUniqueInput;
}

export interface UserUpdateOneRequiredWithoutReceiveMessagesInput {
  create?: UserCreateWithoutReceiveMessagesInput;
  update?: UserUpdateWithoutReceiveMessagesDataInput;
  upsert?: UserUpsertWithoutReceiveMessagesInput;
  connect?: UserWhereUniqueInput;
}

export interface UniversityCreateManyInput {
  create?: UniversityCreateInput[] | UniversityCreateInput;
  connect?: UniversityWhereUniqueInput[] | UniversityWhereUniqueInput;
}

export interface UserUpdateWithoutReceiveMessagesDataInput {
  username?: String;
  password?: String;
  name?: String;
  gender?: String;
  avatar?: PhotoUpdateOneWithoutUserInput;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationUpdateOneWithoutBornsInput;
  residence?: LocationUpdateOneWithoutLivesInput;
  uid?: String;
  token?: String;
  posts?: PostUpdateManyWithoutAuthorInput;
  regStatus?: RegStatusUpdateOneWithoutApplicantsInput;
  regTimes?: Int;
  maxRegTimes?: Int;
  families?: FamilyUpdateManyWithoutFromInput;
  studies?: SchoolEduUpdateManyWithoutStudentsInput;
  works?: WorkUpdateManyWithoutWorkerInput;
  exam?: CollegeEntranceExamUpdateOneWithoutStudentInput;
  sentMessages?: MessageUpdateManyWithoutFromInput;
  groupMessages?: GroupMessageUpdateManyWithoutFromInput;
  groups?: GroupUpdateManyWithoutUsersInput;
  friends?: UserUpdateManyInput;
  familyGroup?: FamilyGroupUpdateOneWithoutUsersInput;
  creater?: FamilyGroupUpdateOneWithoutCreaterInput;
  classMate?: ClassMateUpdateManyWithoutStudentInput;
  workGroup?: WorkGroupUpdateOneInput;
  colleagues?: ColleagueUpdateManyWithoutWorkerInput;
  fromOldColleagues?: OldColleagueUpdateManyWithoutFromInput;
  toOldColleagues?: OldColleagueUpdateManyWithoutToInput;
  locationGroups?: LocationGroupUpdateManyWithoutUsersInput;
  forgetPassword?: FindPassWordUpdateOneWithoutForgetterInput;
  remmemberPassword?: FindPassWordUpdateManyWithoutRemmemberInput;
  loveSetting?: LoveSettingUpdateOneWithoutUserInput;
  loveWoman?: LoveMatchingUpdateManyWithoutWomanInput;
  loveMan?: LoveMatchingUpdateManyWithoutManInput;
  signUpLove?: LoveSignUpUpdateOneWithoutPersonInput;
  skills?: SkillUpdateManyWithoutPersonsInput;
  fitConditions?: PartnerConditionUpdateManyWithoutPartnersInput;
  nofitConditions?: PartnerConditionUpdateManyWithoutPassedPartnersInput;
  projects?: ProjectUpdateManyWithoutStarterInput;
  trades?: TradeUpdateManyWithoutUserInput;
}

export interface UserCreateManyWithoutBirthplaceInput {
  create?:
    | UserCreateWithoutBirthplaceInput[]
    | UserCreateWithoutBirthplaceInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface GroupMessageUpdateManyWithoutFromInput {
  create?:
    | GroupMessageCreateWithoutFromInput[]
    | GroupMessageCreateWithoutFromInput;
  delete?: GroupMessageWhereUniqueInput[] | GroupMessageWhereUniqueInput;
  connect?: GroupMessageWhereUniqueInput[] | GroupMessageWhereUniqueInput;
  disconnect?: GroupMessageWhereUniqueInput[] | GroupMessageWhereUniqueInput;
  update?:
    | GroupMessageUpdateWithWhereUniqueWithoutFromInput[]
    | GroupMessageUpdateWithWhereUniqueWithoutFromInput;
  upsert?:
    | GroupMessageUpsertWithWhereUniqueWithoutFromInput[]
    | GroupMessageUpsertWithWhereUniqueWithoutFromInput;
  deleteMany?: GroupMessageScalarWhereInput[] | GroupMessageScalarWhereInput;
  updateMany?:
    | GroupMessageUpdateManyWithWhereNestedInput[]
    | GroupMessageUpdateManyWithWhereNestedInput;
}

export interface PostCreateManyWithoutAuthorInput {
  create?: PostCreateWithoutAuthorInput[] | PostCreateWithoutAuthorInput;
  connect?: PostWhereUniqueInput[] | PostWhereUniqueInput;
}

export interface GroupMessageUpdateWithWhereUniqueWithoutFromInput {
  where: GroupMessageWhereUniqueInput;
  data: GroupMessageUpdateWithoutFromDataInput;
}

export interface RegStatusCreateOneWithoutApplicantsInput {
  create?: RegStatusCreateWithoutApplicantsInput;
  connect?: RegStatusWhereUniqueInput;
}

export interface GroupMessageUpdateWithoutFromDataInput {
  type?: GroupKind;
  to?: String;
  text?: String;
  image?: PhotoUpdateOneInput;
}

export interface UniversityCreateOneInput {
  create?: UniversityCreateInput;
  connect?: UniversityWhereUniqueInput;
}

export interface PhotoUpdateOneInput {
  create?: PhotoCreateInput;
  update?: PhotoUpdateDataInput;
  upsert?: PhotoUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: PhotoWhereUniqueInput;
}

export interface MajorCreateInput {
  name: String;
  category: String;
  education: Educationkind;
}

export interface PhotoUpdateDataInput {
  name?: String;
  url?: String;
  user?: UserUpdateOneWithoutAvatarInput;
}

export interface FamilyCreateWithoutFromInput {
  to: PersonCreateOneWithoutFamiliesInput;
  relationship: String;
  spouse?: FamilyCreateOneInput;
  status: String;
}

export interface UserUpdateOneWithoutAvatarInput {
  create?: UserCreateWithoutAvatarInput;
  update?: UserUpdateWithoutAvatarDataInput;
  upsert?: UserUpsertWithoutAvatarInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface PersonCreateWithoutFamiliesInput {
  name: String;
  user?: UserCreateOneInput;
  asFather?: FamilyGroupCreateManyWithoutFatherInput;
  asMother?: FamilyGroupCreateManyWithoutMotherInput;
}

export interface UserUpdateWithoutAvatarDataInput {
  username?: String;
  password?: String;
  name?: String;
  gender?: String;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationUpdateOneWithoutBornsInput;
  residence?: LocationUpdateOneWithoutLivesInput;
  uid?: String;
  token?: String;
  posts?: PostUpdateManyWithoutAuthorInput;
  regStatus?: RegStatusUpdateOneWithoutApplicantsInput;
  regTimes?: Int;
  maxRegTimes?: Int;
  families?: FamilyUpdateManyWithoutFromInput;
  studies?: SchoolEduUpdateManyWithoutStudentsInput;
  works?: WorkUpdateManyWithoutWorkerInput;
  exam?: CollegeEntranceExamUpdateOneWithoutStudentInput;
  sentMessages?: MessageUpdateManyWithoutFromInput;
  receiveMessages?: MessageUpdateManyWithoutToInput;
  groupMessages?: GroupMessageUpdateManyWithoutFromInput;
  groups?: GroupUpdateManyWithoutUsersInput;
  friends?: UserUpdateManyInput;
  familyGroup?: FamilyGroupUpdateOneWithoutUsersInput;
  creater?: FamilyGroupUpdateOneWithoutCreaterInput;
  classMate?: ClassMateUpdateManyWithoutStudentInput;
  workGroup?: WorkGroupUpdateOneInput;
  colleagues?: ColleagueUpdateManyWithoutWorkerInput;
  fromOldColleagues?: OldColleagueUpdateManyWithoutFromInput;
  toOldColleagues?: OldColleagueUpdateManyWithoutToInput;
  locationGroups?: LocationGroupUpdateManyWithoutUsersInput;
  forgetPassword?: FindPassWordUpdateOneWithoutForgetterInput;
  remmemberPassword?: FindPassWordUpdateManyWithoutRemmemberInput;
  loveSetting?: LoveSettingUpdateOneWithoutUserInput;
  loveWoman?: LoveMatchingUpdateManyWithoutWomanInput;
  loveMan?: LoveMatchingUpdateManyWithoutManInput;
  signUpLove?: LoveSignUpUpdateOneWithoutPersonInput;
  skills?: SkillUpdateManyWithoutPersonsInput;
  fitConditions?: PartnerConditionUpdateManyWithoutPartnersInput;
  nofitConditions?: PartnerConditionUpdateManyWithoutPassedPartnersInput;
  projects?: ProjectUpdateManyWithoutStarterInput;
  trades?: TradeUpdateManyWithoutUserInput;
}

export interface FamilyGroupCreateManyWithoutFatherInput {
  create?:
    | FamilyGroupCreateWithoutFatherInput[]
    | FamilyGroupCreateWithoutFatherInput;
  connect?: FamilyGroupWhereUniqueInput[] | FamilyGroupWhereUniqueInput;
}

export interface MessageUpdateManyWithoutToInput {
  create?: MessageCreateWithoutToInput[] | MessageCreateWithoutToInput;
  delete?: MessageWhereUniqueInput[] | MessageWhereUniqueInput;
  connect?: MessageWhereUniqueInput[] | MessageWhereUniqueInput;
  disconnect?: MessageWhereUniqueInput[] | MessageWhereUniqueInput;
  update?:
    | MessageUpdateWithWhereUniqueWithoutToInput[]
    | MessageUpdateWithWhereUniqueWithoutToInput;
  upsert?:
    | MessageUpsertWithWhereUniqueWithoutToInput[]
    | MessageUpsertWithWhereUniqueWithoutToInput;
  deleteMany?: MessageScalarWhereInput[] | MessageScalarWhereInput;
  updateMany?:
    | MessageUpdateManyWithWhereNestedInput[]
    | MessageUpdateManyWithWhereNestedInput;
}

export interface PersonCreateOneWithoutAsMotherInput {
  create?: PersonCreateWithoutAsMotherInput;
  connect?: PersonWhereUniqueInput;
}

export interface MessageUpdateWithWhereUniqueWithoutToInput {
  where: MessageWhereUniqueInput;
  data: MessageUpdateWithoutToDataInput;
}

export interface FamilyCreateManyWithoutToInput {
  create?: FamilyCreateWithoutToInput[] | FamilyCreateWithoutToInput;
  connect?: FamilyWhereUniqueInput[] | FamilyWhereUniqueInput;
}

export interface MessageUpdateWithoutToDataInput {
  from?: UserUpdateOneRequiredWithoutSentMessagesInput;
  text?: String;
  image?: PhotoUpdateOneInput;
}

export interface UserCreateOneWithoutFamiliesInput {
  create?: UserCreateWithoutFamiliesInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateOneRequiredWithoutSentMessagesInput {
  create?: UserCreateWithoutSentMessagesInput;
  update?: UserUpdateWithoutSentMessagesDataInput;
  upsert?: UserUpsertWithoutSentMessagesInput;
  connect?: UserWhereUniqueInput;
}

export interface SchoolEduCreateManyWithoutStudentsInput {
  create?:
    | SchoolEduCreateWithoutStudentsInput[]
    | SchoolEduCreateWithoutStudentsInput;
  connect?: SchoolEduWhereUniqueInput[] | SchoolEduWhereUniqueInput;
}

export interface UserUpdateWithoutSentMessagesDataInput {
  username?: String;
  password?: String;
  name?: String;
  gender?: String;
  avatar?: PhotoUpdateOneWithoutUserInput;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationUpdateOneWithoutBornsInput;
  residence?: LocationUpdateOneWithoutLivesInput;
  uid?: String;
  token?: String;
  posts?: PostUpdateManyWithoutAuthorInput;
  regStatus?: RegStatusUpdateOneWithoutApplicantsInput;
  regTimes?: Int;
  maxRegTimes?: Int;
  families?: FamilyUpdateManyWithoutFromInput;
  studies?: SchoolEduUpdateManyWithoutStudentsInput;
  works?: WorkUpdateManyWithoutWorkerInput;
  exam?: CollegeEntranceExamUpdateOneWithoutStudentInput;
  receiveMessages?: MessageUpdateManyWithoutToInput;
  groupMessages?: GroupMessageUpdateManyWithoutFromInput;
  groups?: GroupUpdateManyWithoutUsersInput;
  friends?: UserUpdateManyInput;
  familyGroup?: FamilyGroupUpdateOneWithoutUsersInput;
  creater?: FamilyGroupUpdateOneWithoutCreaterInput;
  classMate?: ClassMateUpdateManyWithoutStudentInput;
  workGroup?: WorkGroupUpdateOneInput;
  colleagues?: ColleagueUpdateManyWithoutWorkerInput;
  fromOldColleagues?: OldColleagueUpdateManyWithoutFromInput;
  toOldColleagues?: OldColleagueUpdateManyWithoutToInput;
  locationGroups?: LocationGroupUpdateManyWithoutUsersInput;
  forgetPassword?: FindPassWordUpdateOneWithoutForgetterInput;
  remmemberPassword?: FindPassWordUpdateManyWithoutRemmemberInput;
  loveSetting?: LoveSettingUpdateOneWithoutUserInput;
  loveWoman?: LoveMatchingUpdateManyWithoutWomanInput;
  loveMan?: LoveMatchingUpdateManyWithoutManInput;
  signUpLove?: LoveSignUpUpdateOneWithoutPersonInput;
  skills?: SkillUpdateManyWithoutPersonsInput;
  fitConditions?: PartnerConditionUpdateManyWithoutPartnersInput;
  nofitConditions?: PartnerConditionUpdateManyWithoutPassedPartnersInput;
  projects?: ProjectUpdateManyWithoutStarterInput;
  trades?: TradeUpdateManyWithoutUserInput;
}

export interface SchoolCreateOneInput {
  create?: SchoolCreateInput;
  connect?: SchoolWhereUniqueInput;
}

export interface GroupUpdateManyWithoutUsersInput {
  create?: GroupCreateWithoutUsersInput[] | GroupCreateWithoutUsersInput;
  delete?: GroupWhereUniqueInput[] | GroupWhereUniqueInput;
  connect?: GroupWhereUniqueInput[] | GroupWhereUniqueInput;
  disconnect?: GroupWhereUniqueInput[] | GroupWhereUniqueInput;
  update?:
    | GroupUpdateWithWhereUniqueWithoutUsersInput[]
    | GroupUpdateWithWhereUniqueWithoutUsersInput;
  upsert?:
    | GroupUpsertWithWhereUniqueWithoutUsersInput[]
    | GroupUpsertWithWhereUniqueWithoutUsersInput;
  deleteMany?: GroupScalarWhereInput[] | GroupScalarWhereInput;
  updateMany?:
    | GroupUpdateManyWithWhereNestedInput[]
    | GroupUpdateManyWithWhereNestedInput;
}

export interface LocationCreateOneWithoutSchoolsInput {
  create?: LocationCreateWithoutSchoolsInput;
  connect?: LocationWhereUniqueInput;
}

export interface GroupUpdateWithWhereUniqueWithoutUsersInput {
  where: GroupWhereUniqueInput;
  data: GroupUpdateWithoutUsersDataInput;
}

export interface UserCreateManyWithoutResidenceInput {
  create?: UserCreateWithoutResidenceInput[] | UserCreateWithoutResidenceInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface GroupUpdateWithoutUsersDataInput {
  type?: GroupKind;
  name?: String;
  messages?: MessageUpdateManyInput;
}

export interface WorkCreateManyWithoutWorkerInput {
  create?: WorkCreateWithoutWorkerInput[] | WorkCreateWithoutWorkerInput;
  connect?: WorkWhereUniqueInput[] | WorkWhereUniqueInput;
}

export interface MessageUpdateManyInput {
  create?: MessageCreateInput[] | MessageCreateInput;
  update?:
    | MessageUpdateWithWhereUniqueNestedInput[]
    | MessageUpdateWithWhereUniqueNestedInput;
  upsert?:
    | MessageUpsertWithWhereUniqueNestedInput[]
    | MessageUpsertWithWhereUniqueNestedInput;
  delete?: MessageWhereUniqueInput[] | MessageWhereUniqueInput;
  connect?: MessageWhereUniqueInput[] | MessageWhereUniqueInput;
  disconnect?: MessageWhereUniqueInput[] | MessageWhereUniqueInput;
  deleteMany?: MessageScalarWhereInput[] | MessageScalarWhereInput;
  updateMany?:
    | MessageUpdateManyWithWhereNestedInput[]
    | MessageUpdateManyWithWhereNestedInput;
}

export interface CompanyCreateOneWithoutWorksInput {
  create?: CompanyCreateWithoutWorksInput;
  connect?: CompanyWhereUniqueInput;
}

export interface MessageUpdateWithWhereUniqueNestedInput {
  where: MessageWhereUniqueInput;
  data: MessageUpdateDataInput;
}

export interface LocationCreateOneWithoutCompaniesInput {
  create?: LocationCreateWithoutCompaniesInput;
  connect?: LocationWhereUniqueInput;
}

export interface MessageUpdateDataInput {
  to?: UserUpdateOneRequiredWithoutReceiveMessagesInput;
  from?: UserUpdateOneRequiredWithoutSentMessagesInput;
  text?: String;
  image?: PhotoUpdateOneInput;
}

export interface WorkGroupCreateOneWithoutCompanyInput {
  create?: WorkGroupCreateWithoutCompanyInput;
  connect?: WorkGroupWhereUniqueInput;
}

export interface MessageUpsertWithWhereUniqueNestedInput {
  where: MessageWhereUniqueInput;
  update: MessageUpdateDataInput;
  create: MessageCreateInput;
}

export interface ColleagueCreateManyWithoutGroupInput {
  create?:
    | ColleagueCreateWithoutGroupInput[]
    | ColleagueCreateWithoutGroupInput;
  connect?: ColleagueWhereUniqueInput[] | ColleagueWhereUniqueInput;
}

export interface MessageScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  AND?: MessageScalarWhereInput[] | MessageScalarWhereInput;
  OR?: MessageScalarWhereInput[] | MessageScalarWhereInput;
  NOT?: MessageScalarWhereInput[] | MessageScalarWhereInput;
}

export interface UserCreateOneWithoutColleaguesInput {
  create?: UserCreateWithoutColleaguesInput;
  connect?: UserWhereUniqueInput;
}

export interface MessageUpdateManyWithWhereNestedInput {
  where: MessageScalarWhereInput;
  data: MessageUpdateManyDataInput;
}

export interface CollegeEntranceExamCreateOneWithoutStudentInput {
  create?: CollegeEntranceExamCreateWithoutStudentInput;
  connect?: CollegeEntranceExamWhereUniqueInput;
}

export interface MessageUpdateManyDataInput {
  text?: String;
}

export interface FamilyGroupUpdateInput {
  father?: PersonUpdateOneWithoutAsFatherInput;
  mother?: PersonUpdateOneWithoutAsMotherInput;
  creater?: UserUpdateOneWithoutCreaterInput;
  name?: String;
  families?: FamilyUpdateManyInput;
  users?: UserUpdateManyWithoutFamilyGroupInput;
}

export interface GroupUpsertWithWhereUniqueWithoutUsersInput {
  where: GroupWhereUniqueInput;
  update: GroupUpdateWithoutUsersDataInput;
  create: GroupCreateWithoutUsersInput;
}

export interface UserCreateOneWithoutReceiveMessagesInput {
  create?: UserCreateWithoutReceiveMessagesInput;
  connect?: UserWhereUniqueInput;
}

export interface GroupScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  type?: GroupKind;
  type_not?: GroupKind;
  type_in?: GroupKind[] | GroupKind;
  type_not_in?: GroupKind[] | GroupKind;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: GroupScalarWhereInput[] | GroupScalarWhereInput;
  OR?: GroupScalarWhereInput[] | GroupScalarWhereInput;
  NOT?: GroupScalarWhereInput[] | GroupScalarWhereInput;
}

export interface GroupMessageCreateManyWithoutFromInput {
  create?:
    | GroupMessageCreateWithoutFromInput[]
    | GroupMessageCreateWithoutFromInput;
  connect?: GroupMessageWhereUniqueInput[] | GroupMessageWhereUniqueInput;
}

export interface GroupUpdateManyWithWhereNestedInput {
  where: GroupScalarWhereInput;
  data: GroupUpdateManyDataInput;
}

export interface PhotoCreateOneInput {
  create?: PhotoCreateInput;
  connect?: PhotoWhereUniqueInput;
}

export interface GroupUpdateManyDataInput {
  type?: GroupKind;
  name?: String;
}

export interface UserCreateOneWithoutAvatarInput {
  create?: UserCreateWithoutAvatarInput;
  connect?: UserWhereUniqueInput;
}

export interface FamilyGroupUpdateOneWithoutUsersInput {
  create?: FamilyGroupCreateWithoutUsersInput;
  update?: FamilyGroupUpdateWithoutUsersDataInput;
  upsert?: FamilyGroupUpsertWithoutUsersInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: FamilyGroupWhereUniqueInput;
}

export interface MessageCreateManyWithoutToInput {
  create?: MessageCreateWithoutToInput[] | MessageCreateWithoutToInput;
  connect?: MessageWhereUniqueInput[] | MessageWhereUniqueInput;
}

export interface FamilyGroupUpdateWithoutUsersDataInput {
  father?: PersonUpdateOneWithoutAsFatherInput;
  mother?: PersonUpdateOneWithoutAsMotherInput;
  creater?: UserUpdateOneWithoutCreaterInput;
  name?: String;
  families?: FamilyUpdateManyInput;
}

export interface UserCreateOneWithoutSentMessagesInput {
  create?: UserCreateWithoutSentMessagesInput;
  connect?: UserWhereUniqueInput;
}

export interface PersonUpdateOneWithoutAsFatherInput {
  create?: PersonCreateWithoutAsFatherInput;
  update?: PersonUpdateWithoutAsFatherDataInput;
  upsert?: PersonUpsertWithoutAsFatherInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: PersonWhereUniqueInput;
}

export interface GroupCreateManyWithoutUsersInput {
  create?: GroupCreateWithoutUsersInput[] | GroupCreateWithoutUsersInput;
  connect?: GroupWhereUniqueInput[] | GroupWhereUniqueInput;
}

export interface PersonUpdateWithoutAsFatherDataInput {
  name?: String;
  user?: UserUpdateOneInput;
  families?: FamilyUpdateManyWithoutToInput;
  asMother?: FamilyGroupUpdateManyWithoutMotherInput;
}

export interface MessageCreateManyInput {
  create?: MessageCreateInput[] | MessageCreateInput;
  connect?: MessageWhereUniqueInput[] | MessageWhereUniqueInput;
}

export interface FamilyGroupUpdateManyWithoutMotherInput {
  create?:
    | FamilyGroupCreateWithoutMotherInput[]
    | FamilyGroupCreateWithoutMotherInput;
  delete?: FamilyGroupWhereUniqueInput[] | FamilyGroupWhereUniqueInput;
  connect?: FamilyGroupWhereUniqueInput[] | FamilyGroupWhereUniqueInput;
  disconnect?: FamilyGroupWhereUniqueInput[] | FamilyGroupWhereUniqueInput;
  update?:
    | FamilyGroupUpdateWithWhereUniqueWithoutMotherInput[]
    | FamilyGroupUpdateWithWhereUniqueWithoutMotherInput;
  upsert?:
    | FamilyGroupUpsertWithWhereUniqueWithoutMotherInput[]
    | FamilyGroupUpsertWithWhereUniqueWithoutMotherInput;
  deleteMany?: FamilyGroupScalarWhereInput[] | FamilyGroupScalarWhereInput;
  updateMany?:
    | FamilyGroupUpdateManyWithWhereNestedInput[]
    | FamilyGroupUpdateManyWithWhereNestedInput;
}

export interface FamilyGroupCreateOneWithoutUsersInput {
  create?: FamilyGroupCreateWithoutUsersInput;
  connect?: FamilyGroupWhereUniqueInput;
}

export interface FamilyGroupUpdateWithWhereUniqueWithoutMotherInput {
  where: FamilyGroupWhereUniqueInput;
  data: FamilyGroupUpdateWithoutMotherDataInput;
}

export interface PersonCreateOneWithoutAsFatherInput {
  create?: PersonCreateWithoutAsFatherInput;
  connect?: PersonWhereUniqueInput;
}

export interface FamilyGroupUpdateWithoutMotherDataInput {
  father?: PersonUpdateOneWithoutAsFatherInput;
  creater?: UserUpdateOneWithoutCreaterInput;
  name?: String;
  families?: FamilyUpdateManyInput;
  users?: UserUpdateManyWithoutFamilyGroupInput;
}

export interface FamilyGroupCreateManyWithoutMotherInput {
  create?:
    | FamilyGroupCreateWithoutMotherInput[]
    | FamilyGroupCreateWithoutMotherInput;
  connect?: FamilyGroupWhereUniqueInput[] | FamilyGroupWhereUniqueInput;
}

export interface UserUpdateOneWithoutCreaterInput {
  create?: UserCreateWithoutCreaterInput;
  update?: UserUpdateWithoutCreaterDataInput;
  upsert?: UserUpsertWithoutCreaterInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateOneWithoutCreaterInput {
  create?: UserCreateWithoutCreaterInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateWithoutCreaterDataInput {
  username?: String;
  password?: String;
  name?: String;
  gender?: String;
  avatar?: PhotoUpdateOneWithoutUserInput;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationUpdateOneWithoutBornsInput;
  residence?: LocationUpdateOneWithoutLivesInput;
  uid?: String;
  token?: String;
  posts?: PostUpdateManyWithoutAuthorInput;
  regStatus?: RegStatusUpdateOneWithoutApplicantsInput;
  regTimes?: Int;
  maxRegTimes?: Int;
  families?: FamilyUpdateManyWithoutFromInput;
  studies?: SchoolEduUpdateManyWithoutStudentsInput;
  works?: WorkUpdateManyWithoutWorkerInput;
  exam?: CollegeEntranceExamUpdateOneWithoutStudentInput;
  sentMessages?: MessageUpdateManyWithoutFromInput;
  receiveMessages?: MessageUpdateManyWithoutToInput;
  groupMessages?: GroupMessageUpdateManyWithoutFromInput;
  groups?: GroupUpdateManyWithoutUsersInput;
  friends?: UserUpdateManyInput;
  familyGroup?: FamilyGroupUpdateOneWithoutUsersInput;
  classMate?: ClassMateUpdateManyWithoutStudentInput;
  workGroup?: WorkGroupUpdateOneInput;
  colleagues?: ColleagueUpdateManyWithoutWorkerInput;
  fromOldColleagues?: OldColleagueUpdateManyWithoutFromInput;
  toOldColleagues?: OldColleagueUpdateManyWithoutToInput;
  locationGroups?: LocationGroupUpdateManyWithoutUsersInput;
  forgetPassword?: FindPassWordUpdateOneWithoutForgetterInput;
  remmemberPassword?: FindPassWordUpdateManyWithoutRemmemberInput;
  loveSetting?: LoveSettingUpdateOneWithoutUserInput;
  loveWoman?: LoveMatchingUpdateManyWithoutWomanInput;
  loveMan?: LoveMatchingUpdateManyWithoutManInput;
  signUpLove?: LoveSignUpUpdateOneWithoutPersonInput;
  skills?: SkillUpdateManyWithoutPersonsInput;
  fitConditions?: PartnerConditionUpdateManyWithoutPartnersInput;
  nofitConditions?: PartnerConditionUpdateManyWithoutPassedPartnersInput;
  projects?: ProjectUpdateManyWithoutStarterInput;
  trades?: TradeUpdateManyWithoutUserInput;
}

export interface ClassMateCreateManyWithoutStudentInput {
  create?:
    | ClassMateCreateWithoutStudentInput[]
    | ClassMateCreateWithoutStudentInput;
  connect?: ClassMateWhereUniqueInput[] | ClassMateWhereUniqueInput;
}

export interface ClassMateUpdateManyWithoutStudentInput {
  create?:
    | ClassMateCreateWithoutStudentInput[]
    | ClassMateCreateWithoutStudentInput;
  delete?: ClassMateWhereUniqueInput[] | ClassMateWhereUniqueInput;
  connect?: ClassMateWhereUniqueInput[] | ClassMateWhereUniqueInput;
  disconnect?: ClassMateWhereUniqueInput[] | ClassMateWhereUniqueInput;
  update?:
    | ClassMateUpdateWithWhereUniqueWithoutStudentInput[]
    | ClassMateUpdateWithWhereUniqueWithoutStudentInput;
  upsert?:
    | ClassMateUpsertWithWhereUniqueWithoutStudentInput[]
    | ClassMateUpsertWithWhereUniqueWithoutStudentInput;
  deleteMany?: ClassMateScalarWhereInput[] | ClassMateScalarWhereInput;
  updateMany?:
    | ClassMateUpdateManyWithWhereNestedInput[]
    | ClassMateUpdateManyWithWhereNestedInput;
}

export interface ClassGroupCreateOneWithoutMembersInput {
  create?: ClassGroupCreateWithoutMembersInput;
  connect?: ClassGroupWhereUniqueInput;
}

export interface ClassMateUpdateWithWhereUniqueWithoutStudentInput {
  where: ClassMateWhereUniqueInput;
  data: ClassMateUpdateWithoutStudentDataInput;
}

export interface SchoolEduCreateOneInput {
  create?: SchoolEduCreateInput;
  connect?: SchoolEduWhereUniqueInput;
}

export interface ClassMateUpdateWithoutStudentDataInput {
  status?: String;
  group?: ClassGroupUpdateOneRequiredWithoutMembersInput;
}

export interface UserCreateManyWithoutStudiesInput {
  create?: UserCreateWithoutStudiesInput[] | UserCreateWithoutStudiesInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface ClassGroupUpdateOneRequiredWithoutMembersInput {
  create?: ClassGroupCreateWithoutMembersInput;
  update?: ClassGroupUpdateWithoutMembersDataInput;
  upsert?: ClassGroupUpsertWithoutMembersInput;
  connect?: ClassGroupWhereUniqueInput;
}

export interface FamilyGroupCreateOneWithoutCreaterInput {
  create?: FamilyGroupCreateWithoutCreaterInput;
  connect?: FamilyGroupWhereUniqueInput;
}

export interface ClassGroupUpdateWithoutMembersDataInput {
  study?: SchoolEduUpdateOneInput;
  name?: String;
}

export interface FamilyCreateManyInput {
  create?: FamilyCreateInput[] | FamilyCreateInput;
  connect?: FamilyWhereUniqueInput[] | FamilyWhereUniqueInput;
}

export interface SchoolEduUpdateOneInput {
  create?: SchoolEduCreateInput;
  update?: SchoolEduUpdateDataInput;
  upsert?: SchoolEduUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: SchoolEduWhereUniqueInput;
}

export interface FamilyCreateOneInput {
  create?: FamilyCreateInput;
  connect?: FamilyWhereUniqueInput;
}

export interface SchoolEduUpdateDataInput {
  school?: SchoolUpdateOneInput;
  startTime?: DateTimeInput;
  major?: MajorUpdateOneInput;
  grade?: Int;
  className?: String;
  students?: UserUpdateManyWithoutStudiesInput;
}

export interface UserCreateWithoutFamilyGroupInput {
  username: String;
  password: String;
  name?: String;
  gender?: String;
  avatar?: PhotoCreateOneWithoutUserInput;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationCreateOneWithoutBornsInput;
  residence?: LocationCreateOneWithoutLivesInput;
  uid: String;
  token: String;
  posts?: PostCreateManyWithoutAuthorInput;
  regStatus?: RegStatusCreateOneWithoutApplicantsInput;
  regTimes?: Int;
  maxRegTimes?: Int;
  families?: FamilyCreateManyWithoutFromInput;
  studies?: SchoolEduCreateManyWithoutStudentsInput;
  works?: WorkCreateManyWithoutWorkerInput;
  exam?: CollegeEntranceExamCreateOneWithoutStudentInput;
  sentMessages?: MessageCreateManyWithoutFromInput;
  receiveMessages?: MessageCreateManyWithoutToInput;
  groupMessages?: GroupMessageCreateManyWithoutFromInput;
  groups?: GroupCreateManyWithoutUsersInput;
  friends?: UserCreateManyInput;
  creater?: FamilyGroupCreateOneWithoutCreaterInput;
  classMate?: ClassMateCreateManyWithoutStudentInput;
  workGroup?: WorkGroupCreateOneInput;
  colleagues?: ColleagueCreateManyWithoutWorkerInput;
  fromOldColleagues?: OldColleagueCreateManyWithoutFromInput;
  toOldColleagues?: OldColleagueCreateManyWithoutToInput;
  locationGroups?: LocationGroupCreateManyWithoutUsersInput;
  forgetPassword?: FindPassWordCreateOneWithoutForgetterInput;
  remmemberPassword?: FindPassWordCreateManyWithoutRemmemberInput;
  loveSetting?: LoveSettingCreateOneWithoutUserInput;
  loveWoman?: LoveMatchingCreateManyWithoutWomanInput;
  loveMan?: LoveMatchingCreateManyWithoutManInput;
  signUpLove?: LoveSignUpCreateOneWithoutPersonInput;
  skills?: SkillCreateManyWithoutPersonsInput;
  fitConditions?: PartnerConditionCreateManyWithoutPartnersInput;
  nofitConditions?: PartnerConditionCreateManyWithoutPassedPartnersInput;
  projects?: ProjectCreateManyWithoutStarterInput;
  trades?: TradeCreateManyWithoutUserInput;
}

export interface MajorUpdateOneInput {
  create?: MajorCreateInput;
  update?: MajorUpdateDataInput;
  upsert?: MajorUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: MajorWhereUniqueInput;
}

export interface SkillWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  persons_every?: UserWhereInput;
  persons_some?: UserWhereInput;
  persons_none?: UserWhereInput;
  AND?: SkillWhereInput[] | SkillWhereInput;
  OR?: SkillWhereInput[] | SkillWhereInput;
  NOT?: SkillWhereInput[] | SkillWhereInput;
}

export interface UserUpdateManyWithoutStudiesInput {
  create?: UserCreateWithoutStudiesInput[] | UserCreateWithoutStudiesInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueWithoutStudiesInput[]
    | UserUpdateWithWhereUniqueWithoutStudiesInput;
  upsert?:
    | UserUpsertWithWhereUniqueWithoutStudiesInput[]
    | UserUpsertWithWhereUniqueWithoutStudiesInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export interface LoveMatchingWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  period?: String;
  period_not?: String;
  period_in?: String[] | String;
  period_not_in?: String[] | String;
  period_lt?: String;
  period_lte?: String;
  period_gt?: String;
  period_gte?: String;
  period_contains?: String;
  period_not_contains?: String;
  period_starts_with?: String;
  period_not_starts_with?: String;
  period_ends_with?: String;
  period_not_ends_with?: String;
  city?: CityWhereInput;
  woman?: UserWhereInput;
  man?: UserWhereInput;
  AND?: LoveMatchingWhereInput[] | LoveMatchingWhereInput;
  OR?: LoveMatchingWhereInput[] | LoveMatchingWhereInput;
  NOT?: LoveMatchingWhereInput[] | LoveMatchingWhereInput;
}

export interface UserUpdateWithWhereUniqueWithoutStudiesInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutStudiesDataInput;
}

export interface FindPassWordWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  times?: Int;
  times_not?: Int;
  times_in?: Int[] | Int;
  times_not_in?: Int[] | Int;
  times_lt?: Int;
  times_lte?: Int;
  times_gt?: Int;
  times_gte?: Int;
  forgetter?: UserWhereInput;
  remmember_every?: UserWhereInput;
  remmember_some?: UserWhereInput;
  remmember_none?: UserWhereInput;
  AND?: FindPassWordWhereInput[] | FindPassWordWhereInput;
  OR?: FindPassWordWhereInput[] | FindPassWordWhereInput;
  NOT?: FindPassWordWhereInput[] | FindPassWordWhereInput;
}

export interface UserUpdateWithoutStudiesDataInput {
  username?: String;
  password?: String;
  name?: String;
  gender?: String;
  avatar?: PhotoUpdateOneWithoutUserInput;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationUpdateOneWithoutBornsInput;
  residence?: LocationUpdateOneWithoutLivesInput;
  uid?: String;
  token?: String;
  posts?: PostUpdateManyWithoutAuthorInput;
  regStatus?: RegStatusUpdateOneWithoutApplicantsInput;
  regTimes?: Int;
  maxRegTimes?: Int;
  families?: FamilyUpdateManyWithoutFromInput;
  works?: WorkUpdateManyWithoutWorkerInput;
  exam?: CollegeEntranceExamUpdateOneWithoutStudentInput;
  sentMessages?: MessageUpdateManyWithoutFromInput;
  receiveMessages?: MessageUpdateManyWithoutToInput;
  groupMessages?: GroupMessageUpdateManyWithoutFromInput;
  groups?: GroupUpdateManyWithoutUsersInput;
  friends?: UserUpdateManyInput;
  familyGroup?: FamilyGroupUpdateOneWithoutUsersInput;
  creater?: FamilyGroupUpdateOneWithoutCreaterInput;
  classMate?: ClassMateUpdateManyWithoutStudentInput;
  workGroup?: WorkGroupUpdateOneInput;
  colleagues?: ColleagueUpdateManyWithoutWorkerInput;
  fromOldColleagues?: OldColleagueUpdateManyWithoutFromInput;
  toOldColleagues?: OldColleagueUpdateManyWithoutToInput;
  locationGroups?: LocationGroupUpdateManyWithoutUsersInput;
  forgetPassword?: FindPassWordUpdateOneWithoutForgetterInput;
  remmemberPassword?: FindPassWordUpdateManyWithoutRemmemberInput;
  loveSetting?: LoveSettingUpdateOneWithoutUserInput;
  loveWoman?: LoveMatchingUpdateManyWithoutWomanInput;
  loveMan?: LoveMatchingUpdateManyWithoutManInput;
  signUpLove?: LoveSignUpUpdateOneWithoutPersonInput;
  skills?: SkillUpdateManyWithoutPersonsInput;
  fitConditions?: PartnerConditionUpdateManyWithoutPartnersInput;
  nofitConditions?: PartnerConditionUpdateManyWithoutPassedPartnersInput;
  projects?: ProjectUpdateManyWithoutStarterInput;
  trades?: TradeUpdateManyWithoutUserInput;
}

export interface WorkGroupCreateWithoutColleaguesInput {
  company?: CompanyCreateOneWithoutWorkGroupInput;
}

export interface FamilyGroupUpdateOneWithoutCreaterInput {
  create?: FamilyGroupCreateWithoutCreaterInput;
  update?: FamilyGroupUpdateWithoutCreaterDataInput;
  upsert?: FamilyGroupUpsertWithoutCreaterInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: FamilyGroupWhereUniqueInput;
}

export interface OldColleagueCreateWithoutFromInput {
  to?: UserCreateOneWithoutToOldColleaguesInput;
  company?: CompanyCreateOneInput;
  status: String;
}

export interface FamilyGroupUpdateWithoutCreaterDataInput {
  father?: PersonUpdateOneWithoutAsFatherInput;
  mother?: PersonUpdateOneWithoutAsMotherInput;
  name?: String;
  families?: FamilyUpdateManyInput;
  users?: UserUpdateManyWithoutFamilyGroupInput;
}

export interface UserCreateWithoutToOldColleaguesInput {
  username: String;
  password: String;
  name?: String;
  gender?: String;
  avatar?: PhotoCreateOneWithoutUserInput;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationCreateOneWithoutBornsInput;
  residence?: LocationCreateOneWithoutLivesInput;
  uid: String;
  token: String;
  posts?: PostCreateManyWithoutAuthorInput;
  regStatus?: RegStatusCreateOneWithoutApplicantsInput;
  regTimes?: Int;
  maxRegTimes?: Int;
  families?: FamilyCreateManyWithoutFromInput;
  studies?: SchoolEduCreateManyWithoutStudentsInput;
  works?: WorkCreateManyWithoutWorkerInput;
  exam?: CollegeEntranceExamCreateOneWithoutStudentInput;
  sentMessages?: MessageCreateManyWithoutFromInput;
  receiveMessages?: MessageCreateManyWithoutToInput;
  groupMessages?: GroupMessageCreateManyWithoutFromInput;
  groups?: GroupCreateManyWithoutUsersInput;
  friends?: UserCreateManyInput;
  familyGroup?: FamilyGroupCreateOneWithoutUsersInput;
  creater?: FamilyGroupCreateOneWithoutCreaterInput;
  classMate?: ClassMateCreateManyWithoutStudentInput;
  workGroup?: WorkGroupCreateOneInput;
  colleagues?: ColleagueCreateManyWithoutWorkerInput;
  fromOldColleagues?: OldColleagueCreateManyWithoutFromInput;
  locationGroups?: LocationGroupCreateManyWithoutUsersInput;
  forgetPassword?: FindPassWordCreateOneWithoutForgetterInput;
  remmemberPassword?: FindPassWordCreateManyWithoutRemmemberInput;
  loveSetting?: LoveSettingCreateOneWithoutUserInput;
  loveWoman?: LoveMatchingCreateManyWithoutWomanInput;
  loveMan?: LoveMatchingCreateManyWithoutManInput;
  signUpLove?: LoveSignUpCreateOneWithoutPersonInput;
  skills?: SkillCreateManyWithoutPersonsInput;
  fitConditions?: PartnerConditionCreateManyWithoutPartnersInput;
  nofitConditions?: PartnerConditionCreateManyWithoutPassedPartnersInput;
  projects?: ProjectCreateManyWithoutStarterInput;
  trades?: TradeCreateManyWithoutUserInput;
}

export interface FamilyUpdateManyInput {
  create?: FamilyCreateInput[] | FamilyCreateInput;
  update?:
    | FamilyUpdateWithWhereUniqueNestedInput[]
    | FamilyUpdateWithWhereUniqueNestedInput;
  upsert?:
    | FamilyUpsertWithWhereUniqueNestedInput[]
    | FamilyUpsertWithWhereUniqueNestedInput;
  delete?: FamilyWhereUniqueInput[] | FamilyWhereUniqueInput;
  connect?: FamilyWhereUniqueInput[] | FamilyWhereUniqueInput;
  disconnect?: FamilyWhereUniqueInput[] | FamilyWhereUniqueInput;
  deleteMany?: FamilyScalarWhereInput[] | FamilyScalarWhereInput;
  updateMany?:
    | FamilyUpdateManyWithWhereNestedInput[]
    | FamilyUpdateManyWithWhereNestedInput;
}

export interface LocationGroupCreateWithoutUsersInput {
  kind?: LocationGroupKind;
  code?: String;
  name?: String;
}

export interface FamilyUpdateWithWhereUniqueNestedInput {
  where: FamilyWhereUniqueInput;
  data: FamilyUpdateDataInput;
}

export interface FindPassWordCreateWithoutForgetterInput {
  times?: Int;
  remmember?: UserCreateManyWithoutRemmemberPasswordInput;
}

export interface FamilyUpdateDataInput {
  from?: UserUpdateOneRequiredWithoutFamiliesInput;
  to?: PersonUpdateOneRequiredWithoutFamiliesInput;
  relationship?: String;
  spouse?: FamilyUpdateOneInput;
  status?: String;
}

export interface UserCreateWithoutRemmemberPasswordInput {
  username: String;
  password: String;
  name?: String;
  gender?: String;
  avatar?: PhotoCreateOneWithoutUserInput;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationCreateOneWithoutBornsInput;
  residence?: LocationCreateOneWithoutLivesInput;
  uid: String;
  token: String;
  posts?: PostCreateManyWithoutAuthorInput;
  regStatus?: RegStatusCreateOneWithoutApplicantsInput;
  regTimes?: Int;
  maxRegTimes?: Int;
  families?: FamilyCreateManyWithoutFromInput;
  studies?: SchoolEduCreateManyWithoutStudentsInput;
  works?: WorkCreateManyWithoutWorkerInput;
  exam?: CollegeEntranceExamCreateOneWithoutStudentInput;
  sentMessages?: MessageCreateManyWithoutFromInput;
  receiveMessages?: MessageCreateManyWithoutToInput;
  groupMessages?: GroupMessageCreateManyWithoutFromInput;
  groups?: GroupCreateManyWithoutUsersInput;
  friends?: UserCreateManyInput;
  familyGroup?: FamilyGroupCreateOneWithoutUsersInput;
  creater?: FamilyGroupCreateOneWithoutCreaterInput;
  classMate?: ClassMateCreateManyWithoutStudentInput;
  workGroup?: WorkGroupCreateOneInput;
  colleagues?: ColleagueCreateManyWithoutWorkerInput;
  fromOldColleagues?: OldColleagueCreateManyWithoutFromInput;
  toOldColleagues?: OldColleagueCreateManyWithoutToInput;
  locationGroups?: LocationGroupCreateManyWithoutUsersInput;
  forgetPassword?: FindPassWordCreateOneWithoutForgetterInput;
  loveSetting?: LoveSettingCreateOneWithoutUserInput;
  loveWoman?: LoveMatchingCreateManyWithoutWomanInput;
  loveMan?: LoveMatchingCreateManyWithoutManInput;
  signUpLove?: LoveSignUpCreateOneWithoutPersonInput;
  skills?: SkillCreateManyWithoutPersonsInput;
  fitConditions?: PartnerConditionCreateManyWithoutPartnersInput;
  nofitConditions?: PartnerConditionCreateManyWithoutPassedPartnersInput;
  projects?: ProjectCreateManyWithoutStarterInput;
  trades?: TradeCreateManyWithoutUserInput;
}

export interface FamilyUpdateOneInput {
  create?: FamilyCreateInput;
  update?: FamilyUpdateDataInput;
  upsert?: FamilyUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: FamilyWhereUniqueInput;
}

export interface FamilyGroupCreateInput {
  father?: PersonCreateOneWithoutAsFatherInput;
  mother?: PersonCreateOneWithoutAsMotherInput;
  creater?: UserCreateOneWithoutCreaterInput;
  name?: String;
  families?: FamilyCreateManyInput;
  users?: UserCreateManyWithoutFamilyGroupInput;
}

export interface FamilyUpsertNestedInput {
  update: FamilyUpdateDataInput;
  create: FamilyCreateInput;
}

export interface FamilyUpdateManyMutationInput {
  relationship?: String;
  status?: String;
}

export interface FamilyUpsertWithWhereUniqueNestedInput {
  where: FamilyWhereUniqueInput;
  update: FamilyUpdateDataInput;
  create: FamilyCreateInput;
}

export interface FamilyUpdateInput {
  from?: UserUpdateOneRequiredWithoutFamiliesInput;
  to?: PersonUpdateOneRequiredWithoutFamiliesInput;
  relationship?: String;
  spouse?: FamilyUpdateOneInput;
  status?: String;
}

export interface FamilyScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  relationship?: String;
  relationship_not?: String;
  relationship_in?: String[] | String;
  relationship_not_in?: String[] | String;
  relationship_lt?: String;
  relationship_lte?: String;
  relationship_gt?: String;
  relationship_gte?: String;
  relationship_contains?: String;
  relationship_not_contains?: String;
  relationship_starts_with?: String;
  relationship_not_starts_with?: String;
  relationship_ends_with?: String;
  relationship_not_ends_with?: String;
  status?: String;
  status_not?: String;
  status_in?: String[] | String;
  status_not_in?: String[] | String;
  status_lt?: String;
  status_lte?: String;
  status_gt?: String;
  status_gte?: String;
  status_contains?: String;
  status_not_contains?: String;
  status_starts_with?: String;
  status_not_starts_with?: String;
  status_ends_with?: String;
  status_not_ends_with?: String;
  AND?: FamilyScalarWhereInput[] | FamilyScalarWhereInput;
  OR?: FamilyScalarWhereInput[] | FamilyScalarWhereInput;
  NOT?: FamilyScalarWhereInput[] | FamilyScalarWhereInput;
}

export interface CompanyUpdateManyMutationInput {
  name?: String;
  code?: String;
  establishmentDate?: DateTimeInput;
  representative?: String;
  BusinessScope?: String;
}

export interface FamilyUpdateManyWithWhereNestedInput {
  where: FamilyScalarWhereInput;
  data: FamilyUpdateManyDataInput;
}

export interface LoveSettingCreateWithoutUserInput {
  myHeight?: Int;
  myWeight?: Int;
  otherHeightMin?: Int;
  otherHeightMax?: Int;
  otherWeightMin?: Int;
  otherWeightMax?: Int;
  otherAgeMin?: Int;
  otherAgeMax?: Int;
  dateTime?: String;
  datePlace?: String;
  memeberGrade?: Int;
  memeberGradeEndTime?: String;
}

export interface FamilyUpdateManyDataInput {
  relationship?: String;
  status?: String;
}

export interface LoveMatchingCreateWithoutWomanInput {
  period?: String;
  city?: CityCreateOneInput;
  man?: UserCreateOneWithoutLoveManInput;
}

export interface UserUpdateManyWithoutFamilyGroupInput {
  create?:
    | UserCreateWithoutFamilyGroupInput[]
    | UserCreateWithoutFamilyGroupInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueWithoutFamilyGroupInput[]
    | UserUpdateWithWhereUniqueWithoutFamilyGroupInput;
  upsert?:
    | UserUpsertWithWhereUniqueWithoutFamilyGroupInput[]
    | UserUpsertWithWhereUniqueWithoutFamilyGroupInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export interface ProjectWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  place?: CityWhereInput;
  content?: String;
  content_not?: String;
  content_in?: String[] | String;
  content_not_in?: String[] | String;
  content_lt?: String;
  content_lte?: String;
  content_gt?: String;
  content_gte?: String;
  content_contains?: String;
  content_not_contains?: String;
  content_starts_with?: String;
  content_not_starts_with?: String;
  content_ends_with?: String;
  content_not_ends_with?: String;
  conditions_every?: PartnerConditionWhereInput;
  conditions_some?: PartnerConditionWhereInput;
  conditions_none?: PartnerConditionWhereInput;
  starter?: UserWhereInput;
  AND?: ProjectWhereInput[] | ProjectWhereInput;
  OR?: ProjectWhereInput[] | ProjectWhereInput;
  NOT?: ProjectWhereInput[] | ProjectWhereInput;
}

export interface UserUpdateWithWhereUniqueWithoutFamilyGroupInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutFamilyGroupDataInput;
}

export interface LoveSignUpCreateWithoutPersonInput {
  period?: String;
  city?: CityCreateOneInput;
}

export interface UserUpdateWithoutFamilyGroupDataInput {
  username?: String;
  password?: String;
  name?: String;
  gender?: String;
  avatar?: PhotoUpdateOneWithoutUserInput;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationUpdateOneWithoutBornsInput;
  residence?: LocationUpdateOneWithoutLivesInput;
  uid?: String;
  token?: String;
  posts?: PostUpdateManyWithoutAuthorInput;
  regStatus?: RegStatusUpdateOneWithoutApplicantsInput;
  regTimes?: Int;
  maxRegTimes?: Int;
  families?: FamilyUpdateManyWithoutFromInput;
  studies?: SchoolEduUpdateManyWithoutStudentsInput;
  works?: WorkUpdateManyWithoutWorkerInput;
  exam?: CollegeEntranceExamUpdateOneWithoutStudentInput;
  sentMessages?: MessageUpdateManyWithoutFromInput;
  receiveMessages?: MessageUpdateManyWithoutToInput;
  groupMessages?: GroupMessageUpdateManyWithoutFromInput;
  groups?: GroupUpdateManyWithoutUsersInput;
  friends?: UserUpdateManyInput;
  creater?: FamilyGroupUpdateOneWithoutCreaterInput;
  classMate?: ClassMateUpdateManyWithoutStudentInput;
  workGroup?: WorkGroupUpdateOneInput;
  colleagues?: ColleagueUpdateManyWithoutWorkerInput;
  fromOldColleagues?: OldColleagueUpdateManyWithoutFromInput;
  toOldColleagues?: OldColleagueUpdateManyWithoutToInput;
  locationGroups?: LocationGroupUpdateManyWithoutUsersInput;
  forgetPassword?: FindPassWordUpdateOneWithoutForgetterInput;
  remmemberPassword?: FindPassWordUpdateManyWithoutRemmemberInput;
  loveSetting?: LoveSettingUpdateOneWithoutUserInput;
  loveWoman?: LoveMatchingUpdateManyWithoutWomanInput;
  loveMan?: LoveMatchingUpdateManyWithoutManInput;
  signUpLove?: LoveSignUpUpdateOneWithoutPersonInput;
  skills?: SkillUpdateManyWithoutPersonsInput;
  fitConditions?: PartnerConditionUpdateManyWithoutPartnersInput;
  nofitConditions?: PartnerConditionUpdateManyWithoutPassedPartnersInput;
  projects?: ProjectUpdateManyWithoutStarterInput;
  trades?: TradeUpdateManyWithoutUserInput;
}

export interface SkillCreateWithoutPersonsInput {
  name?: String;
}

export interface WorkGroupUpdateOneInput {
  create?: WorkGroupCreateInput;
  update?: WorkGroupUpdateDataInput;
  upsert?: WorkGroupUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: WorkGroupWhereUniqueInput;
}

export interface PartnerConditionCreateWithoutPartnersInput {
  skillName?: String;
  place?: String;
  number?: Int;
  passedPartners?: UserCreateManyWithoutNofitConditionsInput;
  project?: ProjectCreateOneWithoutConditionsInput;
}

export interface WorkGroupUpdateDataInput {
  company?: CompanyUpdateOneWithoutWorkGroupInput;
  colleagues?: ColleagueUpdateManyWithoutGroupInput;
}

export interface UserCreateWithoutNofitConditionsInput {
  username: String;
  password: String;
  name?: String;
  gender?: String;
  avatar?: PhotoCreateOneWithoutUserInput;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationCreateOneWithoutBornsInput;
  residence?: LocationCreateOneWithoutLivesInput;
  uid: String;
  token: String;
  posts?: PostCreateManyWithoutAuthorInput;
  regStatus?: RegStatusCreateOneWithoutApplicantsInput;
  regTimes?: Int;
  maxRegTimes?: Int;
  families?: FamilyCreateManyWithoutFromInput;
  studies?: SchoolEduCreateManyWithoutStudentsInput;
  works?: WorkCreateManyWithoutWorkerInput;
  exam?: CollegeEntranceExamCreateOneWithoutStudentInput;
  sentMessages?: MessageCreateManyWithoutFromInput;
  receiveMessages?: MessageCreateManyWithoutToInput;
  groupMessages?: GroupMessageCreateManyWithoutFromInput;
  groups?: GroupCreateManyWithoutUsersInput;
  friends?: UserCreateManyInput;
  familyGroup?: FamilyGroupCreateOneWithoutUsersInput;
  creater?: FamilyGroupCreateOneWithoutCreaterInput;
  classMate?: ClassMateCreateManyWithoutStudentInput;
  workGroup?: WorkGroupCreateOneInput;
  colleagues?: ColleagueCreateManyWithoutWorkerInput;
  fromOldColleagues?: OldColleagueCreateManyWithoutFromInput;
  toOldColleagues?: OldColleagueCreateManyWithoutToInput;
  locationGroups?: LocationGroupCreateManyWithoutUsersInput;
  forgetPassword?: FindPassWordCreateOneWithoutForgetterInput;
  remmemberPassword?: FindPassWordCreateManyWithoutRemmemberInput;
  loveSetting?: LoveSettingCreateOneWithoutUserInput;
  loveWoman?: LoveMatchingCreateManyWithoutWomanInput;
  loveMan?: LoveMatchingCreateManyWithoutManInput;
  signUpLove?: LoveSignUpCreateOneWithoutPersonInput;
  skills?: SkillCreateManyWithoutPersonsInput;
  fitConditions?: PartnerConditionCreateManyWithoutPartnersInput;
  projects?: ProjectCreateManyWithoutStarterInput;
  trades?: TradeCreateManyWithoutUserInput;
}

export interface CompanyUpdateOneWithoutWorkGroupInput {
  create?: CompanyCreateWithoutWorkGroupInput;
  update?: CompanyUpdateWithoutWorkGroupDataInput;
  upsert?: CompanyUpsertWithoutWorkGroupInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: CompanyWhereUniqueInput;
}

export interface LoveMatchingCreateWithoutManInput {
  period?: String;
  city?: CityCreateOneInput;
  woman?: UserCreateOneWithoutLoveWomanInput;
}

export interface CompanyUpdateWithoutWorkGroupDataInput {
  name?: String;
  code?: String;
  establishmentDate?: DateTimeInput;
  representative?: String;
  location?: LocationUpdateOneWithoutCompaniesInput;
  BusinessScope?: String;
  works?: WorkUpdateManyWithoutCompanyInput;
}

export interface UserCreateWithoutLoveWomanInput {
  username: String;
  password: String;
  name?: String;
  gender?: String;
  avatar?: PhotoCreateOneWithoutUserInput;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationCreateOneWithoutBornsInput;
  residence?: LocationCreateOneWithoutLivesInput;
  uid: String;
  token: String;
  posts?: PostCreateManyWithoutAuthorInput;
  regStatus?: RegStatusCreateOneWithoutApplicantsInput;
  regTimes?: Int;
  maxRegTimes?: Int;
  families?: FamilyCreateManyWithoutFromInput;
  studies?: SchoolEduCreateManyWithoutStudentsInput;
  works?: WorkCreateManyWithoutWorkerInput;
  exam?: CollegeEntranceExamCreateOneWithoutStudentInput;
  sentMessages?: MessageCreateManyWithoutFromInput;
  receiveMessages?: MessageCreateManyWithoutToInput;
  groupMessages?: GroupMessageCreateManyWithoutFromInput;
  groups?: GroupCreateManyWithoutUsersInput;
  friends?: UserCreateManyInput;
  familyGroup?: FamilyGroupCreateOneWithoutUsersInput;
  creater?: FamilyGroupCreateOneWithoutCreaterInput;
  classMate?: ClassMateCreateManyWithoutStudentInput;
  workGroup?: WorkGroupCreateOneInput;
  colleagues?: ColleagueCreateManyWithoutWorkerInput;
  fromOldColleagues?: OldColleagueCreateManyWithoutFromInput;
  toOldColleagues?: OldColleagueCreateManyWithoutToInput;
  locationGroups?: LocationGroupCreateManyWithoutUsersInput;
  forgetPassword?: FindPassWordCreateOneWithoutForgetterInput;
  remmemberPassword?: FindPassWordCreateManyWithoutRemmemberInput;
  loveSetting?: LoveSettingCreateOneWithoutUserInput;
  loveMan?: LoveMatchingCreateManyWithoutManInput;
  signUpLove?: LoveSignUpCreateOneWithoutPersonInput;
  skills?: SkillCreateManyWithoutPersonsInput;
  fitConditions?: PartnerConditionCreateManyWithoutPartnersInput;
  nofitConditions?: PartnerConditionCreateManyWithoutPassedPartnersInput;
  projects?: ProjectCreateManyWithoutStarterInput;
  trades?: TradeCreateManyWithoutUserInput;
}

export interface CompanyUpsertWithoutWorkGroupInput {
  update: CompanyUpdateWithoutWorkGroupDataInput;
  create: CompanyCreateWithoutWorkGroupInput;
}

export interface PartnerConditionCreateWithoutPassedPartnersInput {
  skillName?: String;
  place?: String;
  number?: Int;
  partners?: UserCreateManyWithoutFitConditionsInput;
  project?: ProjectCreateOneWithoutConditionsInput;
}

export interface WorkGroupUpsertNestedInput {
  update: WorkGroupUpdateDataInput;
  create: WorkGroupCreateInput;
}

export interface UserCreateWithoutFitConditionsInput {
  username: String;
  password: String;
  name?: String;
  gender?: String;
  avatar?: PhotoCreateOneWithoutUserInput;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationCreateOneWithoutBornsInput;
  residence?: LocationCreateOneWithoutLivesInput;
  uid: String;
  token: String;
  posts?: PostCreateManyWithoutAuthorInput;
  regStatus?: RegStatusCreateOneWithoutApplicantsInput;
  regTimes?: Int;
  maxRegTimes?: Int;
  families?: FamilyCreateManyWithoutFromInput;
  studies?: SchoolEduCreateManyWithoutStudentsInput;
  works?: WorkCreateManyWithoutWorkerInput;
  exam?: CollegeEntranceExamCreateOneWithoutStudentInput;
  sentMessages?: MessageCreateManyWithoutFromInput;
  receiveMessages?: MessageCreateManyWithoutToInput;
  groupMessages?: GroupMessageCreateManyWithoutFromInput;
  groups?: GroupCreateManyWithoutUsersInput;
  friends?: UserCreateManyInput;
  familyGroup?: FamilyGroupCreateOneWithoutUsersInput;
  creater?: FamilyGroupCreateOneWithoutCreaterInput;
  classMate?: ClassMateCreateManyWithoutStudentInput;
  workGroup?: WorkGroupCreateOneInput;
  colleagues?: ColleagueCreateManyWithoutWorkerInput;
  fromOldColleagues?: OldColleagueCreateManyWithoutFromInput;
  toOldColleagues?: OldColleagueCreateManyWithoutToInput;
  locationGroups?: LocationGroupCreateManyWithoutUsersInput;
  forgetPassword?: FindPassWordCreateOneWithoutForgetterInput;
  remmemberPassword?: FindPassWordCreateManyWithoutRemmemberInput;
  loveSetting?: LoveSettingCreateOneWithoutUserInput;
  loveWoman?: LoveMatchingCreateManyWithoutWomanInput;
  loveMan?: LoveMatchingCreateManyWithoutManInput;
  signUpLove?: LoveSignUpCreateOneWithoutPersonInput;
  skills?: SkillCreateManyWithoutPersonsInput;
  nofitConditions?: PartnerConditionCreateManyWithoutPassedPartnersInput;
  projects?: ProjectCreateManyWithoutStarterInput;
  trades?: TradeCreateManyWithoutUserInput;
}

export interface ColleagueUpdateManyWithoutWorkerInput {
  create?:
    | ColleagueCreateWithoutWorkerInput[]
    | ColleagueCreateWithoutWorkerInput;
  delete?: ColleagueWhereUniqueInput[] | ColleagueWhereUniqueInput;
  connect?: ColleagueWhereUniqueInput[] | ColleagueWhereUniqueInput;
  disconnect?: ColleagueWhereUniqueInput[] | ColleagueWhereUniqueInput;
  update?:
    | ColleagueUpdateWithWhereUniqueWithoutWorkerInput[]
    | ColleagueUpdateWithWhereUniqueWithoutWorkerInput;
  upsert?:
    | ColleagueUpsertWithWhereUniqueWithoutWorkerInput[]
    | ColleagueUpsertWithWhereUniqueWithoutWorkerInput;
  deleteMany?: ColleagueScalarWhereInput[] | ColleagueScalarWhereInput;
  updateMany?:
    | ColleagueUpdateManyWithWhereNestedInput[]
    | ColleagueUpdateManyWithWhereNestedInput;
}

export interface ProjectCreateWithoutStarterInput {
  name?: String;
  place?: CityCreateOneInput;
  content?: String;
  conditions?: PartnerConditionCreateManyWithoutProjectInput;
}

export interface ColleagueUpdateWithWhereUniqueWithoutWorkerInput {
  where: ColleagueWhereUniqueInput;
  data: ColleagueUpdateWithoutWorkerDataInput;
}

export interface PartnerConditionCreateWithoutProjectInput {
  skillName?: String;
  place?: String;
  number?: Int;
  partners?: UserCreateManyWithoutFitConditionsInput;
  passedPartners?: UserCreateManyWithoutNofitConditionsInput;
}

export interface ColleagueUpdateWithoutWorkerDataInput {
  status?: String;
  group?: WorkGroupUpdateOneWithoutColleaguesInput;
}

export interface TradeCreateWithoutUserInput {
  product?: ProductCreateOneInput;
  number?: Int;
  amount?: Float;
  status?: String;
}

export interface WorkGroupUpdateOneWithoutColleaguesInput {
  create?: WorkGroupCreateWithoutColleaguesInput;
  update?: WorkGroupUpdateWithoutColleaguesDataInput;
  upsert?: WorkGroupUpsertWithoutColleaguesInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: WorkGroupWhereUniqueInput;
}

export interface ProductCreateInput {
  subject?: String;
  info?: String;
  price?: Float;
  kind?: String;
}

export interface WorkGroupUpdateWithoutColleaguesDataInput {
  company?: CompanyUpdateOneWithoutWorkGroupInput;
}

export interface ProjectCreateWithoutConditionsInput {
  name?: String;
  place?: CityCreateOneInput;
  content?: String;
  starter?: UserCreateOneWithoutProjectsInput;
}

export interface WorkGroupUpsertWithoutColleaguesInput {
  update: WorkGroupUpdateWithoutColleaguesDataInput;
  create: WorkGroupCreateWithoutColleaguesInput;
}

export interface UserCreateWithoutProjectsInput {
  username: String;
  password: String;
  name?: String;
  gender?: String;
  avatar?: PhotoCreateOneWithoutUserInput;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationCreateOneWithoutBornsInput;
  residence?: LocationCreateOneWithoutLivesInput;
  uid: String;
  token: String;
  posts?: PostCreateManyWithoutAuthorInput;
  regStatus?: RegStatusCreateOneWithoutApplicantsInput;
  regTimes?: Int;
  maxRegTimes?: Int;
  families?: FamilyCreateManyWithoutFromInput;
  studies?: SchoolEduCreateManyWithoutStudentsInput;
  works?: WorkCreateManyWithoutWorkerInput;
  exam?: CollegeEntranceExamCreateOneWithoutStudentInput;
  sentMessages?: MessageCreateManyWithoutFromInput;
  receiveMessages?: MessageCreateManyWithoutToInput;
  groupMessages?: GroupMessageCreateManyWithoutFromInput;
  groups?: GroupCreateManyWithoutUsersInput;
  friends?: UserCreateManyInput;
  familyGroup?: FamilyGroupCreateOneWithoutUsersInput;
  creater?: FamilyGroupCreateOneWithoutCreaterInput;
  classMate?: ClassMateCreateManyWithoutStudentInput;
  workGroup?: WorkGroupCreateOneInput;
  colleagues?: ColleagueCreateManyWithoutWorkerInput;
  fromOldColleagues?: OldColleagueCreateManyWithoutFromInput;
  toOldColleagues?: OldColleagueCreateManyWithoutToInput;
  locationGroups?: LocationGroupCreateManyWithoutUsersInput;
  forgetPassword?: FindPassWordCreateOneWithoutForgetterInput;
  remmemberPassword?: FindPassWordCreateManyWithoutRemmemberInput;
  loveSetting?: LoveSettingCreateOneWithoutUserInput;
  loveWoman?: LoveMatchingCreateManyWithoutWomanInput;
  loveMan?: LoveMatchingCreateManyWithoutManInput;
  signUpLove?: LoveSignUpCreateOneWithoutPersonInput;
  skills?: SkillCreateManyWithoutPersonsInput;
  fitConditions?: PartnerConditionCreateManyWithoutPartnersInput;
  nofitConditions?: PartnerConditionCreateManyWithoutPassedPartnersInput;
  trades?: TradeCreateManyWithoutUserInput;
}

export interface ColleagueUpsertWithWhereUniqueWithoutWorkerInput {
  where: ColleagueWhereUniqueInput;
  update: ColleagueUpdateWithoutWorkerDataInput;
  create: ColleagueCreateWithoutWorkerInput;
}

export interface CompanyCreateInput {
  name?: String;
  code?: String;
  establishmentDate?: DateTimeInput;
  representative?: String;
  location?: LocationCreateOneWithoutCompaniesInput;
  BusinessScope?: String;
  works?: WorkCreateManyWithoutCompanyInput;
  workGroup?: WorkGroupCreateOneWithoutCompanyInput;
}

export interface ColleagueScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  status?: String;
  status_not?: String;
  status_in?: String[] | String;
  status_not_in?: String[] | String;
  status_lt?: String;
  status_lte?: String;
  status_gt?: String;
  status_gte?: String;
  status_contains?: String;
  status_not_contains?: String;
  status_starts_with?: String;
  status_not_starts_with?: String;
  status_ends_with?: String;
  status_not_ends_with?: String;
  AND?: ColleagueScalarWhereInput[] | ColleagueScalarWhereInput;
  OR?: ColleagueScalarWhereInput[] | ColleagueScalarWhereInput;
  NOT?: ColleagueScalarWhereInput[] | ColleagueScalarWhereInput;
}

export interface MessageWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  to?: UserWhereInput;
  from?: UserWhereInput;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  image?: PhotoWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  AND?: MessageWhereInput[] | MessageWhereInput;
  OR?: MessageWhereInput[] | MessageWhereInput;
  NOT?: MessageWhereInput[] | MessageWhereInput;
}

export interface ColleagueUpdateManyWithWhereNestedInput {
  where: ColleagueScalarWhereInput;
  data: ColleagueUpdateManyDataInput;
}

export interface CollegeEntranceExamWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  province?: ProvinceWhereInput;
  subject?: String;
  subject_not?: String;
  subject_in?: String[] | String;
  subject_not_in?: String[] | String;
  subject_lt?: String;
  subject_lte?: String;
  subject_gt?: String;
  subject_gte?: String;
  subject_contains?: String;
  subject_not_contains?: String;
  subject_starts_with?: String;
  subject_not_starts_with?: String;
  subject_ends_with?: String;
  subject_not_ends_with?: String;
  culscore?: Float;
  culscore_not?: Float;
  culscore_in?: Float[] | Float;
  culscore_not_in?: Float[] | Float;
  culscore_lt?: Float;
  culscore_lte?: Float;
  culscore_gt?: Float;
  culscore_gte?: Float;
  proscore?: Float;
  proscore_not?: Float;
  proscore_in?: Float[] | Float;
  proscore_not_in?: Float[] | Float;
  proscore_lt?: Float;
  proscore_lte?: Float;
  proscore_gt?: Float;
  proscore_gte?: Float;
  candidatenum?: String;
  candidatenum_not?: String;
  candidatenum_in?: String[] | String;
  candidatenum_not_in?: String[] | String;
  candidatenum_lt?: String;
  candidatenum_lte?: String;
  candidatenum_gt?: String;
  candidatenum_gte?: String;
  candidatenum_contains?: String;
  candidatenum_not_contains?: String;
  candidatenum_starts_with?: String;
  candidatenum_not_starts_with?: String;
  candidatenum_ends_with?: String;
  candidatenum_not_ends_with?: String;
  times?: Int;
  times_not?: Int;
  times_in?: Int[] | Int;
  times_not_in?: Int[] | Int;
  times_lt?: Int;
  times_lte?: Int;
  times_gt?: Int;
  times_gte?: Int;
  student?: UserWhereInput;
  AND?: CollegeEntranceExamWhereInput[] | CollegeEntranceExamWhereInput;
  OR?: CollegeEntranceExamWhereInput[] | CollegeEntranceExamWhereInput;
  NOT?: CollegeEntranceExamWhereInput[] | CollegeEntranceExamWhereInput;
}

export interface ColleagueUpdateManyDataInput {
  status?: String;
}

export interface SchoolEduWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  school?: SchoolWhereInput;
  startTime?: DateTimeInput;
  startTime_not?: DateTimeInput;
  startTime_in?: DateTimeInput[] | DateTimeInput;
  startTime_not_in?: DateTimeInput[] | DateTimeInput;
  startTime_lt?: DateTimeInput;
  startTime_lte?: DateTimeInput;
  startTime_gt?: DateTimeInput;
  startTime_gte?: DateTimeInput;
  major?: MajorWhereInput;
  grade?: Int;
  grade_not?: Int;
  grade_in?: Int[] | Int;
  grade_not_in?: Int[] | Int;
  grade_lt?: Int;
  grade_lte?: Int;
  grade_gt?: Int;
  grade_gte?: Int;
  className?: String;
  className_not?: String;
  className_in?: String[] | String;
  className_not_in?: String[] | String;
  className_lt?: String;
  className_lte?: String;
  className_gt?: String;
  className_gte?: String;
  className_contains?: String;
  className_not_contains?: String;
  className_starts_with?: String;
  className_not_starts_with?: String;
  className_ends_with?: String;
  className_not_ends_with?: String;
  students_every?: UserWhereInput;
  students_some?: UserWhereInput;
  students_none?: UserWhereInput;
  AND?: SchoolEduWhereInput[] | SchoolEduWhereInput;
  OR?: SchoolEduWhereInput[] | SchoolEduWhereInput;
  NOT?: SchoolEduWhereInput[] | SchoolEduWhereInput;
}

export interface OldColleagueUpdateManyWithoutFromInput {
  create?:
    | OldColleagueCreateWithoutFromInput[]
    | OldColleagueCreateWithoutFromInput;
  delete?: OldColleagueWhereUniqueInput[] | OldColleagueWhereUniqueInput;
  connect?: OldColleagueWhereUniqueInput[] | OldColleagueWhereUniqueInput;
  disconnect?: OldColleagueWhereUniqueInput[] | OldColleagueWhereUniqueInput;
  update?:
    | OldColleagueUpdateWithWhereUniqueWithoutFromInput[]
    | OldColleagueUpdateWithWhereUniqueWithoutFromInput;
  upsert?:
    | OldColleagueUpsertWithWhereUniqueWithoutFromInput[]
    | OldColleagueUpsertWithWhereUniqueWithoutFromInput;
  deleteMany?: OldColleagueScalarWhereInput[] | OldColleagueScalarWhereInput;
  updateMany?:
    | OldColleagueUpdateManyWithWhereNestedInput[]
    | OldColleagueUpdateManyWithWhereNestedInput;
}

export interface PersonWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  user?: UserWhereInput;
  families_every?: FamilyWhereInput;
  families_some?: FamilyWhereInput;
  families_none?: FamilyWhereInput;
  asFather_every?: FamilyGroupWhereInput;
  asFather_some?: FamilyGroupWhereInput;
  asFather_none?: FamilyGroupWhereInput;
  asMother_every?: FamilyGroupWhereInput;
  asMother_some?: FamilyGroupWhereInput;
  asMother_none?: FamilyGroupWhereInput;
  AND?: PersonWhereInput[] | PersonWhereInput;
  OR?: PersonWhereInput[] | PersonWhereInput;
  NOT?: PersonWhereInput[] | PersonWhereInput;
}

export interface OldColleagueUpdateWithWhereUniqueWithoutFromInput {
  where: OldColleagueWhereUniqueInput;
  data: OldColleagueUpdateWithoutFromDataInput;
}

export interface FamilyWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  from?: UserWhereInput;
  to?: PersonWhereInput;
  relationship?: String;
  relationship_not?: String;
  relationship_in?: String[] | String;
  relationship_not_in?: String[] | String;
  relationship_lt?: String;
  relationship_lte?: String;
  relationship_gt?: String;
  relationship_gte?: String;
  relationship_contains?: String;
  relationship_not_contains?: String;
  relationship_starts_with?: String;
  relationship_not_starts_with?: String;
  relationship_ends_with?: String;
  relationship_not_ends_with?: String;
  spouse?: FamilyWhereInput;
  status?: String;
  status_not?: String;
  status_in?: String[] | String;
  status_not_in?: String[] | String;
  status_lt?: String;
  status_lte?: String;
  status_gt?: String;
  status_gte?: String;
  status_contains?: String;
  status_not_contains?: String;
  status_starts_with?: String;
  status_not_starts_with?: String;
  status_ends_with?: String;
  status_not_ends_with?: String;
  AND?: FamilyWhereInput[] | FamilyWhereInput;
  OR?: FamilyWhereInput[] | FamilyWhereInput;
  NOT?: FamilyWhereInput[] | FamilyWhereInput;
}

export interface OldColleagueUpdateWithoutFromDataInput {
  to?: UserUpdateOneWithoutToOldColleaguesInput;
  company?: CompanyUpdateOneInput;
  status?: String;
}

export interface ProvinceSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ProvinceWhereInput;
  AND?: ProvinceSubscriptionWhereInput[] | ProvinceSubscriptionWhereInput;
  OR?: ProvinceSubscriptionWhereInput[] | ProvinceSubscriptionWhereInput;
  NOT?: ProvinceSubscriptionWhereInput[] | ProvinceSubscriptionWhereInput;
}

export interface UserUpdateOneWithoutToOldColleaguesInput {
  create?: UserCreateWithoutToOldColleaguesInput;
  update?: UserUpdateWithoutToOldColleaguesDataInput;
  upsert?: UserUpsertWithoutToOldColleaguesInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface PostWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  isPublished?: Boolean;
  isPublished_not?: Boolean;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  content?: String;
  content_not?: String;
  content_in?: String[] | String;
  content_not_in?: String[] | String;
  content_lt?: String;
  content_lte?: String;
  content_gt?: String;
  content_gte?: String;
  content_contains?: String;
  content_not_contains?: String;
  content_starts_with?: String;
  content_not_starts_with?: String;
  content_ends_with?: String;
  content_not_ends_with?: String;
  author?: UserWhereInput;
  AND?: PostWhereInput[] | PostWhereInput;
  OR?: PostWhereInput[] | PostWhereInput;
  NOT?: PostWhereInput[] | PostWhereInput;
}

export interface UserUpdateWithoutToOldColleaguesDataInput {
  username?: String;
  password?: String;
  name?: String;
  gender?: String;
  avatar?: PhotoUpdateOneWithoutUserInput;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationUpdateOneWithoutBornsInput;
  residence?: LocationUpdateOneWithoutLivesInput;
  uid?: String;
  token?: String;
  posts?: PostUpdateManyWithoutAuthorInput;
  regStatus?: RegStatusUpdateOneWithoutApplicantsInput;
  regTimes?: Int;
  maxRegTimes?: Int;
  families?: FamilyUpdateManyWithoutFromInput;
  studies?: SchoolEduUpdateManyWithoutStudentsInput;
  works?: WorkUpdateManyWithoutWorkerInput;
  exam?: CollegeEntranceExamUpdateOneWithoutStudentInput;
  sentMessages?: MessageUpdateManyWithoutFromInput;
  receiveMessages?: MessageUpdateManyWithoutToInput;
  groupMessages?: GroupMessageUpdateManyWithoutFromInput;
  groups?: GroupUpdateManyWithoutUsersInput;
  friends?: UserUpdateManyInput;
  familyGroup?: FamilyGroupUpdateOneWithoutUsersInput;
  creater?: FamilyGroupUpdateOneWithoutCreaterInput;
  classMate?: ClassMateUpdateManyWithoutStudentInput;
  workGroup?: WorkGroupUpdateOneInput;
  colleagues?: ColleagueUpdateManyWithoutWorkerInput;
  fromOldColleagues?: OldColleagueUpdateManyWithoutFromInput;
  locationGroups?: LocationGroupUpdateManyWithoutUsersInput;
  forgetPassword?: FindPassWordUpdateOneWithoutForgetterInput;
  remmemberPassword?: FindPassWordUpdateManyWithoutRemmemberInput;
  loveSetting?: LoveSettingUpdateOneWithoutUserInput;
  loveWoman?: LoveMatchingUpdateManyWithoutWomanInput;
  loveMan?: LoveMatchingUpdateManyWithoutManInput;
  signUpLove?: LoveSignUpUpdateOneWithoutPersonInput;
  skills?: SkillUpdateManyWithoutPersonsInput;
  fitConditions?: PartnerConditionUpdateManyWithoutPartnersInput;
  nofitConditions?: PartnerConditionUpdateManyWithoutPassedPartnersInput;
  projects?: ProjectUpdateManyWithoutStarterInput;
  trades?: TradeUpdateManyWithoutUserInput;
}

export interface ColleagueWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  worker?: UserWhereInput;
  status?: String;
  status_not?: String;
  status_in?: String[] | String;
  status_not_in?: String[] | String;
  status_lt?: String;
  status_lte?: String;
  status_gt?: String;
  status_gte?: String;
  status_contains?: String;
  status_not_contains?: String;
  status_starts_with?: String;
  status_not_starts_with?: String;
  status_ends_with?: String;
  status_not_ends_with?: String;
  group?: WorkGroupWhereInput;
  AND?: ColleagueWhereInput[] | ColleagueWhereInput;
  OR?: ColleagueWhereInput[] | ColleagueWhereInput;
  NOT?: ColleagueWhereInput[] | ColleagueWhereInput;
}

export interface LocationGroupUpdateManyWithoutUsersInput {
  create?:
    | LocationGroupCreateWithoutUsersInput[]
    | LocationGroupCreateWithoutUsersInput;
  delete?: LocationGroupWhereUniqueInput[] | LocationGroupWhereUniqueInput;
  connect?: LocationGroupWhereUniqueInput[] | LocationGroupWhereUniqueInput;
  disconnect?: LocationGroupWhereUniqueInput[] | LocationGroupWhereUniqueInput;
  update?:
    | LocationGroupUpdateWithWhereUniqueWithoutUsersInput[]
    | LocationGroupUpdateWithWhereUniqueWithoutUsersInput;
  upsert?:
    | LocationGroupUpsertWithWhereUniqueWithoutUsersInput[]
    | LocationGroupUpsertWithWhereUniqueWithoutUsersInput;
  deleteMany?: LocationGroupScalarWhereInput[] | LocationGroupScalarWhereInput;
  updateMany?:
    | LocationGroupUpdateManyWithWhereNestedInput[]
    | LocationGroupUpdateManyWithWhereNestedInput;
}

export interface OldColleagueSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: OldColleagueWhereInput;
  AND?:
    | OldColleagueSubscriptionWhereInput[]
    | OldColleagueSubscriptionWhereInput;
  OR?:
    | OldColleagueSubscriptionWhereInput[]
    | OldColleagueSubscriptionWhereInput;
  NOT?:
    | OldColleagueSubscriptionWhereInput[]
    | OldColleagueSubscriptionWhereInput;
}

export interface LocationGroupUpdateWithWhereUniqueWithoutUsersInput {
  where: LocationGroupWhereUniqueInput;
  data: LocationGroupUpdateWithoutUsersDataInput;
}

export interface MajorSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: MajorWhereInput;
  AND?: MajorSubscriptionWhereInput[] | MajorSubscriptionWhereInput;
  OR?: MajorSubscriptionWhereInput[] | MajorSubscriptionWhereInput;
  NOT?: MajorSubscriptionWhereInput[] | MajorSubscriptionWhereInput;
}

export interface LocationGroupUpdateWithoutUsersDataInput {
  kind?: LocationGroupKind;
  code?: String;
  name?: String;
}

export interface SchoolWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  kind?: Educationkind;
  kind_not?: Educationkind;
  kind_in?: Educationkind[] | Educationkind;
  kind_not_in?: Educationkind[] | Educationkind;
  location?: LocationWhereInput;
  AND?: SchoolWhereInput[] | SchoolWhereInput;
  OR?: SchoolWhereInput[] | SchoolWhereInput;
  NOT?: SchoolWhereInput[] | SchoolWhereInput;
}

export interface LocationGroupUpsertWithWhereUniqueWithoutUsersInput {
  where: LocationGroupWhereUniqueInput;
  update: LocationGroupUpdateWithoutUsersDataInput;
  create: LocationGroupCreateWithoutUsersInput;
}

export interface LocationGroupSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: LocationGroupWhereInput;
  AND?:
    | LocationGroupSubscriptionWhereInput[]
    | LocationGroupSubscriptionWhereInput;
  OR?:
    | LocationGroupSubscriptionWhereInput[]
    | LocationGroupSubscriptionWhereInput;
  NOT?:
    | LocationGroupSubscriptionWhereInput[]
    | LocationGroupSubscriptionWhereInput;
}

export interface LocationGroupScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  kind?: LocationGroupKind;
  kind_not?: LocationGroupKind;
  kind_in?: LocationGroupKind[] | LocationGroupKind;
  kind_not_in?: LocationGroupKind[] | LocationGroupKind;
  code?: String;
  code_not?: String;
  code_in?: String[] | String;
  code_not_in?: String[] | String;
  code_lt?: String;
  code_lte?: String;
  code_gt?: String;
  code_gte?: String;
  code_contains?: String;
  code_not_contains?: String;
  code_starts_with?: String;
  code_not_starts_with?: String;
  code_ends_with?: String;
  code_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: LocationGroupScalarWhereInput[] | LocationGroupScalarWhereInput;
  OR?: LocationGroupScalarWhereInput[] | LocationGroupScalarWhereInput;
  NOT?: LocationGroupScalarWhereInput[] | LocationGroupScalarWhereInput;
}

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  username?: String;
  username_not?: String;
  username_in?: String[] | String;
  username_not_in?: String[] | String;
  username_lt?: String;
  username_lte?: String;
  username_gt?: String;
  username_gte?: String;
  username_contains?: String;
  username_not_contains?: String;
  username_starts_with?: String;
  username_not_starts_with?: String;
  username_ends_with?: String;
  username_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  gender?: String;
  gender_not?: String;
  gender_in?: String[] | String;
  gender_not_in?: String[] | String;
  gender_lt?: String;
  gender_lte?: String;
  gender_gt?: String;
  gender_gte?: String;
  gender_contains?: String;
  gender_not_contains?: String;
  gender_starts_with?: String;
  gender_not_starts_with?: String;
  gender_ends_with?: String;
  gender_not_ends_with?: String;
  avatar?: PhotoWhereInput;
  birthdaycalendar?: String;
  birthdaycalendar_not?: String;
  birthdaycalendar_in?: String[] | String;
  birthdaycalendar_not_in?: String[] | String;
  birthdaycalendar_lt?: String;
  birthdaycalendar_lte?: String;
  birthdaycalendar_gt?: String;
  birthdaycalendar_gte?: String;
  birthdaycalendar_contains?: String;
  birthdaycalendar_not_contains?: String;
  birthdaycalendar_starts_with?: String;
  birthdaycalendar_not_starts_with?: String;
  birthdaycalendar_ends_with?: String;
  birthdaycalendar_not_ends_with?: String;
  birthday?: DateTimeInput;
  birthday_not?: DateTimeInput;
  birthday_in?: DateTimeInput[] | DateTimeInput;
  birthday_not_in?: DateTimeInput[] | DateTimeInput;
  birthday_lt?: DateTimeInput;
  birthday_lte?: DateTimeInput;
  birthday_gt?: DateTimeInput;
  birthday_gte?: DateTimeInput;
  birthplace?: LocationWhereInput;
  residence?: LocationWhereInput;
  uid?: String;
  uid_not?: String;
  uid_in?: String[] | String;
  uid_not_in?: String[] | String;
  uid_lt?: String;
  uid_lte?: String;
  uid_gt?: String;
  uid_gte?: String;
  uid_contains?: String;
  uid_not_contains?: String;
  uid_starts_with?: String;
  uid_not_starts_with?: String;
  uid_ends_with?: String;
  uid_not_ends_with?: String;
  token?: String;
  token_not?: String;
  token_in?: String[] | String;
  token_not_in?: String[] | String;
  token_lt?: String;
  token_lte?: String;
  token_gt?: String;
  token_gte?: String;
  token_contains?: String;
  token_not_contains?: String;
  token_starts_with?: String;
  token_not_starts_with?: String;
  token_ends_with?: String;
  token_not_ends_with?: String;
  posts_every?: PostWhereInput;
  posts_some?: PostWhereInput;
  posts_none?: PostWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  regStatus?: RegStatusWhereInput;
  regTimes?: Int;
  regTimes_not?: Int;
  regTimes_in?: Int[] | Int;
  regTimes_not_in?: Int[] | Int;
  regTimes_lt?: Int;
  regTimes_lte?: Int;
  regTimes_gt?: Int;
  regTimes_gte?: Int;
  maxRegTimes?: Int;
  maxRegTimes_not?: Int;
  maxRegTimes_in?: Int[] | Int;
  maxRegTimes_not_in?: Int[] | Int;
  maxRegTimes_lt?: Int;
  maxRegTimes_lte?: Int;
  maxRegTimes_gt?: Int;
  maxRegTimes_gte?: Int;
  families_every?: FamilyWhereInput;
  families_some?: FamilyWhereInput;
  families_none?: FamilyWhereInput;
  studies_every?: SchoolEduWhereInput;
  studies_some?: SchoolEduWhereInput;
  studies_none?: SchoolEduWhereInput;
  works_every?: WorkWhereInput;
  works_some?: WorkWhereInput;
  works_none?: WorkWhereInput;
  exam?: CollegeEntranceExamWhereInput;
  sentMessages_every?: MessageWhereInput;
  sentMessages_some?: MessageWhereInput;
  sentMessages_none?: MessageWhereInput;
  receiveMessages_every?: MessageWhereInput;
  receiveMessages_some?: MessageWhereInput;
  receiveMessages_none?: MessageWhereInput;
  groupMessages_every?: GroupMessageWhereInput;
  groupMessages_some?: GroupMessageWhereInput;
  groupMessages_none?: GroupMessageWhereInput;
  groups_every?: GroupWhereInput;
  groups_some?: GroupWhereInput;
  groups_none?: GroupWhereInput;
  friends_every?: UserWhereInput;
  friends_some?: UserWhereInput;
  friends_none?: UserWhereInput;
  familyGroup?: FamilyGroupWhereInput;
  creater?: FamilyGroupWhereInput;
  classMate_every?: ClassMateWhereInput;
  classMate_some?: ClassMateWhereInput;
  classMate_none?: ClassMateWhereInput;
  workGroup?: WorkGroupWhereInput;
  colleagues_every?: ColleagueWhereInput;
  colleagues_some?: ColleagueWhereInput;
  colleagues_none?: ColleagueWhereInput;
  fromOldColleagues_every?: OldColleagueWhereInput;
  fromOldColleagues_some?: OldColleagueWhereInput;
  fromOldColleagues_none?: OldColleagueWhereInput;
  toOldColleagues_every?: OldColleagueWhereInput;
  toOldColleagues_some?: OldColleagueWhereInput;
  toOldColleagues_none?: OldColleagueWhereInput;
  locationGroups_every?: LocationGroupWhereInput;
  locationGroups_some?: LocationGroupWhereInput;
  locationGroups_none?: LocationGroupWhereInput;
  forgetPassword?: FindPassWordWhereInput;
  remmemberPassword_every?: FindPassWordWhereInput;
  remmemberPassword_some?: FindPassWordWhereInput;
  remmemberPassword_none?: FindPassWordWhereInput;
  loveSetting?: LoveSettingWhereInput;
  loveWoman_every?: LoveMatchingWhereInput;
  loveWoman_some?: LoveMatchingWhereInput;
  loveWoman_none?: LoveMatchingWhereInput;
  loveMan_every?: LoveMatchingWhereInput;
  loveMan_some?: LoveMatchingWhereInput;
  loveMan_none?: LoveMatchingWhereInput;
  signUpLove?: LoveSignUpWhereInput;
  skills_every?: SkillWhereInput;
  skills_some?: SkillWhereInput;
  skills_none?: SkillWhereInput;
  fitConditions_every?: PartnerConditionWhereInput;
  fitConditions_some?: PartnerConditionWhereInput;
  fitConditions_none?: PartnerConditionWhereInput;
  nofitConditions_every?: PartnerConditionWhereInput;
  nofitConditions_some?: PartnerConditionWhereInput;
  nofitConditions_none?: PartnerConditionWhereInput;
  projects_every?: ProjectWhereInput;
  projects_some?: ProjectWhereInput;
  projects_none?: ProjectWhereInput;
  trades_every?: TradeWhereInput;
  trades_some?: TradeWhereInput;
  trades_none?: TradeWhereInput;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface LocationGroupUpdateManyWithWhereNestedInput {
  where: LocationGroupScalarWhereInput;
  data: LocationGroupUpdateManyDataInput;
}

export interface FeeSettingSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: FeeSettingWhereInput;
  AND?: FeeSettingSubscriptionWhereInput[] | FeeSettingSubscriptionWhereInput;
  OR?: FeeSettingSubscriptionWhereInput[] | FeeSettingSubscriptionWhereInput;
  NOT?: FeeSettingSubscriptionWhereInput[] | FeeSettingSubscriptionWhereInput;
}

export interface LocationGroupUpdateManyDataInput {
  kind?: LocationGroupKind;
  code?: String;
  name?: String;
}

export interface CompanySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CompanyWhereInput;
  AND?: CompanySubscriptionWhereInput[] | CompanySubscriptionWhereInput;
  OR?: CompanySubscriptionWhereInput[] | CompanySubscriptionWhereInput;
  NOT?: CompanySubscriptionWhereInput[] | CompanySubscriptionWhereInput;
}

export interface FindPassWordUpdateOneWithoutForgetterInput {
  create?: FindPassWordCreateWithoutForgetterInput;
  update?: FindPassWordUpdateWithoutForgetterDataInput;
  upsert?: FindPassWordUpsertWithoutForgetterInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: FindPassWordWhereUniqueInput;
}

export interface ColleagueSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ColleagueWhereInput;
  AND?: ColleagueSubscriptionWhereInput[] | ColleagueSubscriptionWhereInput;
  OR?: ColleagueSubscriptionWhereInput[] | ColleagueSubscriptionWhereInput;
  NOT?: ColleagueSubscriptionWhereInput[] | ColleagueSubscriptionWhereInput;
}

export interface FindPassWordUpdateWithoutForgetterDataInput {
  times?: Int;
  remmember?: UserUpdateManyWithoutRemmemberPasswordInput;
}

export interface CitySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CityWhereInput;
  AND?: CitySubscriptionWhereInput[] | CitySubscriptionWhereInput;
  OR?: CitySubscriptionWhereInput[] | CitySubscriptionWhereInput;
  NOT?: CitySubscriptionWhereInput[] | CitySubscriptionWhereInput;
}

export interface UserUpdateManyWithoutRemmemberPasswordInput {
  create?:
    | UserCreateWithoutRemmemberPasswordInput[]
    | UserCreateWithoutRemmemberPasswordInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueWithoutRemmemberPasswordInput[]
    | UserUpdateWithWhereUniqueWithoutRemmemberPasswordInput;
  upsert?:
    | UserUpsertWithWhereUniqueWithoutRemmemberPasswordInput[]
    | UserUpsertWithWhereUniqueWithoutRemmemberPasswordInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export interface AreaSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AreaWhereInput;
  AND?: AreaSubscriptionWhereInput[] | AreaSubscriptionWhereInput;
  OR?: AreaSubscriptionWhereInput[] | AreaSubscriptionWhereInput;
  NOT?: AreaSubscriptionWhereInput[] | AreaSubscriptionWhereInput;
}

export interface UserUpdateWithWhereUniqueWithoutRemmemberPasswordInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutRemmemberPasswordDataInput;
}

export interface WorkUpdateManyMutationInput {
  startTime?: DateTimeInput;
  endTime?: DateTimeInput;
  department?: String;
  jobContent?: String;
}

export interface UserUpdateWithoutRemmemberPasswordDataInput {
  username?: String;
  password?: String;
  name?: String;
  gender?: String;
  avatar?: PhotoUpdateOneWithoutUserInput;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationUpdateOneWithoutBornsInput;
  residence?: LocationUpdateOneWithoutLivesInput;
  uid?: String;
  token?: String;
  posts?: PostUpdateManyWithoutAuthorInput;
  regStatus?: RegStatusUpdateOneWithoutApplicantsInput;
  regTimes?: Int;
  maxRegTimes?: Int;
  families?: FamilyUpdateManyWithoutFromInput;
  studies?: SchoolEduUpdateManyWithoutStudentsInput;
  works?: WorkUpdateManyWithoutWorkerInput;
  exam?: CollegeEntranceExamUpdateOneWithoutStudentInput;
  sentMessages?: MessageUpdateManyWithoutFromInput;
  receiveMessages?: MessageUpdateManyWithoutToInput;
  groupMessages?: GroupMessageUpdateManyWithoutFromInput;
  groups?: GroupUpdateManyWithoutUsersInput;
  friends?: UserUpdateManyInput;
  familyGroup?: FamilyGroupUpdateOneWithoutUsersInput;
  creater?: FamilyGroupUpdateOneWithoutCreaterInput;
  classMate?: ClassMateUpdateManyWithoutStudentInput;
  workGroup?: WorkGroupUpdateOneInput;
  colleagues?: ColleagueUpdateManyWithoutWorkerInput;
  fromOldColleagues?: OldColleagueUpdateManyWithoutFromInput;
  toOldColleagues?: OldColleagueUpdateManyWithoutToInput;
  locationGroups?: LocationGroupUpdateManyWithoutUsersInput;
  forgetPassword?: FindPassWordUpdateOneWithoutForgetterInput;
  loveSetting?: LoveSettingUpdateOneWithoutUserInput;
  loveWoman?: LoveMatchingUpdateManyWithoutWomanInput;
  loveMan?: LoveMatchingUpdateManyWithoutManInput;
  signUpLove?: LoveSignUpUpdateOneWithoutPersonInput;
  skills?: SkillUpdateManyWithoutPersonsInput;
  fitConditions?: PartnerConditionUpdateManyWithoutPartnersInput;
  nofitConditions?: PartnerConditionUpdateManyWithoutPassedPartnersInput;
  projects?: ProjectUpdateManyWithoutStarterInput;
  trades?: TradeUpdateManyWithoutUserInput;
}

export interface VillageUpdateManyMutationInput {
  code?: String;
  name?: String;
}

export interface OldColleagueUpdateManyWithoutToInput {
  create?:
    | OldColleagueCreateWithoutToInput[]
    | OldColleagueCreateWithoutToInput;
  delete?: OldColleagueWhereUniqueInput[] | OldColleagueWhereUniqueInput;
  connect?: OldColleagueWhereUniqueInput[] | OldColleagueWhereUniqueInput;
  disconnect?: OldColleagueWhereUniqueInput[] | OldColleagueWhereUniqueInput;
  update?:
    | OldColleagueUpdateWithWhereUniqueWithoutToInput[]
    | OldColleagueUpdateWithWhereUniqueWithoutToInput;
  upsert?:
    | OldColleagueUpsertWithWhereUniqueWithoutToInput[]
    | OldColleagueUpsertWithWhereUniqueWithoutToInput;
  deleteMany?: OldColleagueScalarWhereInput[] | OldColleagueScalarWhereInput;
  updateMany?:
    | OldColleagueUpdateManyWithWhereNestedInput[]
    | OldColleagueUpdateManyWithWhereNestedInput;
}

export interface ProvinceWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  code?: String;
  code_not?: String;
  code_in?: String[] | String;
  code_not_in?: String[] | String;
  code_lt?: String;
  code_lte?: String;
  code_gt?: String;
  code_gte?: String;
  code_contains?: String;
  code_not_contains?: String;
  code_starts_with?: String;
  code_not_starts_with?: String;
  code_ends_with?: String;
  code_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  cities_every?: CityWhereInput;
  cities_some?: CityWhereInput;
  cities_none?: CityWhereInput;
  AND?: ProvinceWhereInput[] | ProvinceWhereInput;
  OR?: ProvinceWhereInput[] | ProvinceWhereInput;
  NOT?: ProvinceWhereInput[] | ProvinceWhereInput;
}

export interface OldColleagueUpdateWithWhereUniqueWithoutToInput {
  where: OldColleagueWhereUniqueInput;
  data: OldColleagueUpdateWithoutToDataInput;
}

export type CompanyWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  name?: String;
}>;

export interface OldColleagueUpdateWithoutToDataInput {
  from?: UserUpdateOneWithoutFromOldColleaguesInput;
  company?: CompanyUpdateOneInput;
  status?: String;
}

export type FamilyWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface UserUpdateOneWithoutFromOldColleaguesInput {
  create?: UserCreateWithoutFromOldColleaguesInput;
  update?: UserUpdateWithoutFromOldColleaguesDataInput;
  upsert?: UserUpsertWithoutFromOldColleaguesInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: UserWhereUniqueInput;
}

export type FamilyGroupWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface UserUpdateWithoutFromOldColleaguesDataInput {
  username?: String;
  password?: String;
  name?: String;
  gender?: String;
  avatar?: PhotoUpdateOneWithoutUserInput;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationUpdateOneWithoutBornsInput;
  residence?: LocationUpdateOneWithoutLivesInput;
  uid?: String;
  token?: String;
  posts?: PostUpdateManyWithoutAuthorInput;
  regStatus?: RegStatusUpdateOneWithoutApplicantsInput;
  regTimes?: Int;
  maxRegTimes?: Int;
  families?: FamilyUpdateManyWithoutFromInput;
  studies?: SchoolEduUpdateManyWithoutStudentsInput;
  works?: WorkUpdateManyWithoutWorkerInput;
  exam?: CollegeEntranceExamUpdateOneWithoutStudentInput;
  sentMessages?: MessageUpdateManyWithoutFromInput;
  receiveMessages?: MessageUpdateManyWithoutToInput;
  groupMessages?: GroupMessageUpdateManyWithoutFromInput;
  groups?: GroupUpdateManyWithoutUsersInput;
  friends?: UserUpdateManyInput;
  familyGroup?: FamilyGroupUpdateOneWithoutUsersInput;
  creater?: FamilyGroupUpdateOneWithoutCreaterInput;
  classMate?: ClassMateUpdateManyWithoutStudentInput;
  workGroup?: WorkGroupUpdateOneInput;
  colleagues?: ColleagueUpdateManyWithoutWorkerInput;
  toOldColleagues?: OldColleagueUpdateManyWithoutToInput;
  locationGroups?: LocationGroupUpdateManyWithoutUsersInput;
  forgetPassword?: FindPassWordUpdateOneWithoutForgetterInput;
  remmemberPassword?: FindPassWordUpdateManyWithoutRemmemberInput;
  loveSetting?: LoveSettingUpdateOneWithoutUserInput;
  loveWoman?: LoveMatchingUpdateManyWithoutWomanInput;
  loveMan?: LoveMatchingUpdateManyWithoutManInput;
  signUpLove?: LoveSignUpUpdateOneWithoutPersonInput;
  skills?: SkillUpdateManyWithoutPersonsInput;
  fitConditions?: PartnerConditionUpdateManyWithoutPartnersInput;
  nofitConditions?: PartnerConditionUpdateManyWithoutPassedPartnersInput;
  projects?: ProjectUpdateManyWithoutStarterInput;
  trades?: TradeUpdateManyWithoutUserInput;
}

export type FeeSettingWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface FindPassWordUpdateManyWithoutRemmemberInput {
  create?:
    | FindPassWordCreateWithoutRemmemberInput[]
    | FindPassWordCreateWithoutRemmemberInput;
  delete?: FindPassWordWhereUniqueInput[] | FindPassWordWhereUniqueInput;
  connect?: FindPassWordWhereUniqueInput[] | FindPassWordWhereUniqueInput;
  disconnect?: FindPassWordWhereUniqueInput[] | FindPassWordWhereUniqueInput;
  update?:
    | FindPassWordUpdateWithWhereUniqueWithoutRemmemberInput[]
    | FindPassWordUpdateWithWhereUniqueWithoutRemmemberInput;
  upsert?:
    | FindPassWordUpsertWithWhereUniqueWithoutRemmemberInput[]
    | FindPassWordUpsertWithWhereUniqueWithoutRemmemberInput;
  deleteMany?: FindPassWordScalarWhereInput[] | FindPassWordScalarWhereInput;
  updateMany?:
    | FindPassWordUpdateManyWithWhereNestedInput[]
    | FindPassWordUpdateManyWithWhereNestedInput;
}

export interface StationUpdateManyMutationInput {
  code?: String;
  name?: String;
}

export interface FindPassWordUpdateWithWhereUniqueWithoutRemmemberInput {
  where: FindPassWordWhereUniqueInput;
  data: FindPassWordUpdateWithoutRemmemberDataInput;
}

export interface UserUpsertWithWhereUniqueWithoutSkillsInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutSkillsDataInput;
  create: UserCreateWithoutSkillsInput;
}

export interface FindPassWordUpdateWithoutRemmemberDataInput {
  times?: Int;
  forgetter?: UserUpdateOneWithoutForgetPasswordInput;
}

export interface UserUpdateManyWithoutSkillsInput {
  create?: UserCreateWithoutSkillsInput[] | UserCreateWithoutSkillsInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueWithoutSkillsInput[]
    | UserUpdateWithWhereUniqueWithoutSkillsInput;
  upsert?:
    | UserUpsertWithWhereUniqueWithoutSkillsInput[]
    | UserUpsertWithWhereUniqueWithoutSkillsInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export interface UserUpdateOneWithoutForgetPasswordInput {
  create?: UserCreateWithoutForgetPasswordInput;
  update?: UserUpdateWithoutForgetPasswordDataInput;
  upsert?: UserUpsertWithoutForgetPasswordInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateManyWithoutSkillsInput {
  create?: UserCreateWithoutSkillsInput[] | UserCreateWithoutSkillsInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface UserUpdateWithoutForgetPasswordDataInput {
  username?: String;
  password?: String;
  name?: String;
  gender?: String;
  avatar?: PhotoUpdateOneWithoutUserInput;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationUpdateOneWithoutBornsInput;
  residence?: LocationUpdateOneWithoutLivesInput;
  uid?: String;
  token?: String;
  posts?: PostUpdateManyWithoutAuthorInput;
  regStatus?: RegStatusUpdateOneWithoutApplicantsInput;
  regTimes?: Int;
  maxRegTimes?: Int;
  families?: FamilyUpdateManyWithoutFromInput;
  studies?: SchoolEduUpdateManyWithoutStudentsInput;
  works?: WorkUpdateManyWithoutWorkerInput;
  exam?: CollegeEntranceExamUpdateOneWithoutStudentInput;
  sentMessages?: MessageUpdateManyWithoutFromInput;
  receiveMessages?: MessageUpdateManyWithoutToInput;
  groupMessages?: GroupMessageUpdateManyWithoutFromInput;
  groups?: GroupUpdateManyWithoutUsersInput;
  friends?: UserUpdateManyInput;
  familyGroup?: FamilyGroupUpdateOneWithoutUsersInput;
  creater?: FamilyGroupUpdateOneWithoutCreaterInput;
  classMate?: ClassMateUpdateManyWithoutStudentInput;
  workGroup?: WorkGroupUpdateOneInput;
  colleagues?: ColleagueUpdateManyWithoutWorkerInput;
  fromOldColleagues?: OldColleagueUpdateManyWithoutFromInput;
  toOldColleagues?: OldColleagueUpdateManyWithoutToInput;
  locationGroups?: LocationGroupUpdateManyWithoutUsersInput;
  remmemberPassword?: FindPassWordUpdateManyWithoutRemmemberInput;
  loveSetting?: LoveSettingUpdateOneWithoutUserInput;
  loveWoman?: LoveMatchingUpdateManyWithoutWomanInput;
  loveMan?: LoveMatchingUpdateManyWithoutManInput;
  signUpLove?: LoveSignUpUpdateOneWithoutPersonInput;
  skills?: SkillUpdateManyWithoutPersonsInput;
  fitConditions?: PartnerConditionUpdateManyWithoutPartnersInput;
  nofitConditions?: PartnerConditionUpdateManyWithoutPassedPartnersInput;
  projects?: ProjectUpdateManyWithoutStarterInput;
  trades?: TradeUpdateManyWithoutUserInput;
}

export interface SchoolEduUpdateInput {
  school?: SchoolUpdateOneInput;
  startTime?: DateTimeInput;
  major?: MajorUpdateOneInput;
  grade?: Int;
  className?: String;
  students?: UserUpdateManyWithoutStudiesInput;
}

export interface LoveSettingUpdateOneWithoutUserInput {
  create?: LoveSettingCreateWithoutUserInput;
  update?: LoveSettingUpdateWithoutUserDataInput;
  upsert?: LoveSettingUpsertWithoutUserInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: LoveSettingWhereUniqueInput;
}

export type LocationGroupWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  code?: String;
}>;

export interface LoveSettingUpdateWithoutUserDataInput {
  myHeight?: Int;
  myWeight?: Int;
  otherHeightMin?: Int;
  otherHeightMax?: Int;
  otherWeightMin?: Int;
  otherWeightMax?: Int;
  otherAgeMin?: Int;
  otherAgeMax?: Int;
  dateTime?: String;
  datePlace?: String;
  memeberGrade?: Int;
  memeberGradeEndTime?: String;
}

export interface LogsWhereInput {
  user?: UserWhereInput;
  createFamilyGroupTime?: DateTimeInput;
  createFamilyGroupTime_not?: DateTimeInput;
  createFamilyGroupTime_in?: DateTimeInput[] | DateTimeInput;
  createFamilyGroupTime_not_in?: DateTimeInput[] | DateTimeInput;
  createFamilyGroupTime_lt?: DateTimeInput;
  createFamilyGroupTime_lte?: DateTimeInput;
  createFamilyGroupTime_gt?: DateTimeInput;
  createFamilyGroupTime_gte?: DateTimeInput;
  AND?: LogsWhereInput[] | LogsWhereInput;
  OR?: LogsWhereInput[] | LogsWhereInput;
  NOT?: LogsWhereInput[] | LogsWhereInput;
}

export interface LoveSettingUpsertWithoutUserInput {
  update: LoveSettingUpdateWithoutUserDataInput;
  create: LoveSettingCreateWithoutUserInput;
}

export interface UserUpdateManyWithoutRegStatusInput {
  create?: UserCreateWithoutRegStatusInput[] | UserCreateWithoutRegStatusInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueWithoutRegStatusInput[]
    | UserUpdateWithWhereUniqueWithoutRegStatusInput;
  upsert?:
    | UserUpsertWithWhereUniqueWithoutRegStatusInput[]
    | UserUpsertWithWhereUniqueWithoutRegStatusInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export interface LoveMatchingUpdateManyWithoutWomanInput {
  create?:
    | LoveMatchingCreateWithoutWomanInput[]
    | LoveMatchingCreateWithoutWomanInput;
  delete?: LoveMatchingWhereUniqueInput[] | LoveMatchingWhereUniqueInput;
  connect?: LoveMatchingWhereUniqueInput[] | LoveMatchingWhereUniqueInput;
  disconnect?: LoveMatchingWhereUniqueInput[] | LoveMatchingWhereUniqueInput;
  update?:
    | LoveMatchingUpdateWithWhereUniqueWithoutWomanInput[]
    | LoveMatchingUpdateWithWhereUniqueWithoutWomanInput;
  upsert?:
    | LoveMatchingUpsertWithWhereUniqueWithoutWomanInput[]
    | LoveMatchingUpsertWithWhereUniqueWithoutWomanInput;
  deleteMany?: LoveMatchingScalarWhereInput[] | LoveMatchingScalarWhereInput;
  updateMany?:
    | LoveMatchingUpdateManyWithWhereNestedInput[]
    | LoveMatchingUpdateManyWithWhereNestedInput;
}

export interface UserCreateManyWithoutRegStatusInput {
  create?: UserCreateWithoutRegStatusInput[] | UserCreateWithoutRegStatusInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface LoveMatchingUpdateWithWhereUniqueWithoutWomanInput {
  where: LoveMatchingWhereUniqueInput;
  data: LoveMatchingUpdateWithoutWomanDataInput;
}

export interface ProvinceUpdateInput {
  code?: String;
  name?: String;
  cities?: CityUpdateManyWithoutProvinceInput;
}

export interface LoveMatchingUpdateWithoutWomanDataInput {
  period?: String;
  city?: CityUpdateOneInput;
  man?: UserUpdateOneWithoutLoveManInput;
}

export type AreaWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  code?: String;
}>;

export interface UserUpdateOneWithoutLoveManInput {
  create?: UserCreateWithoutLoveManInput;
  update?: UserUpdateWithoutLoveManDataInput;
  upsert?: UserUpsertWithoutLoveManInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: UserWhereUniqueInput;
}

export type MajorWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface UserUpdateWithoutLoveManDataInput {
  username?: String;
  password?: String;
  name?: String;
  gender?: String;
  avatar?: PhotoUpdateOneWithoutUserInput;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationUpdateOneWithoutBornsInput;
  residence?: LocationUpdateOneWithoutLivesInput;
  uid?: String;
  token?: String;
  posts?: PostUpdateManyWithoutAuthorInput;
  regStatus?: RegStatusUpdateOneWithoutApplicantsInput;
  regTimes?: Int;
  maxRegTimes?: Int;
  families?: FamilyUpdateManyWithoutFromInput;
  studies?: SchoolEduUpdateManyWithoutStudentsInput;
  works?: WorkUpdateManyWithoutWorkerInput;
  exam?: CollegeEntranceExamUpdateOneWithoutStudentInput;
  sentMessages?: MessageUpdateManyWithoutFromInput;
  receiveMessages?: MessageUpdateManyWithoutToInput;
  groupMessages?: GroupMessageUpdateManyWithoutFromInput;
  groups?: GroupUpdateManyWithoutUsersInput;
  friends?: UserUpdateManyInput;
  familyGroup?: FamilyGroupUpdateOneWithoutUsersInput;
  creater?: FamilyGroupUpdateOneWithoutCreaterInput;
  classMate?: ClassMateUpdateManyWithoutStudentInput;
  workGroup?: WorkGroupUpdateOneInput;
  colleagues?: ColleagueUpdateManyWithoutWorkerInput;
  fromOldColleagues?: OldColleagueUpdateManyWithoutFromInput;
  toOldColleagues?: OldColleagueUpdateManyWithoutToInput;
  locationGroups?: LocationGroupUpdateManyWithoutUsersInput;
  forgetPassword?: FindPassWordUpdateOneWithoutForgetterInput;
  remmemberPassword?: FindPassWordUpdateManyWithoutRemmemberInput;
  loveSetting?: LoveSettingUpdateOneWithoutUserInput;
  loveWoman?: LoveMatchingUpdateManyWithoutWomanInput;
  signUpLove?: LoveSignUpUpdateOneWithoutPersonInput;
  skills?: SkillUpdateManyWithoutPersonsInput;
  fitConditions?: PartnerConditionUpdateManyWithoutPartnersInput;
  nofitConditions?: PartnerConditionUpdateManyWithoutPassedPartnersInput;
  projects?: ProjectUpdateManyWithoutStarterInput;
  trades?: TradeUpdateManyWithoutUserInput;
}

export interface UserUpdateOneRequiredWithoutPostsInput {
  create?: UserCreateWithoutPostsInput;
  update?: UserUpdateWithoutPostsDataInput;
  upsert?: UserUpsertWithoutPostsInput;
  connect?: UserWhereUniqueInput;
}

export interface LoveSignUpUpdateOneWithoutPersonInput {
  create?: LoveSignUpCreateWithoutPersonInput;
  update?: LoveSignUpUpdateWithoutPersonDataInput;
  upsert?: LoveSignUpUpsertWithoutPersonInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: LoveSignUpWhereUniqueInput;
}

export interface UserCreateOneWithoutPostsInput {
  create?: UserCreateWithoutPostsInput;
  connect?: UserWhereUniqueInput;
}

export interface LoveSignUpUpdateWithoutPersonDataInput {
  period?: String;
  city?: CityUpdateOneInput;
}

export interface PhotoUpdateInput {
  name?: String;
  url?: String;
  user?: UserUpdateOneWithoutAvatarInput;
}

export interface LoveSignUpUpsertWithoutPersonInput {
  update: LoveSignUpUpdateWithoutPersonDataInput;
  create: LoveSignUpCreateWithoutPersonInput;
}

export interface PersonCreateInput {
  name: String;
  user?: UserCreateOneInput;
  families?: FamilyCreateManyWithoutToInput;
  asFather?: FamilyGroupCreateManyWithoutFatherInput;
  asMother?: FamilyGroupCreateManyWithoutMotherInput;
}

export interface SkillUpdateManyWithoutPersonsInput {
  create?: SkillCreateWithoutPersonsInput[] | SkillCreateWithoutPersonsInput;
  delete?: SkillWhereUniqueInput[] | SkillWhereUniqueInput;
  connect?: SkillWhereUniqueInput[] | SkillWhereUniqueInput;
  disconnect?: SkillWhereUniqueInput[] | SkillWhereUniqueInput;
  update?:
    | SkillUpdateWithWhereUniqueWithoutPersonsInput[]
    | SkillUpdateWithWhereUniqueWithoutPersonsInput;
  upsert?:
    | SkillUpsertWithWhereUniqueWithoutPersonsInput[]
    | SkillUpsertWithWhereUniqueWithoutPersonsInput;
  deleteMany?: SkillScalarWhereInput[] | SkillScalarWhereInput;
  updateMany?:
    | SkillUpdateManyWithWhereNestedInput[]
    | SkillUpdateManyWithWhereNestedInput;
}

export interface PartnerConditionCreateInput {
  skillName?: String;
  place?: String;
  number?: Int;
  partners?: UserCreateManyWithoutFitConditionsInput;
  passedPartners?: UserCreateManyWithoutNofitConditionsInput;
  project?: ProjectCreateOneWithoutConditionsInput;
}

export interface SkillUpdateWithWhereUniqueWithoutPersonsInput {
  where: SkillWhereUniqueInput;
  data: SkillUpdateWithoutPersonsDataInput;
}

export interface OldColleagueCreateInput {
  from?: UserCreateOneWithoutFromOldColleaguesInput;
  to?: UserCreateOneWithoutToOldColleaguesInput;
  company?: CompanyCreateOneInput;
  status: String;
}

export interface SkillUpdateWithoutPersonsDataInput {
  name?: String;
}

export interface MajorUpdateManyMutationInput {
  name?: String;
  category?: String;
  education?: Educationkind;
}

export interface SkillUpsertWithWhereUniqueWithoutPersonsInput {
  where: SkillWhereUniqueInput;
  update: SkillUpdateWithoutPersonsDataInput;
  create: SkillCreateWithoutPersonsInput;
}

export interface UserUpsertWithoutSignUpLoveInput {
  update: UserUpdateWithoutSignUpLoveDataInput;
  create: UserCreateWithoutSignUpLoveInput;
}

export interface SkillScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: SkillScalarWhereInput[] | SkillScalarWhereInput;
  OR?: SkillScalarWhereInput[] | SkillScalarWhereInput;
  NOT?: SkillScalarWhereInput[] | SkillScalarWhereInput;
}

export type ProjectWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface SkillUpdateManyWithWhereNestedInput {
  where: SkillScalarWhereInput;
  data: SkillUpdateManyDataInput;
}

export type ProvinceWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  code?: String;
  name?: String;
}>;

export interface SkillUpdateManyDataInput {
  name?: String;
}

export interface UserUpdateOneRequiredWithoutLoveSettingInput {
  create?: UserCreateWithoutLoveSettingInput;
  update?: UserUpdateWithoutLoveSettingDataInput;
  upsert?: UserUpsertWithoutLoveSettingInput;
  connect?: UserWhereUniqueInput;
}

export interface PartnerConditionUpdateManyWithoutPartnersInput {
  create?:
    | PartnerConditionCreateWithoutPartnersInput[]
    | PartnerConditionCreateWithoutPartnersInput;
  delete?:
    | PartnerConditionWhereUniqueInput[]
    | PartnerConditionWhereUniqueInput;
  connect?:
    | PartnerConditionWhereUniqueInput[]
    | PartnerConditionWhereUniqueInput;
  disconnect?:
    | PartnerConditionWhereUniqueInput[]
    | PartnerConditionWhereUniqueInput;
  update?:
    | PartnerConditionUpdateWithWhereUniqueWithoutPartnersInput[]
    | PartnerConditionUpdateWithWhereUniqueWithoutPartnersInput;
  upsert?:
    | PartnerConditionUpsertWithWhereUniqueWithoutPartnersInput[]
    | PartnerConditionUpsertWithWhereUniqueWithoutPartnersInput;
  deleteMany?:
    | PartnerConditionScalarWhereInput[]
    | PartnerConditionScalarWhereInput;
  updateMany?:
    | PartnerConditionUpdateManyWithWhereNestedInput[]
    | PartnerConditionUpdateManyWithWhereNestedInput;
}

export interface UserCreateOneWithoutLoveSettingInput {
  create?: UserCreateWithoutLoveSettingInput;
  connect?: UserWhereUniqueInput;
}

export interface PartnerConditionUpdateWithWhereUniqueWithoutPartnersInput {
  where: PartnerConditionWhereUniqueInput;
  data: PartnerConditionUpdateWithoutPartnersDataInput;
}

export interface RegisterCountWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  addUser?: UserWhereInput;
  deviceId?: String;
  deviceId_not?: String;
  deviceId_in?: String[] | String;
  deviceId_not_in?: String[] | String;
  deviceId_lt?: String;
  deviceId_lte?: String;
  deviceId_gt?: String;
  deviceId_gte?: String;
  deviceId_contains?: String;
  deviceId_not_contains?: String;
  deviceId_starts_with?: String;
  deviceId_not_starts_with?: String;
  deviceId_ends_with?: String;
  deviceId_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  AND?: RegisterCountWhereInput[] | RegisterCountWhereInput;
  OR?: RegisterCountWhereInput[] | RegisterCountWhereInput;
  NOT?: RegisterCountWhereInput[] | RegisterCountWhereInput;
}

export interface PartnerConditionUpdateWithoutPartnersDataInput {
  skillName?: String;
  place?: String;
  number?: Int;
  passedPartners?: UserUpdateManyWithoutNofitConditionsInput;
  project?: ProjectUpdateOneWithoutConditionsInput;
}

export interface LogsUpdateManyMutationInput {
  createFamilyGroupTime?: DateTimeInput;
}

export interface UserUpdateManyWithoutNofitConditionsInput {
  create?:
    | UserCreateWithoutNofitConditionsInput[]
    | UserCreateWithoutNofitConditionsInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueWithoutNofitConditionsInput[]
    | UserUpdateWithWhereUniqueWithoutNofitConditionsInput;
  upsert?:
    | UserUpsertWithWhereUniqueWithoutNofitConditionsInput[]
    | UserUpsertWithWhereUniqueWithoutNofitConditionsInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export interface UserUpsertWithWhereUniqueWithoutLocationGroupsInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutLocationGroupsDataInput;
  create: UserCreateWithoutLocationGroupsInput;
}

export interface UserUpdateWithWhereUniqueWithoutNofitConditionsInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutNofitConditionsDataInput;
}

export interface UserUpdateManyWithoutLocationGroupsInput {
  create?:
    | UserCreateWithoutLocationGroupsInput[]
    | UserCreateWithoutLocationGroupsInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueWithoutLocationGroupsInput[]
    | UserUpdateWithWhereUniqueWithoutLocationGroupsInput;
  upsert?:
    | UserUpsertWithWhereUniqueWithoutLocationGroupsInput[]
    | UserUpsertWithWhereUniqueWithoutLocationGroupsInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export interface UserUpdateWithoutNofitConditionsDataInput {
  username?: String;
  password?: String;
  name?: String;
  gender?: String;
  avatar?: PhotoUpdateOneWithoutUserInput;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationUpdateOneWithoutBornsInput;
  residence?: LocationUpdateOneWithoutLivesInput;
  uid?: String;
  token?: String;
  posts?: PostUpdateManyWithoutAuthorInput;
  regStatus?: RegStatusUpdateOneWithoutApplicantsInput;
  regTimes?: Int;
  maxRegTimes?: Int;
  families?: FamilyUpdateManyWithoutFromInput;
  studies?: SchoolEduUpdateManyWithoutStudentsInput;
  works?: WorkUpdateManyWithoutWorkerInput;
  exam?: CollegeEntranceExamUpdateOneWithoutStudentInput;
  sentMessages?: MessageUpdateManyWithoutFromInput;
  receiveMessages?: MessageUpdateManyWithoutToInput;
  groupMessages?: GroupMessageUpdateManyWithoutFromInput;
  groups?: GroupUpdateManyWithoutUsersInput;
  friends?: UserUpdateManyInput;
  familyGroup?: FamilyGroupUpdateOneWithoutUsersInput;
  creater?: FamilyGroupUpdateOneWithoutCreaterInput;
  classMate?: ClassMateUpdateManyWithoutStudentInput;
  workGroup?: WorkGroupUpdateOneInput;
  colleagues?: ColleagueUpdateManyWithoutWorkerInput;
  fromOldColleagues?: OldColleagueUpdateManyWithoutFromInput;
  toOldColleagues?: OldColleagueUpdateManyWithoutToInput;
  locationGroups?: LocationGroupUpdateManyWithoutUsersInput;
  forgetPassword?: FindPassWordUpdateOneWithoutForgetterInput;
  remmemberPassword?: FindPassWordUpdateManyWithoutRemmemberInput;
  loveSetting?: LoveSettingUpdateOneWithoutUserInput;
  loveWoman?: LoveMatchingUpdateManyWithoutWomanInput;
  loveMan?: LoveMatchingUpdateManyWithoutManInput;
  signUpLove?: LoveSignUpUpdateOneWithoutPersonInput;
  skills?: SkillUpdateManyWithoutPersonsInput;
  fitConditions?: PartnerConditionUpdateManyWithoutPartnersInput;
  projects?: ProjectUpdateManyWithoutStarterInput;
  trades?: TradeUpdateManyWithoutUserInput;
}

export interface UserCreateManyWithoutLocationGroupsInput {
  create?:
    | UserCreateWithoutLocationGroupsInput[]
    | UserCreateWithoutLocationGroupsInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface LoveMatchingUpdateManyWithoutManInput {
  create?:
    | LoveMatchingCreateWithoutManInput[]
    | LoveMatchingCreateWithoutManInput;
  delete?: LoveMatchingWhereUniqueInput[] | LoveMatchingWhereUniqueInput;
  connect?: LoveMatchingWhereUniqueInput[] | LoveMatchingWhereUniqueInput;
  disconnect?: LoveMatchingWhereUniqueInput[] | LoveMatchingWhereUniqueInput;
  update?:
    | LoveMatchingUpdateWithWhereUniqueWithoutManInput[]
    | LoveMatchingUpdateWithWhereUniqueWithoutManInput;
  upsert?:
    | LoveMatchingUpsertWithWhereUniqueWithoutManInput[]
    | LoveMatchingUpsertWithWhereUniqueWithoutManInput;
  deleteMany?: LoveMatchingScalarWhereInput[] | LoveMatchingScalarWhereInput;
  updateMany?:
    | LoveMatchingUpdateManyWithWhereNestedInput[]
    | LoveMatchingUpdateManyWithWhereNestedInput;
}

export interface LocationUpdateInput {
  name?: String;
  province?: ProvinceUpdateOneInput;
  city?: CityUpdateOneInput;
  area?: AreaUpdateOneInput;
  street?: StreetUpdateOneInput;
  village?: VillageUpdateOneInput;
  schools?: SchoolUpdateManyWithoutLocationInput;
  companies?: CompanyUpdateManyWithoutLocationInput;
  universities?: UniversityUpdateManyInput;
  borns?: UserUpdateManyWithoutBirthplaceInput;
  lives?: UserUpdateManyWithoutResidenceInput;
}

export interface LoveMatchingUpdateWithWhereUniqueWithoutManInput {
  where: LoveMatchingWhereUniqueInput;
  data: LoveMatchingUpdateWithoutManDataInput;
}

export interface UserUpsertWithoutGroupMessagesInput {
  update: UserUpdateWithoutGroupMessagesDataInput;
  create: UserCreateWithoutGroupMessagesInput;
}

export interface LoveMatchingUpdateWithoutManDataInput {
  period?: String;
  city?: CityUpdateOneInput;
  woman?: UserUpdateOneWithoutLoveWomanInput;
}

export interface GroupMessageUpdateInput {
  type?: GroupKind;
  to?: String;
  from?: UserUpdateOneRequiredWithoutGroupMessagesInput;
  text?: String;
  image?: PhotoUpdateOneInput;
}

export interface UserUpdateOneWithoutLoveWomanInput {
  create?: UserCreateWithoutLoveWomanInput;
  update?: UserUpdateWithoutLoveWomanDataInput;
  upsert?: UserUpsertWithoutLoveWomanInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface GroupMessageCreateInput {
  type?: GroupKind;
  to: String;
  from: UserCreateOneWithoutGroupMessagesInput;
  text?: String;
  image?: PhotoCreateOneInput;
}

export interface UserUpdateWithoutLoveWomanDataInput {
  username?: String;
  password?: String;
  name?: String;
  gender?: String;
  avatar?: PhotoUpdateOneWithoutUserInput;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationUpdateOneWithoutBornsInput;
  residence?: LocationUpdateOneWithoutLivesInput;
  uid?: String;
  token?: String;
  posts?: PostUpdateManyWithoutAuthorInput;
  regStatus?: RegStatusUpdateOneWithoutApplicantsInput;
  regTimes?: Int;
  maxRegTimes?: Int;
  families?: FamilyUpdateManyWithoutFromInput;
  studies?: SchoolEduUpdateManyWithoutStudentsInput;
  works?: WorkUpdateManyWithoutWorkerInput;
  exam?: CollegeEntranceExamUpdateOneWithoutStudentInput;
  sentMessages?: MessageUpdateManyWithoutFromInput;
  receiveMessages?: MessageUpdateManyWithoutToInput;
  groupMessages?: GroupMessageUpdateManyWithoutFromInput;
  groups?: GroupUpdateManyWithoutUsersInput;
  friends?: UserUpdateManyInput;
  familyGroup?: FamilyGroupUpdateOneWithoutUsersInput;
  creater?: FamilyGroupUpdateOneWithoutCreaterInput;
  classMate?: ClassMateUpdateManyWithoutStudentInput;
  workGroup?: WorkGroupUpdateOneInput;
  colleagues?: ColleagueUpdateManyWithoutWorkerInput;
  fromOldColleagues?: OldColleagueUpdateManyWithoutFromInput;
  toOldColleagues?: OldColleagueUpdateManyWithoutToInput;
  locationGroups?: LocationGroupUpdateManyWithoutUsersInput;
  forgetPassword?: FindPassWordUpdateOneWithoutForgetterInput;
  remmemberPassword?: FindPassWordUpdateManyWithoutRemmemberInput;
  loveSetting?: LoveSettingUpdateOneWithoutUserInput;
  loveMan?: LoveMatchingUpdateManyWithoutManInput;
  signUpLove?: LoveSignUpUpdateOneWithoutPersonInput;
  skills?: SkillUpdateManyWithoutPersonsInput;
  fitConditions?: PartnerConditionUpdateManyWithoutPartnersInput;
  nofitConditions?: PartnerConditionUpdateManyWithoutPassedPartnersInput;
  projects?: ProjectUpdateManyWithoutStarterInput;
  trades?: TradeUpdateManyWithoutUserInput;
}

export interface UserUpdateWithoutGroupsDataInput {
  username?: String;
  password?: String;
  name?: String;
  gender?: String;
  avatar?: PhotoUpdateOneWithoutUserInput;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationUpdateOneWithoutBornsInput;
  residence?: LocationUpdateOneWithoutLivesInput;
  uid?: String;
  token?: String;
  posts?: PostUpdateManyWithoutAuthorInput;
  regStatus?: RegStatusUpdateOneWithoutApplicantsInput;
  regTimes?: Int;
  maxRegTimes?: Int;
  families?: FamilyUpdateManyWithoutFromInput;
  studies?: SchoolEduUpdateManyWithoutStudentsInput;
  works?: WorkUpdateManyWithoutWorkerInput;
  exam?: CollegeEntranceExamUpdateOneWithoutStudentInput;
  sentMessages?: MessageUpdateManyWithoutFromInput;
  receiveMessages?: MessageUpdateManyWithoutToInput;
  groupMessages?: GroupMessageUpdateManyWithoutFromInput;
  friends?: UserUpdateManyInput;
  familyGroup?: FamilyGroupUpdateOneWithoutUsersInput;
  creater?: FamilyGroupUpdateOneWithoutCreaterInput;
  classMate?: ClassMateUpdateManyWithoutStudentInput;
  workGroup?: WorkGroupUpdateOneInput;
  colleagues?: ColleagueUpdateManyWithoutWorkerInput;
  fromOldColleagues?: OldColleagueUpdateManyWithoutFromInput;
  toOldColleagues?: OldColleagueUpdateManyWithoutToInput;
  locationGroups?: LocationGroupUpdateManyWithoutUsersInput;
  forgetPassword?: FindPassWordUpdateOneWithoutForgetterInput;
  remmemberPassword?: FindPassWordUpdateManyWithoutRemmemberInput;
  loveSetting?: LoveSettingUpdateOneWithoutUserInput;
  loveWoman?: LoveMatchingUpdateManyWithoutWomanInput;
  loveMan?: LoveMatchingUpdateManyWithoutManInput;
  signUpLove?: LoveSignUpUpdateOneWithoutPersonInput;
  skills?: SkillUpdateManyWithoutPersonsInput;
  fitConditions?: PartnerConditionUpdateManyWithoutPartnersInput;
  nofitConditions?: PartnerConditionUpdateManyWithoutPassedPartnersInput;
  projects?: ProjectUpdateManyWithoutStarterInput;
  trades?: TradeUpdateManyWithoutUserInput;
}

export interface PartnerConditionUpdateManyWithoutPassedPartnersInput {
  create?:
    | PartnerConditionCreateWithoutPassedPartnersInput[]
    | PartnerConditionCreateWithoutPassedPartnersInput;
  delete?:
    | PartnerConditionWhereUniqueInput[]
    | PartnerConditionWhereUniqueInput;
  connect?:
    | PartnerConditionWhereUniqueInput[]
    | PartnerConditionWhereUniqueInput;
  disconnect?:
    | PartnerConditionWhereUniqueInput[]
    | PartnerConditionWhereUniqueInput;
  update?:
    | PartnerConditionUpdateWithWhereUniqueWithoutPassedPartnersInput[]
    | PartnerConditionUpdateWithWhereUniqueWithoutPassedPartnersInput;
  upsert?:
    | PartnerConditionUpsertWithWhereUniqueWithoutPassedPartnersInput[]
    | PartnerConditionUpsertWithWhereUniqueWithoutPassedPartnersInput;
  deleteMany?:
    | PartnerConditionScalarWhereInput[]
    | PartnerConditionScalarWhereInput;
  updateMany?:
    | PartnerConditionUpdateManyWithWhereNestedInput[]
    | PartnerConditionUpdateManyWithWhereNestedInput;
}

export interface GroupUpdateInput {
  type?: GroupKind;
  name?: String;
  users?: UserUpdateManyWithoutGroupsInput;
  messages?: MessageUpdateManyInput;
}

export interface PartnerConditionUpdateWithWhereUniqueWithoutPassedPartnersInput {
  where: PartnerConditionWhereUniqueInput;
  data: PartnerConditionUpdateWithoutPassedPartnersDataInput;
}

export interface GroupCreateInput {
  type?: GroupKind;
  name?: String;
  users?: UserCreateManyWithoutGroupsInput;
  messages?: MessageCreateManyInput;
}

export interface PartnerConditionUpdateWithoutPassedPartnersDataInput {
  skillName?: String;
  place?: String;
  number?: Int;
  partners?: UserUpdateManyWithoutFitConditionsInput;
  project?: ProjectUpdateOneWithoutConditionsInput;
}

export interface FindPassWordCreateInput {
  times?: Int;
  forgetter?: UserCreateOneWithoutForgetPasswordInput;
  remmember?: UserCreateManyWithoutRemmemberPasswordInput;
}

export interface UserUpdateManyWithoutFitConditionsInput {
  create?:
    | UserCreateWithoutFitConditionsInput[]
    | UserCreateWithoutFitConditionsInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueWithoutFitConditionsInput[]
    | UserUpdateWithWhereUniqueWithoutFitConditionsInput;
  upsert?:
    | UserUpsertWithWhereUniqueWithoutFitConditionsInput[]
    | UserUpsertWithWhereUniqueWithoutFitConditionsInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export interface AdvertisementCreateInput {
  image1?: String;
  image2?: String;
  image3?: String;
  image4?: String;
  image5?: String;
  startTime?: DateTimeInput;
  endTime?: DateTimeInput;
}

export interface UserUpdateWithWhereUniqueWithoutFitConditionsInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutFitConditionsDataInput;
}

export interface FamilyGroupUpdateManyMutationInput {
  name?: String;
}

export interface UserUpdateWithoutFitConditionsDataInput {
  username?: String;
  password?: String;
  name?: String;
  gender?: String;
  avatar?: PhotoUpdateOneWithoutUserInput;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationUpdateOneWithoutBornsInput;
  residence?: LocationUpdateOneWithoutLivesInput;
  uid?: String;
  token?: String;
  posts?: PostUpdateManyWithoutAuthorInput;
  regStatus?: RegStatusUpdateOneWithoutApplicantsInput;
  regTimes?: Int;
  maxRegTimes?: Int;
  families?: FamilyUpdateManyWithoutFromInput;
  studies?: SchoolEduUpdateManyWithoutStudentsInput;
  works?: WorkUpdateManyWithoutWorkerInput;
  exam?: CollegeEntranceExamUpdateOneWithoutStudentInput;
  sentMessages?: MessageUpdateManyWithoutFromInput;
  receiveMessages?: MessageUpdateManyWithoutToInput;
  groupMessages?: GroupMessageUpdateManyWithoutFromInput;
  groups?: GroupUpdateManyWithoutUsersInput;
  friends?: UserUpdateManyInput;
  familyGroup?: FamilyGroupUpdateOneWithoutUsersInput;
  creater?: FamilyGroupUpdateOneWithoutCreaterInput;
  classMate?: ClassMateUpdateManyWithoutStudentInput;
  workGroup?: WorkGroupUpdateOneInput;
  colleagues?: ColleagueUpdateManyWithoutWorkerInput;
  fromOldColleagues?: OldColleagueUpdateManyWithoutFromInput;
  toOldColleagues?: OldColleagueUpdateManyWithoutToInput;
  locationGroups?: LocationGroupUpdateManyWithoutUsersInput;
  forgetPassword?: FindPassWordUpdateOneWithoutForgetterInput;
  remmemberPassword?: FindPassWordUpdateManyWithoutRemmemberInput;
  loveSetting?: LoveSettingUpdateOneWithoutUserInput;
  loveWoman?: LoveMatchingUpdateManyWithoutWomanInput;
  loveMan?: LoveMatchingUpdateManyWithoutManInput;
  signUpLove?: LoveSignUpUpdateOneWithoutPersonInput;
  skills?: SkillUpdateManyWithoutPersonsInput;
  nofitConditions?: PartnerConditionUpdateManyWithoutPassedPartnersInput;
  projects?: ProjectUpdateManyWithoutStarterInput;
  trades?: TradeUpdateManyWithoutUserInput;
}

export interface ProvinceCreateOneWithoutCitiesInput {
  create?: ProvinceCreateWithoutCitiesInput;
  connect?: ProvinceWhereUniqueInput;
}

export interface ProjectUpdateManyWithoutStarterInput {
  create?:
    | ProjectCreateWithoutStarterInput[]
    | ProjectCreateWithoutStarterInput;
  delete?: ProjectWhereUniqueInput[] | ProjectWhereUniqueInput;
  connect?: ProjectWhereUniqueInput[] | ProjectWhereUniqueInput;
  disconnect?: ProjectWhereUniqueInput[] | ProjectWhereUniqueInput;
  update?:
    | ProjectUpdateWithWhereUniqueWithoutStarterInput[]
    | ProjectUpdateWithWhereUniqueWithoutStarterInput;
  upsert?:
    | ProjectUpsertWithWhereUniqueWithoutStarterInput[]
    | ProjectUpsertWithWhereUniqueWithoutStarterInput;
  deleteMany?: ProjectScalarWhereInput[] | ProjectScalarWhereInput;
  updateMany?:
    | ProjectUpdateManyWithWhereNestedInput[]
    | ProjectUpdateManyWithWhereNestedInput;
}

export interface VillageCreateManyWithoutStreetInput {
  create?: VillageCreateWithoutStreetInput[] | VillageCreateWithoutStreetInput;
  connect?: VillageWhereUniqueInput[] | VillageWhereUniqueInput;
}

export interface ProjectUpdateWithWhereUniqueWithoutStarterInput {
  where: ProjectWhereUniqueInput;
  data: ProjectUpdateWithoutStarterDataInput;
}

export interface PhotoCreateOneWithoutUserInput {
  create?: PhotoCreateWithoutUserInput;
  connect?: PhotoWhereUniqueInput;
}

export interface ProjectUpdateWithoutStarterDataInput {
  name?: String;
  place?: CityUpdateOneInput;
  content?: String;
  conditions?: PartnerConditionUpdateManyWithoutProjectInput;
}

export interface ProvinceCreateOneInput {
  create?: ProvinceCreateInput;
  connect?: ProvinceWhereUniqueInput;
}

export interface PartnerConditionUpdateManyWithoutProjectInput {
  create?:
    | PartnerConditionCreateWithoutProjectInput[]
    | PartnerConditionCreateWithoutProjectInput;
  delete?:
    | PartnerConditionWhereUniqueInput[]
    | PartnerConditionWhereUniqueInput;
  connect?:
    | PartnerConditionWhereUniqueInput[]
    | PartnerConditionWhereUniqueInput;
  disconnect?:
    | PartnerConditionWhereUniqueInput[]
    | PartnerConditionWhereUniqueInput;
  update?:
    | PartnerConditionUpdateWithWhereUniqueWithoutProjectInput[]
    | PartnerConditionUpdateWithWhereUniqueWithoutProjectInput;
  upsert?:
    | PartnerConditionUpsertWithWhereUniqueWithoutProjectInput[]
    | PartnerConditionUpsertWithWhereUniqueWithoutProjectInput;
  deleteMany?:
    | PartnerConditionScalarWhereInput[]
    | PartnerConditionScalarWhereInput;
  updateMany?:
    | PartnerConditionUpdateManyWithWhereNestedInput[]
    | PartnerConditionUpdateManyWithWhereNestedInput;
}

export interface AreaCreateManyWithoutCityInput {
  create?: AreaCreateWithoutCityInput[] | AreaCreateWithoutCityInput;
  connect?: AreaWhereUniqueInput[] | AreaWhereUniqueInput;
}

export interface PartnerConditionUpdateWithWhereUniqueWithoutProjectInput {
  where: PartnerConditionWhereUniqueInput;
  data: PartnerConditionUpdateWithoutProjectDataInput;
}

export interface AreaCreateOneInput {
  create?: AreaCreateInput;
  connect?: AreaWhereUniqueInput;
}

export interface PartnerConditionUpdateWithoutProjectDataInput {
  skillName?: String;
  place?: String;
  number?: Int;
  partners?: UserUpdateManyWithoutFitConditionsInput;
  passedPartners?: UserUpdateManyWithoutNofitConditionsInput;
}

export interface AreaCreateWithoutTownsInput {
  code: String;
  name: String;
  city: CityCreateOneWithoutAreasInput;
}

export interface PartnerConditionUpsertWithWhereUniqueWithoutProjectInput {
  where: PartnerConditionWhereUniqueInput;
  update: PartnerConditionUpdateWithoutProjectDataInput;
  create: PartnerConditionCreateWithoutProjectInput;
}

export interface StreetCreateWithoutVillagesInput {
  code: String;
  name: String;
  Area: AreaCreateOneWithoutTownsInput;
}

export interface PartnerConditionScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  skillName?: String;
  skillName_not?: String;
  skillName_in?: String[] | String;
  skillName_not_in?: String[] | String;
  skillName_lt?: String;
  skillName_lte?: String;
  skillName_gt?: String;
  skillName_gte?: String;
  skillName_contains?: String;
  skillName_not_contains?: String;
  skillName_starts_with?: String;
  skillName_not_starts_with?: String;
  skillName_ends_with?: String;
  skillName_not_ends_with?: String;
  place?: String;
  place_not?: String;
  place_in?: String[] | String;
  place_not_in?: String[] | String;
  place_lt?: String;
  place_lte?: String;
  place_gt?: String;
  place_gte?: String;
  place_contains?: String;
  place_not_contains?: String;
  place_starts_with?: String;
  place_not_starts_with?: String;
  place_ends_with?: String;
  place_not_ends_with?: String;
  number?: Int;
  number_not?: Int;
  number_in?: Int[] | Int;
  number_not_in?: Int[] | Int;
  number_lt?: Int;
  number_lte?: Int;
  number_gt?: Int;
  number_gte?: Int;
  AND?: PartnerConditionScalarWhereInput[] | PartnerConditionScalarWhereInput;
  OR?: PartnerConditionScalarWhereInput[] | PartnerConditionScalarWhereInput;
  NOT?: PartnerConditionScalarWhereInput[] | PartnerConditionScalarWhereInput;
}

export interface CompanyCreateWithoutLocationInput {
  name?: String;
  code?: String;
  establishmentDate?: DateTimeInput;
  representative?: String;
  BusinessScope?: String;
  works?: WorkCreateManyWithoutCompanyInput;
  workGroup?: WorkGroupCreateOneWithoutCompanyInput;
}

export interface PartnerConditionUpdateManyWithWhereNestedInput {
  where: PartnerConditionScalarWhereInput;
  data: PartnerConditionUpdateManyDataInput;
}

export interface StationCreateInput {
  code?: String;
  name?: String;
}

export interface PartnerConditionUpdateManyDataInput {
  skillName?: String;
  place?: String;
  number?: Int;
}

export interface LocationCreateWithoutLivesInput {
  name?: String;
  province?: ProvinceCreateOneInput;
  city?: CityCreateOneInput;
  area?: AreaCreateOneInput;
  street?: StreetCreateOneInput;
  village?: VillageCreateOneInput;
  schools?: SchoolCreateManyWithoutLocationInput;
  companies?: CompanyCreateManyWithoutLocationInput;
  universities?: UniversityCreateManyInput;
  borns?: UserCreateManyWithoutBirthplaceInput;
}

export interface ProjectUpsertWithWhereUniqueWithoutStarterInput {
  where: ProjectWhereUniqueInput;
  update: ProjectUpdateWithoutStarterDataInput;
  create: ProjectCreateWithoutStarterInput;
}

export interface UserCreateWithoutBirthplaceInput {
  username: String;
  password: String;
  name?: String;
  gender?: String;
  avatar?: PhotoCreateOneWithoutUserInput;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  residence?: LocationCreateOneWithoutLivesInput;
  uid: String;
  token: String;
  posts?: PostCreateManyWithoutAuthorInput;
  regStatus?: RegStatusCreateOneWithoutApplicantsInput;
  regTimes?: Int;
  maxRegTimes?: Int;
  families?: FamilyCreateManyWithoutFromInput;
  studies?: SchoolEduCreateManyWithoutStudentsInput;
  works?: WorkCreateManyWithoutWorkerInput;
  exam?: CollegeEntranceExamCreateOneWithoutStudentInput;
  sentMessages?: MessageCreateManyWithoutFromInput;
  receiveMessages?: MessageCreateManyWithoutToInput;
  groupMessages?: GroupMessageCreateManyWithoutFromInput;
  groups?: GroupCreateManyWithoutUsersInput;
  friends?: UserCreateManyInput;
  familyGroup?: FamilyGroupCreateOneWithoutUsersInput;
  creater?: FamilyGroupCreateOneWithoutCreaterInput;
  classMate?: ClassMateCreateManyWithoutStudentInput;
  workGroup?: WorkGroupCreateOneInput;
  colleagues?: ColleagueCreateManyWithoutWorkerInput;
  fromOldColleagues?: OldColleagueCreateManyWithoutFromInput;
  toOldColleagues?: OldColleagueCreateManyWithoutToInput;
  locationGroups?: LocationGroupCreateManyWithoutUsersInput;
  forgetPassword?: FindPassWordCreateOneWithoutForgetterInput;
  remmemberPassword?: FindPassWordCreateManyWithoutRemmemberInput;
  loveSetting?: LoveSettingCreateOneWithoutUserInput;
  loveWoman?: LoveMatchingCreateManyWithoutWomanInput;
  loveMan?: LoveMatchingCreateManyWithoutManInput;
  signUpLove?: LoveSignUpCreateOneWithoutPersonInput;
  skills?: SkillCreateManyWithoutPersonsInput;
  fitConditions?: PartnerConditionCreateManyWithoutPartnersInput;
  nofitConditions?: PartnerConditionCreateManyWithoutPassedPartnersInput;
  projects?: ProjectCreateManyWithoutStarterInput;
  trades?: TradeCreateManyWithoutUserInput;
}

export interface ProjectScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  content?: String;
  content_not?: String;
  content_in?: String[] | String;
  content_not_in?: String[] | String;
  content_lt?: String;
  content_lte?: String;
  content_gt?: String;
  content_gte?: String;
  content_contains?: String;
  content_not_contains?: String;
  content_starts_with?: String;
  content_not_starts_with?: String;
  content_ends_with?: String;
  content_not_ends_with?: String;
  AND?: ProjectScalarWhereInput[] | ProjectScalarWhereInput;
  OR?: ProjectScalarWhereInput[] | ProjectScalarWhereInput;
  NOT?: ProjectScalarWhereInput[] | ProjectScalarWhereInput;
}

export interface RegStatusCreateWithoutApplicantsInput {
  education: Educationkind;
  university?: UniversityCreateOneInput;
  major: MajorCreateOneInput;
}

export interface ProjectUpdateManyWithWhereNestedInput {
  where: ProjectScalarWhereInput;
  data: ProjectUpdateManyDataInput;
}

export interface FamilyCreateManyWithoutFromInput {
  create?: FamilyCreateWithoutFromInput[] | FamilyCreateWithoutFromInput;
  connect?: FamilyWhereUniqueInput[] | FamilyWhereUniqueInput;
}

export interface ProjectUpdateManyDataInput {
  name?: String;
  content?: String;
}

export interface UserCreateOneInput {
  create?: UserCreateInput;
  connect?: UserWhereUniqueInput;
}

export interface TradeUpdateManyWithoutUserInput {
  create?: TradeCreateWithoutUserInput[] | TradeCreateWithoutUserInput;
  delete?: TradeWhereUniqueInput[] | TradeWhereUniqueInput;
  connect?: TradeWhereUniqueInput[] | TradeWhereUniqueInput;
  disconnect?: TradeWhereUniqueInput[] | TradeWhereUniqueInput;
  update?:
    | TradeUpdateWithWhereUniqueWithoutUserInput[]
    | TradeUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | TradeUpsertWithWhereUniqueWithoutUserInput[]
    | TradeUpsertWithWhereUniqueWithoutUserInput;
  deleteMany?: TradeScalarWhereInput[] | TradeScalarWhereInput;
  updateMany?:
    | TradeUpdateManyWithWhereNestedInput[]
    | TradeUpdateManyWithWhereNestedInput;
}

export interface PersonCreateWithoutAsMotherInput {
  name: String;
  user?: UserCreateOneInput;
  families?: FamilyCreateManyWithoutToInput;
  asFather?: FamilyGroupCreateManyWithoutFatherInput;
}

export interface TradeUpdateWithWhereUniqueWithoutUserInput {
  where: TradeWhereUniqueInput;
  data: TradeUpdateWithoutUserDataInput;
}

export interface UserCreateWithoutFamiliesInput {
  username: String;
  password: String;
  name?: String;
  gender?: String;
  avatar?: PhotoCreateOneWithoutUserInput;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationCreateOneWithoutBornsInput;
  residence?: LocationCreateOneWithoutLivesInput;
  uid: String;
  token: String;
  posts?: PostCreateManyWithoutAuthorInput;
  regStatus?: RegStatusCreateOneWithoutApplicantsInput;
  regTimes?: Int;
  maxRegTimes?: Int;
  studies?: SchoolEduCreateManyWithoutStudentsInput;
  works?: WorkCreateManyWithoutWorkerInput;
  exam?: CollegeEntranceExamCreateOneWithoutStudentInput;
  sentMessages?: MessageCreateManyWithoutFromInput;
  receiveMessages?: MessageCreateManyWithoutToInput;
  groupMessages?: GroupMessageCreateManyWithoutFromInput;
  groups?: GroupCreateManyWithoutUsersInput;
  friends?: UserCreateManyInput;
  familyGroup?: FamilyGroupCreateOneWithoutUsersInput;
  creater?: FamilyGroupCreateOneWithoutCreaterInput;
  classMate?: ClassMateCreateManyWithoutStudentInput;
  workGroup?: WorkGroupCreateOneInput;
  colleagues?: ColleagueCreateManyWithoutWorkerInput;
  fromOldColleagues?: OldColleagueCreateManyWithoutFromInput;
  toOldColleagues?: OldColleagueCreateManyWithoutToInput;
  locationGroups?: LocationGroupCreateManyWithoutUsersInput;
  forgetPassword?: FindPassWordCreateOneWithoutForgetterInput;
  remmemberPassword?: FindPassWordCreateManyWithoutRemmemberInput;
  loveSetting?: LoveSettingCreateOneWithoutUserInput;
  loveWoman?: LoveMatchingCreateManyWithoutWomanInput;
  loveMan?: LoveMatchingCreateManyWithoutManInput;
  signUpLove?: LoveSignUpCreateOneWithoutPersonInput;
  skills?: SkillCreateManyWithoutPersonsInput;
  fitConditions?: PartnerConditionCreateManyWithoutPartnersInput;
  nofitConditions?: PartnerConditionCreateManyWithoutPassedPartnersInput;
  projects?: ProjectCreateManyWithoutStarterInput;
  trades?: TradeCreateManyWithoutUserInput;
}

export interface TradeUpdateWithoutUserDataInput {
  product?: ProductUpdateOneInput;
  number?: Int;
  amount?: Float;
  status?: String;
}

export interface SchoolCreateInput {
  name?: String;
  kind?: Educationkind;
  location?: LocationCreateOneWithoutSchoolsInput;
}

export interface ProductUpdateOneInput {
  create?: ProductCreateInput;
  update?: ProductUpdateDataInput;
  upsert?: ProductUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ProductWhereUniqueInput;
}

export interface UserCreateWithoutResidenceInput {
  username: String;
  password: String;
  name?: String;
  gender?: String;
  avatar?: PhotoCreateOneWithoutUserInput;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationCreateOneWithoutBornsInput;
  uid: String;
  token: String;
  posts?: PostCreateManyWithoutAuthorInput;
  regStatus?: RegStatusCreateOneWithoutApplicantsInput;
  regTimes?: Int;
  maxRegTimes?: Int;
  families?: FamilyCreateManyWithoutFromInput;
  studies?: SchoolEduCreateManyWithoutStudentsInput;
  works?: WorkCreateManyWithoutWorkerInput;
  exam?: CollegeEntranceExamCreateOneWithoutStudentInput;
  sentMessages?: MessageCreateManyWithoutFromInput;
  receiveMessages?: MessageCreateManyWithoutToInput;
  groupMessages?: GroupMessageCreateManyWithoutFromInput;
  groups?: GroupCreateManyWithoutUsersInput;
  friends?: UserCreateManyInput;
  familyGroup?: FamilyGroupCreateOneWithoutUsersInput;
  creater?: FamilyGroupCreateOneWithoutCreaterInput;
  classMate?: ClassMateCreateManyWithoutStudentInput;
  workGroup?: WorkGroupCreateOneInput;
  colleagues?: ColleagueCreateManyWithoutWorkerInput;
  fromOldColleagues?: OldColleagueCreateManyWithoutFromInput;
  toOldColleagues?: OldColleagueCreateManyWithoutToInput;
  locationGroups?: LocationGroupCreateManyWithoutUsersInput;
  forgetPassword?: FindPassWordCreateOneWithoutForgetterInput;
  remmemberPassword?: FindPassWordCreateManyWithoutRemmemberInput;
  loveSetting?: LoveSettingCreateOneWithoutUserInput;
  loveWoman?: LoveMatchingCreateManyWithoutWomanInput;
  loveMan?: LoveMatchingCreateManyWithoutManInput;
  signUpLove?: LoveSignUpCreateOneWithoutPersonInput;
  skills?: SkillCreateManyWithoutPersonsInput;
  fitConditions?: PartnerConditionCreateManyWithoutPartnersInput;
  nofitConditions?: PartnerConditionCreateManyWithoutPassedPartnersInput;
  projects?: ProjectCreateManyWithoutStarterInput;
  trades?: TradeCreateManyWithoutUserInput;
}

export interface ProductUpdateDataInput {
  subject?: String;
  info?: String;
  price?: Float;
  kind?: String;
}

export interface CompanyCreateWithoutWorksInput {
  name?: String;
  code?: String;
  establishmentDate?: DateTimeInput;
  representative?: String;
  location?: LocationCreateOneWithoutCompaniesInput;
  BusinessScope?: String;
  workGroup?: WorkGroupCreateOneWithoutCompanyInput;
}

export interface ProductUpsertNestedInput {
  update: ProductUpdateDataInput;
  create: ProductCreateInput;
}

export interface WorkGroupCreateWithoutCompanyInput {
  colleagues?: ColleagueCreateManyWithoutGroupInput;
}

export interface TradeUpsertWithWhereUniqueWithoutUserInput {
  where: TradeWhereUniqueInput;
  update: TradeUpdateWithoutUserDataInput;
  create: TradeCreateWithoutUserInput;
}

export interface UserCreateWithoutColleaguesInput {
  username: String;
  password: String;
  name?: String;
  gender?: String;
  avatar?: PhotoCreateOneWithoutUserInput;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationCreateOneWithoutBornsInput;
  residence?: LocationCreateOneWithoutLivesInput;
  uid: String;
  token: String;
  posts?: PostCreateManyWithoutAuthorInput;
  regStatus?: RegStatusCreateOneWithoutApplicantsInput;
  regTimes?: Int;
  maxRegTimes?: Int;
  families?: FamilyCreateManyWithoutFromInput;
  studies?: SchoolEduCreateManyWithoutStudentsInput;
  works?: WorkCreateManyWithoutWorkerInput;
  exam?: CollegeEntranceExamCreateOneWithoutStudentInput;
  sentMessages?: MessageCreateManyWithoutFromInput;
  receiveMessages?: MessageCreateManyWithoutToInput;
  groupMessages?: GroupMessageCreateManyWithoutFromInput;
  groups?: GroupCreateManyWithoutUsersInput;
  friends?: UserCreateManyInput;
  familyGroup?: FamilyGroupCreateOneWithoutUsersInput;
  creater?: FamilyGroupCreateOneWithoutCreaterInput;
  classMate?: ClassMateCreateManyWithoutStudentInput;
  workGroup?: WorkGroupCreateOneInput;
  fromOldColleagues?: OldColleagueCreateManyWithoutFromInput;
  toOldColleagues?: OldColleagueCreateManyWithoutToInput;
  locationGroups?: LocationGroupCreateManyWithoutUsersInput;
  forgetPassword?: FindPassWordCreateOneWithoutForgetterInput;
  remmemberPassword?: FindPassWordCreateManyWithoutRemmemberInput;
  loveSetting?: LoveSettingCreateOneWithoutUserInput;
  loveWoman?: LoveMatchingCreateManyWithoutWomanInput;
  loveMan?: LoveMatchingCreateManyWithoutManInput;
  signUpLove?: LoveSignUpCreateOneWithoutPersonInput;
  skills?: SkillCreateManyWithoutPersonsInput;
  fitConditions?: PartnerConditionCreateManyWithoutPartnersInput;
  nofitConditions?: PartnerConditionCreateManyWithoutPassedPartnersInput;
  projects?: ProjectCreateManyWithoutStarterInput;
  trades?: TradeCreateManyWithoutUserInput;
}

export interface TradeScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  number?: Int;
  number_not?: Int;
  number_in?: Int[] | Int;
  number_not_in?: Int[] | Int;
  number_lt?: Int;
  number_lte?: Int;
  number_gt?: Int;
  number_gte?: Int;
  amount?: Float;
  amount_not?: Float;
  amount_in?: Float[] | Float;
  amount_not_in?: Float[] | Float;
  amount_lt?: Float;
  amount_lte?: Float;
  amount_gt?: Float;
  amount_gte?: Float;
  status?: String;
  status_not?: String;
  status_in?: String[] | String;
  status_not_in?: String[] | String;
  status_lt?: String;
  status_lte?: String;
  status_gt?: String;
  status_gte?: String;
  status_contains?: String;
  status_not_contains?: String;
  status_starts_with?: String;
  status_not_starts_with?: String;
  status_ends_with?: String;
  status_not_ends_with?: String;
  AND?: TradeScalarWhereInput[] | TradeScalarWhereInput;
  OR?: TradeScalarWhereInput[] | TradeScalarWhereInput;
  NOT?: TradeScalarWhereInput[] | TradeScalarWhereInput;
}

export interface MessageCreateWithoutFromInput {
  to: UserCreateOneWithoutReceiveMessagesInput;
  text?: String;
  image?: PhotoCreateOneInput;
}

export interface TradeUpdateManyWithWhereNestedInput {
  where: TradeScalarWhereInput;
  data: TradeUpdateManyDataInput;
}

export interface GroupMessageCreateWithoutFromInput {
  type?: GroupKind;
  to: String;
  text?: String;
  image?: PhotoCreateOneInput;
}

export interface TradeUpdateManyDataInput {
  number?: Int;
  amount?: Float;
  status?: String;
}

export interface UserCreateWithoutAvatarInput {
  username: String;
  password: String;
  name?: String;
  gender?: String;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationCreateOneWithoutBornsInput;
  residence?: LocationCreateOneWithoutLivesInput;
  uid: String;
  token: String;
  posts?: PostCreateManyWithoutAuthorInput;
  regStatus?: RegStatusCreateOneWithoutApplicantsInput;
  regTimes?: Int;
  maxRegTimes?: Int;
  families?: FamilyCreateManyWithoutFromInput;
  studies?: SchoolEduCreateManyWithoutStudentsInput;
  works?: WorkCreateManyWithoutWorkerInput;
  exam?: CollegeEntranceExamCreateOneWithoutStudentInput;
  sentMessages?: MessageCreateManyWithoutFromInput;
  receiveMessages?: MessageCreateManyWithoutToInput;
  groupMessages?: GroupMessageCreateManyWithoutFromInput;
  groups?: GroupCreateManyWithoutUsersInput;
  friends?: UserCreateManyInput;
  familyGroup?: FamilyGroupCreateOneWithoutUsersInput;
  creater?: FamilyGroupCreateOneWithoutCreaterInput;
  classMate?: ClassMateCreateManyWithoutStudentInput;
  workGroup?: WorkGroupCreateOneInput;
  colleagues?: ColleagueCreateManyWithoutWorkerInput;
  fromOldColleagues?: OldColleagueCreateManyWithoutFromInput;
  toOldColleagues?: OldColleagueCreateManyWithoutToInput;
  locationGroups?: LocationGroupCreateManyWithoutUsersInput;
  forgetPassword?: FindPassWordCreateOneWithoutForgetterInput;
  remmemberPassword?: FindPassWordCreateManyWithoutRemmemberInput;
  loveSetting?: LoveSettingCreateOneWithoutUserInput;
  loveWoman?: LoveMatchingCreateManyWithoutWomanInput;
  loveMan?: LoveMatchingCreateManyWithoutManInput;
  signUpLove?: LoveSignUpCreateOneWithoutPersonInput;
  skills?: SkillCreateManyWithoutPersonsInput;
  fitConditions?: PartnerConditionCreateManyWithoutPartnersInput;
  nofitConditions?: PartnerConditionCreateManyWithoutPassedPartnersInput;
  projects?: ProjectCreateManyWithoutStarterInput;
  trades?: TradeCreateManyWithoutUserInput;
}

export interface UserUpsertWithWhereUniqueWithoutFitConditionsInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutFitConditionsDataInput;
  create: UserCreateWithoutFitConditionsInput;
}

export interface UserCreateWithoutSentMessagesInput {
  username: String;
  password: String;
  name?: String;
  gender?: String;
  avatar?: PhotoCreateOneWithoutUserInput;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationCreateOneWithoutBornsInput;
  residence?: LocationCreateOneWithoutLivesInput;
  uid: String;
  token: String;
  posts?: PostCreateManyWithoutAuthorInput;
  regStatus?: RegStatusCreateOneWithoutApplicantsInput;
  regTimes?: Int;
  maxRegTimes?: Int;
  families?: FamilyCreateManyWithoutFromInput;
  studies?: SchoolEduCreateManyWithoutStudentsInput;
  works?: WorkCreateManyWithoutWorkerInput;
  exam?: CollegeEntranceExamCreateOneWithoutStudentInput;
  receiveMessages?: MessageCreateManyWithoutToInput;
  groupMessages?: GroupMessageCreateManyWithoutFromInput;
  groups?: GroupCreateManyWithoutUsersInput;
  friends?: UserCreateManyInput;
  familyGroup?: FamilyGroupCreateOneWithoutUsersInput;
  creater?: FamilyGroupCreateOneWithoutCreaterInput;
  classMate?: ClassMateCreateManyWithoutStudentInput;
  workGroup?: WorkGroupCreateOneInput;
  colleagues?: ColleagueCreateManyWithoutWorkerInput;
  fromOldColleagues?: OldColleagueCreateManyWithoutFromInput;
  toOldColleagues?: OldColleagueCreateManyWithoutToInput;
  locationGroups?: LocationGroupCreateManyWithoutUsersInput;
  forgetPassword?: FindPassWordCreateOneWithoutForgetterInput;
  remmemberPassword?: FindPassWordCreateManyWithoutRemmemberInput;
  loveSetting?: LoveSettingCreateOneWithoutUserInput;
  loveWoman?: LoveMatchingCreateManyWithoutWomanInput;
  loveMan?: LoveMatchingCreateManyWithoutManInput;
  signUpLove?: LoveSignUpCreateOneWithoutPersonInput;
  skills?: SkillCreateManyWithoutPersonsInput;
  fitConditions?: PartnerConditionCreateManyWithoutPartnersInput;
  nofitConditions?: PartnerConditionCreateManyWithoutPassedPartnersInput;
  projects?: ProjectCreateManyWithoutStarterInput;
  trades?: TradeCreateManyWithoutUserInput;
}

export interface UserScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  username?: String;
  username_not?: String;
  username_in?: String[] | String;
  username_not_in?: String[] | String;
  username_lt?: String;
  username_lte?: String;
  username_gt?: String;
  username_gte?: String;
  username_contains?: String;
  username_not_contains?: String;
  username_starts_with?: String;
  username_not_starts_with?: String;
  username_ends_with?: String;
  username_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  gender?: String;
  gender_not?: String;
  gender_in?: String[] | String;
  gender_not_in?: String[] | String;
  gender_lt?: String;
  gender_lte?: String;
  gender_gt?: String;
  gender_gte?: String;
  gender_contains?: String;
  gender_not_contains?: String;
  gender_starts_with?: String;
  gender_not_starts_with?: String;
  gender_ends_with?: String;
  gender_not_ends_with?: String;
  birthdaycalendar?: String;
  birthdaycalendar_not?: String;
  birthdaycalendar_in?: String[] | String;
  birthdaycalendar_not_in?: String[] | String;
  birthdaycalendar_lt?: String;
  birthdaycalendar_lte?: String;
  birthdaycalendar_gt?: String;
  birthdaycalendar_gte?: String;
  birthdaycalendar_contains?: String;
  birthdaycalendar_not_contains?: String;
  birthdaycalendar_starts_with?: String;
  birthdaycalendar_not_starts_with?: String;
  birthdaycalendar_ends_with?: String;
  birthdaycalendar_not_ends_with?: String;
  birthday?: DateTimeInput;
  birthday_not?: DateTimeInput;
  birthday_in?: DateTimeInput[] | DateTimeInput;
  birthday_not_in?: DateTimeInput[] | DateTimeInput;
  birthday_lt?: DateTimeInput;
  birthday_lte?: DateTimeInput;
  birthday_gt?: DateTimeInput;
  birthday_gte?: DateTimeInput;
  uid?: String;
  uid_not?: String;
  uid_in?: String[] | String;
  uid_not_in?: String[] | String;
  uid_lt?: String;
  uid_lte?: String;
  uid_gt?: String;
  uid_gte?: String;
  uid_contains?: String;
  uid_not_contains?: String;
  uid_starts_with?: String;
  uid_not_starts_with?: String;
  uid_ends_with?: String;
  uid_not_ends_with?: String;
  token?: String;
  token_not?: String;
  token_in?: String[] | String;
  token_not_in?: String[] | String;
  token_lt?: String;
  token_lte?: String;
  token_gt?: String;
  token_gte?: String;
  token_contains?: String;
  token_not_contains?: String;
  token_starts_with?: String;
  token_not_starts_with?: String;
  token_ends_with?: String;
  token_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  regTimes?: Int;
  regTimes_not?: Int;
  regTimes_in?: Int[] | Int;
  regTimes_not_in?: Int[] | Int;
  regTimes_lt?: Int;
  regTimes_lte?: Int;
  regTimes_gt?: Int;
  regTimes_gte?: Int;
  maxRegTimes?: Int;
  maxRegTimes_not?: Int;
  maxRegTimes_in?: Int[] | Int;
  maxRegTimes_not_in?: Int[] | Int;
  maxRegTimes_lt?: Int;
  maxRegTimes_lte?: Int;
  maxRegTimes_gt?: Int;
  maxRegTimes_gte?: Int;
  AND?: UserScalarWhereInput[] | UserScalarWhereInput;
  OR?: UserScalarWhereInput[] | UserScalarWhereInput;
  NOT?: UserScalarWhereInput[] | UserScalarWhereInput;
}

export interface MessageCreateInput {
  to: UserCreateOneWithoutReceiveMessagesInput;
  from: UserCreateOneWithoutSentMessagesInput;
  text?: String;
  image?: PhotoCreateOneInput;
}

export interface UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput;
  data: UserUpdateManyDataInput;
}

export interface PersonCreateWithoutAsFatherInput {
  name: String;
  user?: UserCreateOneInput;
  families?: FamilyCreateManyWithoutToInput;
  asMother?: FamilyGroupCreateManyWithoutMotherInput;
}

export interface UserUpdateManyDataInput {
  username?: String;
  password?: String;
  name?: String;
  gender?: String;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  uid?: String;
  token?: String;
  regTimes?: Int;
  maxRegTimes?: Int;
}

export interface UserCreateWithoutCreaterInput {
  username: String;
  password: String;
  name?: String;
  gender?: String;
  avatar?: PhotoCreateOneWithoutUserInput;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationCreateOneWithoutBornsInput;
  residence?: LocationCreateOneWithoutLivesInput;
  uid: String;
  token: String;
  posts?: PostCreateManyWithoutAuthorInput;
  regStatus?: RegStatusCreateOneWithoutApplicantsInput;
  regTimes?: Int;
  maxRegTimes?: Int;
  families?: FamilyCreateManyWithoutFromInput;
  studies?: SchoolEduCreateManyWithoutStudentsInput;
  works?: WorkCreateManyWithoutWorkerInput;
  exam?: CollegeEntranceExamCreateOneWithoutStudentInput;
  sentMessages?: MessageCreateManyWithoutFromInput;
  receiveMessages?: MessageCreateManyWithoutToInput;
  groupMessages?: GroupMessageCreateManyWithoutFromInput;
  groups?: GroupCreateManyWithoutUsersInput;
  friends?: UserCreateManyInput;
  familyGroup?: FamilyGroupCreateOneWithoutUsersInput;
  classMate?: ClassMateCreateManyWithoutStudentInput;
  workGroup?: WorkGroupCreateOneInput;
  colleagues?: ColleagueCreateManyWithoutWorkerInput;
  fromOldColleagues?: OldColleagueCreateManyWithoutFromInput;
  toOldColleagues?: OldColleagueCreateManyWithoutToInput;
  locationGroups?: LocationGroupCreateManyWithoutUsersInput;
  forgetPassword?: FindPassWordCreateOneWithoutForgetterInput;
  remmemberPassword?: FindPassWordCreateManyWithoutRemmemberInput;
  loveSetting?: LoveSettingCreateOneWithoutUserInput;
  loveWoman?: LoveMatchingCreateManyWithoutWomanInput;
  loveMan?: LoveMatchingCreateManyWithoutManInput;
  signUpLove?: LoveSignUpCreateOneWithoutPersonInput;
  skills?: SkillCreateManyWithoutPersonsInput;
  fitConditions?: PartnerConditionCreateManyWithoutPartnersInput;
  nofitConditions?: PartnerConditionCreateManyWithoutPassedPartnersInput;
  projects?: ProjectCreateManyWithoutStarterInput;
  trades?: TradeCreateManyWithoutUserInput;
}

export interface ProjectUpdateOneWithoutConditionsInput {
  create?: ProjectCreateWithoutConditionsInput;
  update?: ProjectUpdateWithoutConditionsDataInput;
  upsert?: ProjectUpsertWithoutConditionsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ProjectWhereUniqueInput;
}

export interface ClassGroupCreateWithoutMembersInput {
  study?: SchoolEduCreateOneInput;
  name?: String;
}

export interface ProjectUpdateWithoutConditionsDataInput {
  name?: String;
  place?: CityUpdateOneInput;
  content?: String;
  starter?: UserUpdateOneWithoutProjectsInput;
}

export interface UserCreateWithoutStudiesInput {
  username: String;
  password: String;
  name?: String;
  gender?: String;
  avatar?: PhotoCreateOneWithoutUserInput;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationCreateOneWithoutBornsInput;
  residence?: LocationCreateOneWithoutLivesInput;
  uid: String;
  token: String;
  posts?: PostCreateManyWithoutAuthorInput;
  regStatus?: RegStatusCreateOneWithoutApplicantsInput;
  regTimes?: Int;
  maxRegTimes?: Int;
  families?: FamilyCreateManyWithoutFromInput;
  works?: WorkCreateManyWithoutWorkerInput;
  exam?: CollegeEntranceExamCreateOneWithoutStudentInput;
  sentMessages?: MessageCreateManyWithoutFromInput;
  receiveMessages?: MessageCreateManyWithoutToInput;
  groupMessages?: GroupMessageCreateManyWithoutFromInput;
  groups?: GroupCreateManyWithoutUsersInput;
  friends?: UserCreateManyInput;
  familyGroup?: FamilyGroupCreateOneWithoutUsersInput;
  creater?: FamilyGroupCreateOneWithoutCreaterInput;
  classMate?: ClassMateCreateManyWithoutStudentInput;
  workGroup?: WorkGroupCreateOneInput;
  colleagues?: ColleagueCreateManyWithoutWorkerInput;
  fromOldColleagues?: OldColleagueCreateManyWithoutFromInput;
  toOldColleagues?: OldColleagueCreateManyWithoutToInput;
  locationGroups?: LocationGroupCreateManyWithoutUsersInput;
  forgetPassword?: FindPassWordCreateOneWithoutForgetterInput;
  remmemberPassword?: FindPassWordCreateManyWithoutRemmemberInput;
  loveSetting?: LoveSettingCreateOneWithoutUserInput;
  loveWoman?: LoveMatchingCreateManyWithoutWomanInput;
  loveMan?: LoveMatchingCreateManyWithoutManInput;
  signUpLove?: LoveSignUpCreateOneWithoutPersonInput;
  skills?: SkillCreateManyWithoutPersonsInput;
  fitConditions?: PartnerConditionCreateManyWithoutPartnersInput;
  nofitConditions?: PartnerConditionCreateManyWithoutPassedPartnersInput;
  projects?: ProjectCreateManyWithoutStarterInput;
  trades?: TradeCreateManyWithoutUserInput;
}

export interface UserUpdateOneWithoutProjectsInput {
  create?: UserCreateWithoutProjectsInput;
  update?: UserUpdateWithoutProjectsDataInput;
  upsert?: UserUpsertWithoutProjectsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface FamilyCreateInput {
  from: UserCreateOneWithoutFamiliesInput;
  to: PersonCreateOneWithoutFamiliesInput;
  relationship: String;
  spouse?: FamilyCreateOneInput;
  status: String;
}

export interface UserUpdateWithoutProjectsDataInput {
  username?: String;
  password?: String;
  name?: String;
  gender?: String;
  avatar?: PhotoUpdateOneWithoutUserInput;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationUpdateOneWithoutBornsInput;
  residence?: LocationUpdateOneWithoutLivesInput;
  uid?: String;
  token?: String;
  posts?: PostUpdateManyWithoutAuthorInput;
  regStatus?: RegStatusUpdateOneWithoutApplicantsInput;
  regTimes?: Int;
  maxRegTimes?: Int;
  families?: FamilyUpdateManyWithoutFromInput;
  studies?: SchoolEduUpdateManyWithoutStudentsInput;
  works?: WorkUpdateManyWithoutWorkerInput;
  exam?: CollegeEntranceExamUpdateOneWithoutStudentInput;
  sentMessages?: MessageUpdateManyWithoutFromInput;
  receiveMessages?: MessageUpdateManyWithoutToInput;
  groupMessages?: GroupMessageUpdateManyWithoutFromInput;
  groups?: GroupUpdateManyWithoutUsersInput;
  friends?: UserUpdateManyInput;
  familyGroup?: FamilyGroupUpdateOneWithoutUsersInput;
  creater?: FamilyGroupUpdateOneWithoutCreaterInput;
  classMate?: ClassMateUpdateManyWithoutStudentInput;
  workGroup?: WorkGroupUpdateOneInput;
  colleagues?: ColleagueUpdateManyWithoutWorkerInput;
  fromOldColleagues?: OldColleagueUpdateManyWithoutFromInput;
  toOldColleagues?: OldColleagueUpdateManyWithoutToInput;
  locationGroups?: LocationGroupUpdateManyWithoutUsersInput;
  forgetPassword?: FindPassWordUpdateOneWithoutForgetterInput;
  remmemberPassword?: FindPassWordUpdateManyWithoutRemmemberInput;
  loveSetting?: LoveSettingUpdateOneWithoutUserInput;
  loveWoman?: LoveMatchingUpdateManyWithoutWomanInput;
  loveMan?: LoveMatchingUpdateManyWithoutManInput;
  signUpLove?: LoveSignUpUpdateOneWithoutPersonInput;
  skills?: SkillUpdateManyWithoutPersonsInput;
  fitConditions?: PartnerConditionUpdateManyWithoutPartnersInput;
  nofitConditions?: PartnerConditionUpdateManyWithoutPassedPartnersInput;
  trades?: TradeUpdateManyWithoutUserInput;
}

export interface WorkGroupCreateOneInput {
  create?: WorkGroupCreateInput;
  connect?: WorkGroupWhereUniqueInput;
}

export interface UserUpsertWithoutProjectsInput {
  update: UserUpdateWithoutProjectsDataInput;
  create: UserCreateWithoutProjectsInput;
}

export interface ColleagueCreateManyWithoutWorkerInput {
  create?:
    | ColleagueCreateWithoutWorkerInput[]
    | ColleagueCreateWithoutWorkerInput;
  connect?: ColleagueWhereUniqueInput[] | ColleagueWhereUniqueInput;
}

export interface ProjectUpsertWithoutConditionsInput {
  update: ProjectUpdateWithoutConditionsDataInput;
  create: ProjectCreateWithoutConditionsInput;
}

export interface OldColleagueCreateManyWithoutFromInput {
  create?:
    | OldColleagueCreateWithoutFromInput[]
    | OldColleagueCreateWithoutFromInput;
  connect?: OldColleagueWhereUniqueInput[] | OldColleagueWhereUniqueInput;
}

export interface PartnerConditionUpsertWithWhereUniqueWithoutPassedPartnersInput {
  where: PartnerConditionWhereUniqueInput;
  update: PartnerConditionUpdateWithoutPassedPartnersDataInput;
  create: PartnerConditionCreateWithoutPassedPartnersInput;
}

export interface LocationGroupCreateManyWithoutUsersInput {
  create?:
    | LocationGroupCreateWithoutUsersInput[]
    | LocationGroupCreateWithoutUsersInput;
  connect?: LocationGroupWhereUniqueInput[] | LocationGroupWhereUniqueInput;
}

export interface UserUpsertWithoutLoveWomanInput {
  update: UserUpdateWithoutLoveWomanDataInput;
  create: UserCreateWithoutLoveWomanInput;
}

export interface UserCreateManyWithoutRemmemberPasswordInput {
  create?:
    | UserCreateWithoutRemmemberPasswordInput[]
    | UserCreateWithoutRemmemberPasswordInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface LoveMatchingUpsertWithWhereUniqueWithoutManInput {
  where: LoveMatchingWhereUniqueInput;
  update: LoveMatchingUpdateWithoutManDataInput;
  create: LoveMatchingCreateWithoutManInput;
}

export interface UserCreateOneWithoutFromOldColleaguesInput {
  create?: UserCreateWithoutFromOldColleaguesInput;
  connect?: UserWhereUniqueInput;
}

export interface LoveMatchingScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  period?: String;
  period_not?: String;
  period_in?: String[] | String;
  period_not_in?: String[] | String;
  period_lt?: String;
  period_lte?: String;
  period_gt?: String;
  period_gte?: String;
  period_contains?: String;
  period_not_contains?: String;
  period_starts_with?: String;
  period_not_starts_with?: String;
  period_ends_with?: String;
  period_not_ends_with?: String;
  AND?: LoveMatchingScalarWhereInput[] | LoveMatchingScalarWhereInput;
  OR?: LoveMatchingScalarWhereInput[] | LoveMatchingScalarWhereInput;
  NOT?: LoveMatchingScalarWhereInput[] | LoveMatchingScalarWhereInput;
}

export interface UserCreateOneWithoutForgetPasswordInput {
  create?: UserCreateWithoutForgetPasswordInput;
  connect?: UserWhereUniqueInput;
}

export interface LoveMatchingUpdateManyWithWhereNestedInput {
  where: LoveMatchingScalarWhereInput;
  data: LoveMatchingUpdateManyDataInput;
}

export interface LoveMatchingCreateManyWithoutWomanInput {
  create?:
    | LoveMatchingCreateWithoutWomanInput[]
    | LoveMatchingCreateWithoutWomanInput;
  connect?: LoveMatchingWhereUniqueInput[] | LoveMatchingWhereUniqueInput;
}

export interface LoveMatchingUpdateManyDataInput {
  period?: String;
}

export interface LoveSignUpCreateOneWithoutPersonInput {
  create?: LoveSignUpCreateWithoutPersonInput;
  connect?: LoveSignUpWhereUniqueInput;
}

export interface UserUpsertWithWhereUniqueWithoutNofitConditionsInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutNofitConditionsDataInput;
  create: UserCreateWithoutNofitConditionsInput;
}

export interface PartnerConditionCreateManyWithoutPartnersInput {
  create?:
    | PartnerConditionCreateWithoutPartnersInput[]
    | PartnerConditionCreateWithoutPartnersInput;
  connect?:
    | PartnerConditionWhereUniqueInput[]
    | PartnerConditionWhereUniqueInput;
}

export interface PartnerConditionUpsertWithWhereUniqueWithoutPartnersInput {
  where: PartnerConditionWhereUniqueInput;
  update: PartnerConditionUpdateWithoutPartnersDataInput;
  create: PartnerConditionCreateWithoutPartnersInput;
}

export interface LoveMatchingCreateManyWithoutManInput {
  create?:
    | LoveMatchingCreateWithoutManInput[]
    | LoveMatchingCreateWithoutManInput;
  connect?: LoveMatchingWhereUniqueInput[] | LoveMatchingWhereUniqueInput;
}

export interface UserUpsertWithoutLoveManInput {
  update: UserUpdateWithoutLoveManDataInput;
  create: UserCreateWithoutLoveManInput;
}

export interface PartnerConditionCreateManyWithoutPassedPartnersInput {
  create?:
    | PartnerConditionCreateWithoutPassedPartnersInput[]
    | PartnerConditionCreateWithoutPassedPartnersInput;
  connect?:
    | PartnerConditionWhereUniqueInput[]
    | PartnerConditionWhereUniqueInput;
}

export interface LoveMatchingUpsertWithWhereUniqueWithoutWomanInput {
  where: LoveMatchingWhereUniqueInput;
  update: LoveMatchingUpdateWithoutWomanDataInput;
  create: LoveMatchingCreateWithoutWomanInput;
}

export interface ProjectCreateManyWithoutStarterInput {
  create?:
    | ProjectCreateWithoutStarterInput[]
    | ProjectCreateWithoutStarterInput;
  connect?: ProjectWhereUniqueInput[] | ProjectWhereUniqueInput;
}

export interface UserUpsertWithoutForgetPasswordInput {
  update: UserUpdateWithoutForgetPasswordDataInput;
  create: UserCreateWithoutForgetPasswordInput;
}

export interface TradeCreateManyWithoutUserInput {
  create?: TradeCreateWithoutUserInput[] | TradeCreateWithoutUserInput;
  connect?: TradeWhereUniqueInput[] | TradeWhereUniqueInput;
}

export interface FindPassWordUpsertWithWhereUniqueWithoutRemmemberInput {
  where: FindPassWordWhereUniqueInput;
  update: FindPassWordUpdateWithoutRemmemberDataInput;
  create: FindPassWordCreateWithoutRemmemberInput;
}

export interface ProjectCreateOneWithoutConditionsInput {
  create?: ProjectCreateWithoutConditionsInput;
  connect?: ProjectWhereUniqueInput;
}

export interface FindPassWordScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  times?: Int;
  times_not?: Int;
  times_in?: Int[] | Int;
  times_not_in?: Int[] | Int;
  times_lt?: Int;
  times_lte?: Int;
  times_gt?: Int;
  times_gte?: Int;
  AND?: FindPassWordScalarWhereInput[] | FindPassWordScalarWhereInput;
  OR?: FindPassWordScalarWhereInput[] | FindPassWordScalarWhereInput;
  NOT?: FindPassWordScalarWhereInput[] | FindPassWordScalarWhereInput;
}

export interface CompanyCreateOneInput {
  create?: CompanyCreateInput;
  connect?: CompanyWhereUniqueInput;
}

export interface FindPassWordUpdateManyWithWhereNestedInput {
  where: FindPassWordScalarWhereInput;
  data: FindPassWordUpdateManyDataInput;
}

export interface WorkSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: WorkWhereInput;
  AND?: WorkSubscriptionWhereInput[] | WorkSubscriptionWhereInput;
  OR?: WorkSubscriptionWhereInput[] | WorkSubscriptionWhereInput;
  NOT?: WorkSubscriptionWhereInput[] | WorkSubscriptionWhereInput;
}

export interface FindPassWordUpdateManyDataInput {
  times?: Int;
}

export interface FamilyGroupWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  father?: PersonWhereInput;
  mother?: PersonWhereInput;
  creater?: UserWhereInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  families_every?: FamilyWhereInput;
  families_some?: FamilyWhereInput;
  families_none?: FamilyWhereInput;
  users_every?: UserWhereInput;
  users_some?: UserWhereInput;
  users_none?: UserWhereInput;
  AND?: FamilyGroupWhereInput[] | FamilyGroupWhereInput;
  OR?: FamilyGroupWhereInput[] | FamilyGroupWhereInput;
  NOT?: FamilyGroupWhereInput[] | FamilyGroupWhereInput;
}

export interface UserUpsertWithoutFromOldColleaguesInput {
  update: UserUpdateWithoutFromOldColleaguesDataInput;
  create: UserCreateWithoutFromOldColleaguesInput;
}

export interface RegStatusSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: RegStatusWhereInput;
  AND?: RegStatusSubscriptionWhereInput[] | RegStatusSubscriptionWhereInput;
  OR?: RegStatusSubscriptionWhereInput[] | RegStatusSubscriptionWhereInput;
  NOT?: RegStatusSubscriptionWhereInput[] | RegStatusSubscriptionWhereInput;
}

export interface CompanyUpdateOneInput {
  create?: CompanyCreateInput;
  update?: CompanyUpdateDataInput;
  upsert?: CompanyUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: CompanyWhereUniqueInput;
}

export interface UniversityWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  education?: Educationkind;
  education_not?: Educationkind;
  education_in?: Educationkind[] | Educationkind;
  education_not_in?: Educationkind[] | Educationkind;
  department?: String;
  department_not?: String;
  department_in?: String[] | String;
  department_not_in?: String[] | String;
  department_lt?: String;
  department_lte?: String;
  department_gt?: String;
  department_gte?: String;
  department_contains?: String;
  department_not_contains?: String;
  department_starts_with?: String;
  department_not_starts_with?: String;
  department_ends_with?: String;
  department_not_ends_with?: String;
  location?: String;
  location_not?: String;
  location_in?: String[] | String;
  location_not_in?: String[] | String;
  location_lt?: String;
  location_lte?: String;
  location_gt?: String;
  location_gte?: String;
  location_contains?: String;
  location_not_contains?: String;
  location_starts_with?: String;
  location_not_starts_with?: String;
  location_ends_with?: String;
  location_not_ends_with?: String;
  desc?: String;
  desc_not?: String;
  desc_in?: String[] | String;
  desc_not_in?: String[] | String;
  desc_lt?: String;
  desc_lte?: String;
  desc_gt?: String;
  desc_gte?: String;
  desc_contains?: String;
  desc_not_contains?: String;
  desc_starts_with?: String;
  desc_not_starts_with?: String;
  desc_ends_with?: String;
  desc_not_ends_with?: String;
  AND?: UniversityWhereInput[] | UniversityWhereInput;
  OR?: UniversityWhereInput[] | UniversityWhereInput;
  NOT?: UniversityWhereInput[] | UniversityWhereInput;
}

export interface CompanyUpdateDataInput {
  name?: String;
  code?: String;
  establishmentDate?: DateTimeInput;
  representative?: String;
  location?: LocationUpdateOneWithoutCompaniesInput;
  BusinessScope?: String;
  works?: WorkUpdateManyWithoutCompanyInput;
  workGroup?: WorkGroupUpdateOneWithoutCompanyInput;
}

export interface MessageSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: MessageWhereInput;
  AND?: MessageSubscriptionWhereInput[] | MessageSubscriptionWhereInput;
  OR?: MessageSubscriptionWhereInput[] | MessageSubscriptionWhereInput;
  NOT?: MessageSubscriptionWhereInput[] | MessageSubscriptionWhereInput;
}

export interface CompanyUpsertNestedInput {
  update: CompanyUpdateDataInput;
  create: CompanyCreateInput;
}

export interface LogsSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: LogsWhereInput;
  AND?: LogsSubscriptionWhereInput[] | LogsSubscriptionWhereInput;
  OR?: LogsSubscriptionWhereInput[] | LogsSubscriptionWhereInput;
  NOT?: LogsSubscriptionWhereInput[] | LogsSubscriptionWhereInput;
}

export interface OldColleagueUpsertWithWhereUniqueWithoutToInput {
  where: OldColleagueWhereUniqueInput;
  update: OldColleagueUpdateWithoutToDataInput;
  create: OldColleagueCreateWithoutToInput;
}

export interface GroupSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: GroupWhereInput;
  AND?: GroupSubscriptionWhereInput[] | GroupSubscriptionWhereInput;
  OR?: GroupSubscriptionWhereInput[] | GroupSubscriptionWhereInput;
  NOT?: GroupSubscriptionWhereInput[] | GroupSubscriptionWhereInput;
}

export interface OldColleagueScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  status?: String;
  status_not?: String;
  status_in?: String[] | String;
  status_not_in?: String[] | String;
  status_lt?: String;
  status_lte?: String;
  status_gt?: String;
  status_gte?: String;
  status_contains?: String;
  status_not_contains?: String;
  status_starts_with?: String;
  status_not_starts_with?: String;
  status_ends_with?: String;
  status_not_ends_with?: String;
  AND?: OldColleagueScalarWhereInput[] | OldColleagueScalarWhereInput;
  OR?: OldColleagueScalarWhereInput[] | OldColleagueScalarWhereInput;
  NOT?: OldColleagueScalarWhereInput[] | OldColleagueScalarWhereInput;
}

export interface StreetWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  code?: String;
  code_not?: String;
  code_in?: String[] | String;
  code_not_in?: String[] | String;
  code_lt?: String;
  code_lte?: String;
  code_gt?: String;
  code_gte?: String;
  code_contains?: String;
  code_not_contains?: String;
  code_starts_with?: String;
  code_not_starts_with?: String;
  code_ends_with?: String;
  code_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  Area?: AreaWhereInput;
  villages_every?: VillageWhereInput;
  villages_some?: VillageWhereInput;
  villages_none?: VillageWhereInput;
  AND?: StreetWhereInput[] | StreetWhereInput;
  OR?: StreetWhereInput[] | StreetWhereInput;
  NOT?: StreetWhereInput[] | StreetWhereInput;
}

export interface OldColleagueUpdateManyWithWhereNestedInput {
  where: OldColleagueScalarWhereInput;
  data: OldColleagueUpdateManyDataInput;
}

export type ClassGroupWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface OldColleagueUpdateManyDataInput {
  status?: String;
}

export interface WorkCreateInput {
  startTime?: DateTimeInput;
  endTime?: DateTimeInput;
  company?: CompanyCreateOneWithoutWorksInput;
  department?: String;
  post?: StationCreateOneInput;
  jobContent?: String;
  worker?: UserCreateOneWithoutWorksInput;
}

export interface UserUpsertWithWhereUniqueWithoutRemmemberPasswordInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutRemmemberPasswordDataInput;
  create: UserCreateWithoutRemmemberPasswordInput;
}

export interface UniversityUpdateManyMutationInput {
  name?: String;
  education?: Educationkind;
  department?: String;
  location?: String;
  desc?: String;
}

export interface FindPassWordUpsertWithoutForgetterInput {
  update: FindPassWordUpdateWithoutForgetterDataInput;
  create: FindPassWordCreateWithoutForgetterInput;
}

export interface TradeUpdateInput {
  product?: ProductUpdateOneInput;
  number?: Int;
  amount?: Float;
  user?: UserUpdateOneWithoutTradesInput;
  status?: String;
}

export interface UserUpsertWithoutToOldColleaguesInput {
  update: UserUpdateWithoutToOldColleaguesDataInput;
  create: UserCreateWithoutToOldColleaguesInput;
}

export interface FeeSettingWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  fee?: Boolean;
  fee_not?: Boolean;
  AND?: FeeSettingWhereInput[] | FeeSettingWhereInput;
  OR?: FeeSettingWhereInput[] | FeeSettingWhereInput;
  NOT?: FeeSettingWhereInput[] | FeeSettingWhereInput;
}

export interface OldColleagueUpsertWithWhereUniqueWithoutFromInput {
  where: OldColleagueWhereUniqueInput;
  update: OldColleagueUpdateWithoutFromDataInput;
  create: OldColleagueCreateWithoutFromInput;
}

export interface UserUpdateWithWhereUniqueWithoutSkillsInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutSkillsDataInput;
}

export interface UserUpsertWithWhereUniqueWithoutFamilyGroupInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutFamilyGroupDataInput;
  create: UserCreateWithoutFamilyGroupInput;
}

export interface SchoolEduUpdateManyMutationInput {
  startTime?: DateTimeInput;
  grade?: Int;
  className?: String;
}

export interface FamilyGroupUpsertWithoutCreaterInput {
  update: FamilyGroupUpdateWithoutCreaterDataInput;
  create: FamilyGroupCreateWithoutCreaterInput;
}

export interface RegisterCountCreateInput {
  addUser?: UserCreateOneInput;
  deviceId?: String;
}

export interface UserUpsertWithWhereUniqueWithoutStudiesInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutStudiesDataInput;
  create: UserCreateWithoutStudiesInput;
}

export type LoveMatchingWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface SchoolEduUpsertNestedInput {
  update: SchoolEduUpdateDataInput;
  create: SchoolEduCreateInput;
}

export interface ProjectUpdateInput {
  name?: String;
  place?: CityUpdateOneInput;
  content?: String;
  conditions?: PartnerConditionUpdateManyWithoutProjectInput;
  starter?: UserUpdateOneWithoutProjectsInput;
}

export interface ClassGroupUpsertWithoutMembersInput {
  update: ClassGroupUpdateWithoutMembersDataInput;
  create: ClassGroupCreateWithoutMembersInput;
}

export interface UserUpsertWithoutPostsInput {
  update: UserUpdateWithoutPostsDataInput;
  create: UserCreateWithoutPostsInput;
}

export interface ClassMateUpsertWithWhereUniqueWithoutStudentInput {
  where: ClassMateWhereUniqueInput;
  update: ClassMateUpdateWithoutStudentDataInput;
  create: ClassMateCreateWithoutStudentInput;
}

export interface PostCreateInput {
  isPublished?: Boolean;
  title: String;
  content: String;
  author: UserCreateOneWithoutPostsInput;
}

export interface ClassMateScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  status?: String;
  status_not?: String;
  status_in?: String[] | String;
  status_not_in?: String[] | String;
  status_lt?: String;
  status_lte?: String;
  status_gt?: String;
  status_gte?: String;
  status_contains?: String;
  status_not_contains?: String;
  status_starts_with?: String;
  status_not_starts_with?: String;
  status_ends_with?: String;
  status_not_ends_with?: String;
  AND?: ClassMateScalarWhereInput[] | ClassMateScalarWhereInput;
  OR?: ClassMateScalarWhereInput[] | ClassMateScalarWhereInput;
  NOT?: ClassMateScalarWhereInput[] | ClassMateScalarWhereInput;
}

export interface PartnerConditionUpdateManyMutationInput {
  skillName?: String;
  place?: String;
  number?: Int;
}

export interface ClassMateUpdateManyWithWhereNestedInput {
  where: ClassMateScalarWhereInput;
  data: ClassMateUpdateManyDataInput;
}

export interface MessageUpdateInput {
  to?: UserUpdateOneRequiredWithoutReceiveMessagesInput;
  from?: UserUpdateOneRequiredWithoutSentMessagesInput;
  text?: String;
  image?: PhotoUpdateOneInput;
}

export interface ClassMateUpdateManyDataInput {
  status?: String;
}

export interface UserUpdateOneWithoutSignUpLoveInput {
  create?: UserCreateWithoutSignUpLoveInput;
  update?: UserUpdateWithoutSignUpLoveDataInput;
  upsert?: UserUpsertWithoutSignUpLoveInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface UserUpsertWithoutCreaterInput {
  update: UserUpdateWithoutCreaterDataInput;
  create: UserCreateWithoutCreaterInput;
}

export interface UserUpsertWithoutLoveSettingInput {
  update: UserUpdateWithoutLoveSettingDataInput;
  create: UserCreateWithoutLoveSettingInput;
}

export interface FamilyGroupUpsertWithWhereUniqueWithoutMotherInput {
  where: FamilyGroupWhereUniqueInput;
  update: FamilyGroupUpdateWithoutMotherDataInput;
  create: FamilyGroupCreateWithoutMotherInput;
}

export type RegisterCountWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface FamilyGroupScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: FamilyGroupScalarWhereInput[] | FamilyGroupScalarWhereInput;
  OR?: FamilyGroupScalarWhereInput[] | FamilyGroupScalarWhereInput;
  NOT?: FamilyGroupScalarWhereInput[] | FamilyGroupScalarWhereInput;
}

export interface LogsCreateInput {
  user?: UserCreateOneInput;
  createFamilyGroupTime?: DateTimeInput;
}

export interface FamilyGroupUpdateManyWithWhereNestedInput {
  where: FamilyGroupScalarWhereInput;
  data: FamilyGroupUpdateManyDataInput;
}

export interface LocationGroupUpdateInput {
  kind?: LocationGroupKind;
  code?: String;
  name?: String;
  users?: UserUpdateManyWithoutLocationGroupsInput;
}

export interface FamilyGroupUpdateManyDataInput {
  name?: String;
}

export type StreetWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  code?: String;
}>;

export interface PersonUpsertWithoutAsFatherInput {
  update: PersonUpdateWithoutAsFatherDataInput;
  create: PersonCreateWithoutAsFatherInput;
}

export type UniversityWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  name?: String;
}>;

export interface FamilyGroupUpsertWithoutUsersInput {
  update: FamilyGroupUpdateWithoutUsersDataInput;
  create: FamilyGroupCreateWithoutUsersInput;
}

export type VillageWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  code?: String;
}>;

export interface UserUpsertWithoutSentMessagesInput {
  update: UserUpdateWithoutSentMessagesDataInput;
  create: UserCreateWithoutSentMessagesInput;
}

export type WorkGroupWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface MessageUpsertWithWhereUniqueWithoutToInput {
  where: MessageWhereUniqueInput;
  update: MessageUpdateWithoutToDataInput;
  create: MessageCreateWithoutToInput;
}

export interface AdvertisementUpdateManyMutationInput {
  image1?: String;
  image2?: String;
  image3?: String;
  image4?: String;
  image5?: String;
  startTime?: DateTimeInput;
  endTime?: DateTimeInput;
}

export interface UserUpsertWithoutAvatarInput {
  update: UserUpdateWithoutAvatarDataInput;
  create: UserCreateWithoutAvatarInput;
}

export interface StreetCreateManyWithoutAreaInput {
  create?: StreetCreateWithoutAreaInput[] | StreetCreateWithoutAreaInput;
  connect?: StreetWhereUniqueInput[] | StreetWhereUniqueInput;
}

export interface PhotoUpsertNestedInput {
  update: PhotoUpdateDataInput;
  create: PhotoCreateInput;
}

export interface LocationCreateOneWithoutBornsInput {
  create?: LocationCreateWithoutBornsInput;
  connect?: LocationWhereUniqueInput;
}

export interface GroupMessageUpsertWithWhereUniqueWithoutFromInput {
  where: GroupMessageWhereUniqueInput;
  update: GroupMessageUpdateWithoutFromDataInput;
  create: GroupMessageCreateWithoutFromInput;
}

export interface CityCreateOneInput {
  create?: CityCreateInput;
  connect?: CityWhereUniqueInput;
}

export interface GroupMessageScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  type?: GroupKind;
  type_not?: GroupKind;
  type_in?: GroupKind[] | GroupKind;
  type_not_in?: GroupKind[] | GroupKind;
  to?: String;
  to_not?: String;
  to_in?: String[] | String;
  to_not_in?: String[] | String;
  to_lt?: String;
  to_lte?: String;
  to_gt?: String;
  to_gte?: String;
  to_contains?: String;
  to_not_contains?: String;
  to_starts_with?: String;
  to_not_starts_with?: String;
  to_ends_with?: String;
  to_not_ends_with?: String;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  AND?: GroupMessageScalarWhereInput[] | GroupMessageScalarWhereInput;
  OR?: GroupMessageScalarWhereInput[] | GroupMessageScalarWhereInput;
  NOT?: GroupMessageScalarWhereInput[] | GroupMessageScalarWhereInput;
}

export interface VillageCreateInput {
  code: String;
  name: String;
  street: StreetCreateOneWithoutVillagesInput;
  people?: UserCreateManyInput;
}

export interface GroupMessageUpdateManyWithWhereNestedInput {
  where: GroupMessageScalarWhereInput;
  data: GroupMessageUpdateManyDataInput;
}

export interface WorkCreateWithoutCompanyInput {
  startTime?: DateTimeInput;
  endTime?: DateTimeInput;
  department?: String;
  post?: StationCreateOneInput;
  jobContent?: String;
  worker?: UserCreateOneWithoutWorksInput;
}

export interface GroupMessageUpdateManyDataInput {
  type?: GroupKind;
  to?: String;
  text?: String;
}

export interface UniversityCreateInput {
  name: String;
  education: Educationkind;
  department?: String;
  location?: String;
  desc?: String;
}

export interface UserUpsertWithoutReceiveMessagesInput {
  update: UserUpdateWithoutReceiveMessagesDataInput;
  create: UserCreateWithoutReceiveMessagesInput;
}

export interface MajorCreateOneInput {
  create?: MajorCreateInput;
  connect?: MajorWhereUniqueInput;
}

export interface MessageUpsertWithWhereUniqueWithoutFromInput {
  where: MessageWhereUniqueInput;
  update: MessageUpdateWithoutFromDataInput;
  create: MessageCreateWithoutFromInput;
}

export interface FamilyGroupCreateWithoutFatherInput {
  mother?: PersonCreateOneWithoutAsMotherInput;
  creater?: UserCreateOneWithoutCreaterInput;
  name?: String;
  families?: FamilyCreateManyInput;
  users?: UserCreateManyWithoutFamilyGroupInput;
}

export interface UserUpsertWithoutColleaguesInput {
  update: UserUpdateWithoutColleaguesDataInput;
  create: UserCreateWithoutColleaguesInput;
}

export interface SchoolEduCreateWithoutStudentsInput {
  school?: SchoolCreateOneInput;
  startTime?: DateTimeInput;
  major?: MajorCreateOneInput;
  grade?: Int;
  className?: String;
}

export interface ColleagueUpsertWithWhereUniqueWithoutGroupInput {
  where: ColleagueWhereUniqueInput;
  update: ColleagueUpdateWithoutGroupDataInput;
  create: ColleagueCreateWithoutGroupInput;
}

export interface WorkCreateWithoutWorkerInput {
  startTime?: DateTimeInput;
  endTime?: DateTimeInput;
  company?: CompanyCreateOneWithoutWorksInput;
  department?: String;
  post?: StationCreateOneInput;
  jobContent?: String;
}

export interface WorkGroupUpsertWithoutCompanyInput {
  update: WorkGroupUpdateWithoutCompanyDataInput;
  create: WorkGroupCreateWithoutCompanyInput;
}

export interface ColleagueCreateWithoutGroupInput {
  worker?: UserCreateOneWithoutColleaguesInput;
  status: String;
}

export interface CompanyUpsertWithoutWorksInput {
  update: CompanyUpdateWithoutWorksDataInput;
  create: CompanyCreateWithoutWorksInput;
}

export interface UserCreateWithoutReceiveMessagesInput {
  username: String;
  password: String;
  name?: String;
  gender?: String;
  avatar?: PhotoCreateOneWithoutUserInput;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationCreateOneWithoutBornsInput;
  residence?: LocationCreateOneWithoutLivesInput;
  uid: String;
  token: String;
  posts?: PostCreateManyWithoutAuthorInput;
  regStatus?: RegStatusCreateOneWithoutApplicantsInput;
  regTimes?: Int;
  maxRegTimes?: Int;
  families?: FamilyCreateManyWithoutFromInput;
  studies?: SchoolEduCreateManyWithoutStudentsInput;
  works?: WorkCreateManyWithoutWorkerInput;
  exam?: CollegeEntranceExamCreateOneWithoutStudentInput;
  sentMessages?: MessageCreateManyWithoutFromInput;
  groupMessages?: GroupMessageCreateManyWithoutFromInput;
  groups?: GroupCreateManyWithoutUsersInput;
  friends?: UserCreateManyInput;
  familyGroup?: FamilyGroupCreateOneWithoutUsersInput;
  creater?: FamilyGroupCreateOneWithoutCreaterInput;
  classMate?: ClassMateCreateManyWithoutStudentInput;
  workGroup?: WorkGroupCreateOneInput;
  colleagues?: ColleagueCreateManyWithoutWorkerInput;
  fromOldColleagues?: OldColleagueCreateManyWithoutFromInput;
  toOldColleagues?: OldColleagueCreateManyWithoutToInput;
  locationGroups?: LocationGroupCreateManyWithoutUsersInput;
  forgetPassword?: FindPassWordCreateOneWithoutForgetterInput;
  remmemberPassword?: FindPassWordCreateManyWithoutRemmemberInput;
  loveSetting?: LoveSettingCreateOneWithoutUserInput;
  loveWoman?: LoveMatchingCreateManyWithoutWomanInput;
  loveMan?: LoveMatchingCreateManyWithoutManInput;
  signUpLove?: LoveSignUpCreateOneWithoutPersonInput;
  skills?: SkillCreateManyWithoutPersonsInput;
  fitConditions?: PartnerConditionCreateManyWithoutPartnersInput;
  nofitConditions?: PartnerConditionCreateManyWithoutPassedPartnersInput;
  projects?: ProjectCreateManyWithoutStarterInput;
  trades?: TradeCreateManyWithoutUserInput;
}

export interface WorkUpsertWithWhereUniqueWithoutWorkerInput {
  where: WorkWhereUniqueInput;
  update: WorkUpdateWithoutWorkerDataInput;
  create: WorkCreateWithoutWorkerInput;
}

export interface MessageCreateWithoutToInput {
  from: UserCreateOneWithoutSentMessagesInput;
  text?: String;
  image?: PhotoCreateOneInput;
}

export interface WorkScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  startTime?: DateTimeInput;
  startTime_not?: DateTimeInput;
  startTime_in?: DateTimeInput[] | DateTimeInput;
  startTime_not_in?: DateTimeInput[] | DateTimeInput;
  startTime_lt?: DateTimeInput;
  startTime_lte?: DateTimeInput;
  startTime_gt?: DateTimeInput;
  startTime_gte?: DateTimeInput;
  endTime?: DateTimeInput;
  endTime_not?: DateTimeInput;
  endTime_in?: DateTimeInput[] | DateTimeInput;
  endTime_not_in?: DateTimeInput[] | DateTimeInput;
  endTime_lt?: DateTimeInput;
  endTime_lte?: DateTimeInput;
  endTime_gt?: DateTimeInput;
  endTime_gte?: DateTimeInput;
  department?: String;
  department_not?: String;
  department_in?: String[] | String;
  department_not_in?: String[] | String;
  department_lt?: String;
  department_lte?: String;
  department_gt?: String;
  department_gte?: String;
  department_contains?: String;
  department_not_contains?: String;
  department_starts_with?: String;
  department_not_starts_with?: String;
  department_ends_with?: String;
  department_not_ends_with?: String;
  jobContent?: String;
  jobContent_not?: String;
  jobContent_in?: String[] | String;
  jobContent_not_in?: String[] | String;
  jobContent_lt?: String;
  jobContent_lte?: String;
  jobContent_gt?: String;
  jobContent_gte?: String;
  jobContent_contains?: String;
  jobContent_not_contains?: String;
  jobContent_starts_with?: String;
  jobContent_not_starts_with?: String;
  jobContent_ends_with?: String;
  jobContent_not_ends_with?: String;
  AND?: WorkScalarWhereInput[] | WorkScalarWhereInput;
  OR?: WorkScalarWhereInput[] | WorkScalarWhereInput;
  NOT?: WorkScalarWhereInput[] | WorkScalarWhereInput;
}

export interface FamilyGroupCreateWithoutUsersInput {
  father?: PersonCreateOneWithoutAsFatherInput;
  mother?: PersonCreateOneWithoutAsMotherInput;
  creater?: UserCreateOneWithoutCreaterInput;
  name?: String;
  families?: FamilyCreateManyInput;
}

export interface WorkUpdateManyWithWhereNestedInput {
  where: WorkScalarWhereInput;
  data: WorkUpdateManyDataInput;
}

export interface ClassMateCreateWithoutStudentInput {
  status: String;
  group: ClassGroupCreateOneWithoutMembersInput;
}

export interface WorkUpdateManyDataInput {
  startTime?: DateTimeInput;
  endTime?: DateTimeInput;
  department?: String;
  jobContent?: String;
}

export interface FamilyGroupCreateWithoutCreaterInput {
  father?: PersonCreateOneWithoutAsFatherInput;
  mother?: PersonCreateOneWithoutAsMotherInput;
  name?: String;
  families?: FamilyCreateManyInput;
  users?: UserCreateManyWithoutFamilyGroupInput;
}

export interface UserUpsertWithWhereUniqueWithoutResidenceInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutResidenceDataInput;
  create: UserCreateWithoutResidenceInput;
}

export interface CompanyCreateOneWithoutWorkGroupInput {
  create?: CompanyCreateWithoutWorkGroupInput;
  connect?: CompanyWhereUniqueInput;
}

export interface LocationUpsertWithoutSchoolsInput {
  update: LocationUpdateWithoutSchoolsDataInput;
  create: LocationCreateWithoutSchoolsInput;
}

export interface UserCreateOneWithoutToOldColleaguesInput {
  create?: UserCreateWithoutToOldColleaguesInput;
  connect?: UserWhereUniqueInput;
}

export interface SchoolUpsertNestedInput {
  update: SchoolUpdateDataInput;
  create: SchoolCreateInput;
}

export interface OldColleagueCreateManyWithoutToInput {
  create?:
    | OldColleagueCreateWithoutToInput[]
    | OldColleagueCreateWithoutToInput;
  connect?: OldColleagueWhereUniqueInput[] | OldColleagueWhereUniqueInput;
}

export interface SchoolEduUpsertWithWhereUniqueWithoutStudentsInput {
  where: SchoolEduWhereUniqueInput;
  update: SchoolEduUpdateWithoutStudentsDataInput;
  create: SchoolEduCreateWithoutStudentsInput;
}

export interface LoveSettingCreateOneWithoutUserInput {
  create?: LoveSettingCreateWithoutUserInput;
  connect?: LoveSettingWhereUniqueInput;
}

export interface SchoolEduScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  startTime?: DateTimeInput;
  startTime_not?: DateTimeInput;
  startTime_in?: DateTimeInput[] | DateTimeInput;
  startTime_not_in?: DateTimeInput[] | DateTimeInput;
  startTime_lt?: DateTimeInput;
  startTime_lte?: DateTimeInput;
  startTime_gt?: DateTimeInput;
  startTime_gte?: DateTimeInput;
  grade?: Int;
  grade_not?: Int;
  grade_in?: Int[] | Int;
  grade_not_in?: Int[] | Int;
  grade_lt?: Int;
  grade_lte?: Int;
  grade_gt?: Int;
  grade_gte?: Int;
  className?: String;
  className_not?: String;
  className_in?: String[] | String;
  className_not_in?: String[] | String;
  className_lt?: String;
  className_lte?: String;
  className_gt?: String;
  className_gte?: String;
  className_contains?: String;
  className_not_contains?: String;
  className_starts_with?: String;
  className_not_starts_with?: String;
  className_ends_with?: String;
  className_not_ends_with?: String;
  AND?: SchoolEduScalarWhereInput[] | SchoolEduScalarWhereInput;
  OR?: SchoolEduScalarWhereInput[] | SchoolEduScalarWhereInput;
  NOT?: SchoolEduScalarWhereInput[] | SchoolEduScalarWhereInput;
}

export interface SkillCreateManyWithoutPersonsInput {
  create?: SkillCreateWithoutPersonsInput[] | SkillCreateWithoutPersonsInput;
  connect?: SkillWhereUniqueInput[] | SkillWhereUniqueInput;
}

export interface SchoolEduUpdateManyWithWhereNestedInput {
  where: SchoolEduScalarWhereInput;
  data: SchoolEduUpdateManyDataInput;
}

export interface UserCreateOneWithoutLoveWomanInput {
  create?: UserCreateWithoutLoveWomanInput;
  connect?: UserWhereUniqueInput;
}

export interface SchoolEduUpdateManyDataInput {
  startTime?: DateTimeInput;
  grade?: Int;
  className?: String;
}

export interface PartnerConditionCreateManyWithoutProjectInput {
  create?:
    | PartnerConditionCreateWithoutProjectInput[]
    | PartnerConditionCreateWithoutProjectInput;
  connect?:
    | PartnerConditionWhereUniqueInput[]
    | PartnerConditionWhereUniqueInput;
}

export interface UserUpsertWithoutFamiliesInput {
  update: UserUpdateWithoutFamiliesDataInput;
  create: UserCreateWithoutFamiliesInput;
}

export interface UserCreateOneWithoutProjectsInput {
  create?: UserCreateWithoutProjectsInput;
  connect?: UserWhereUniqueInput;
}

export interface FamilyUpsertWithWhereUniqueWithoutToInput {
  where: FamilyWhereUniqueInput;
  update: FamilyUpdateWithoutToDataInput;
  create: FamilyCreateWithoutToInput;
}

export interface UniversitySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UniversityWhereInput;
  AND?: UniversitySubscriptionWhereInput[] | UniversitySubscriptionWhereInput;
  OR?: UniversitySubscriptionWhereInput[] | UniversitySubscriptionWhereInput;
  NOT?: UniversitySubscriptionWhereInput[] | UniversitySubscriptionWhereInput;
}

export interface PersonUpsertWithoutAsMotherInput {
  update: PersonUpdateWithoutAsMotherDataInput;
  create: PersonCreateWithoutAsMotherInput;
}

export interface ProjectSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ProjectWhereInput;
  AND?: ProjectSubscriptionWhereInput[] | ProjectSubscriptionWhereInput;
  OR?: ProjectSubscriptionWhereInput[] | ProjectSubscriptionWhereInput;
  NOT?: ProjectSubscriptionWhereInput[] | ProjectSubscriptionWhereInput;
}

export interface FamilyGroupUpsertWithWhereUniqueWithoutFatherInput {
  where: FamilyGroupWhereUniqueInput;
  update: FamilyGroupUpdateWithoutFatherDataInput;
  create: FamilyGroupCreateWithoutFatherInput;
}

export interface CompanyWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  code?: String;
  code_not?: String;
  code_in?: String[] | String;
  code_not_in?: String[] | String;
  code_lt?: String;
  code_lte?: String;
  code_gt?: String;
  code_gte?: String;
  code_contains?: String;
  code_not_contains?: String;
  code_starts_with?: String;
  code_not_starts_with?: String;
  code_ends_with?: String;
  code_not_ends_with?: String;
  establishmentDate?: DateTimeInput;
  establishmentDate_not?: DateTimeInput;
  establishmentDate_in?: DateTimeInput[] | DateTimeInput;
  establishmentDate_not_in?: DateTimeInput[] | DateTimeInput;
  establishmentDate_lt?: DateTimeInput;
  establishmentDate_lte?: DateTimeInput;
  establishmentDate_gt?: DateTimeInput;
  establishmentDate_gte?: DateTimeInput;
  representative?: String;
  representative_not?: String;
  representative_in?: String[] | String;
  representative_not_in?: String[] | String;
  representative_lt?: String;
  representative_lte?: String;
  representative_gt?: String;
  representative_gte?: String;
  representative_contains?: String;
  representative_not_contains?: String;
  representative_starts_with?: String;
  representative_not_starts_with?: String;
  representative_ends_with?: String;
  representative_not_ends_with?: String;
  location?: LocationWhereInput;
  BusinessScope?: String;
  BusinessScope_not?: String;
  BusinessScope_in?: String[] | String;
  BusinessScope_not_in?: String[] | String;
  BusinessScope_lt?: String;
  BusinessScope_lte?: String;
  BusinessScope_gt?: String;
  BusinessScope_gte?: String;
  BusinessScope_contains?: String;
  BusinessScope_not_contains?: String;
  BusinessScope_starts_with?: String;
  BusinessScope_not_starts_with?: String;
  BusinessScope_ends_with?: String;
  BusinessScope_not_ends_with?: String;
  works_every?: WorkWhereInput;
  works_some?: WorkWhereInput;
  works_none?: WorkWhereInput;
  workGroup?: WorkGroupWhereInput;
  AND?: CompanyWhereInput[] | CompanyWhereInput;
  OR?: CompanyWhereInput[] | CompanyWhereInput;
  NOT?: CompanyWhereInput[] | CompanyWhereInput;
}

export interface PersonUpsertWithoutFamiliesInput {
  update: PersonUpdateWithoutFamiliesDataInput;
  create: PersonCreateWithoutFamiliesInput;
}

export interface FamilySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: FamilyWhereInput;
  AND?: FamilySubscriptionWhereInput[] | FamilySubscriptionWhereInput;
  OR?: FamilySubscriptionWhereInput[] | FamilySubscriptionWhereInput;
  NOT?: FamilySubscriptionWhereInput[] | FamilySubscriptionWhereInput;
}

export interface FamilyUpsertWithWhereUniqueWithoutFromInput {
  where: FamilyWhereUniqueInput;
  update: FamilyUpdateWithoutFromDataInput;
  create: FamilyCreateWithoutFromInput;
}

export interface WorkGroupUpdateInput {
  company?: CompanyUpdateOneWithoutWorkGroupInput;
  colleagues?: ColleagueUpdateManyWithoutGroupInput;
}

export interface UserUpsertWithWhereUniqueWithoutBirthplaceInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutBirthplaceDataInput;
  create: UserCreateWithoutBirthplaceInput;
}

export interface UserUpsertWithoutTradesInput {
  update: UserUpdateWithoutTradesDataInput;
  create: UserCreateWithoutTradesInput;
}

export interface LocationUpsertWithoutLivesInput {
  update: LocationUpdateWithoutLivesDataInput;
  create: LocationCreateWithoutLivesInput;
}

export interface SkillUpdateManyMutationInput {
  name?: String;
}

export interface UserUpsertWithoutWorksInput {
  update: UserUpdateWithoutWorksDataInput;
  create: UserCreateWithoutWorksInput;
}

export interface SchoolUpdateInput {
  name?: String;
  kind?: Educationkind;
  location?: LocationUpdateOneWithoutSchoolsInput;
}

export interface WorkUpsertWithWhereUniqueWithoutCompanyInput {
  where: WorkWhereUniqueInput;
  update: WorkUpdateWithoutCompanyDataInput;
  create: WorkCreateWithoutCompanyInput;
}

export type LoveSettingWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CompanyUpsertWithWhereUniqueWithoutLocationInput {
  where: CompanyWhereUniqueInput;
  update: CompanyUpdateWithoutLocationDataInput;
  create: CompanyCreateWithoutLocationInput;
}

export interface PostUpdateInput {
  isPublished?: Boolean;
  title?: String;
  content?: String;
  author?: UserUpdateOneRequiredWithoutPostsInput;
}

export interface CompanyScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  code?: String;
  code_not?: String;
  code_in?: String[] | String;
  code_not_in?: String[] | String;
  code_lt?: String;
  code_lte?: String;
  code_gt?: String;
  code_gte?: String;
  code_contains?: String;
  code_not_contains?: String;
  code_starts_with?: String;
  code_not_starts_with?: String;
  code_ends_with?: String;
  code_not_ends_with?: String;
  establishmentDate?: DateTimeInput;
  establishmentDate_not?: DateTimeInput;
  establishmentDate_in?: DateTimeInput[] | DateTimeInput;
  establishmentDate_not_in?: DateTimeInput[] | DateTimeInput;
  establishmentDate_lt?: DateTimeInput;
  establishmentDate_lte?: DateTimeInput;
  establishmentDate_gt?: DateTimeInput;
  establishmentDate_gte?: DateTimeInput;
  representative?: String;
  representative_not?: String;
  representative_in?: String[] | String;
  representative_not_in?: String[] | String;
  representative_lt?: String;
  representative_lte?: String;
  representative_gt?: String;
  representative_gte?: String;
  representative_contains?: String;
  representative_not_contains?: String;
  representative_starts_with?: String;
  representative_not_starts_with?: String;
  representative_ends_with?: String;
  representative_not_ends_with?: String;
  BusinessScope?: String;
  BusinessScope_not?: String;
  BusinessScope_in?: String[] | String;
  BusinessScope_not_in?: String[] | String;
  BusinessScope_lt?: String;
  BusinessScope_lte?: String;
  BusinessScope_gt?: String;
  BusinessScope_gte?: String;
  BusinessScope_contains?: String;
  BusinessScope_not_contains?: String;
  BusinessScope_starts_with?: String;
  BusinessScope_not_starts_with?: String;
  BusinessScope_ends_with?: String;
  BusinessScope_not_ends_with?: String;
  AND?: CompanyScalarWhereInput[] | CompanyScalarWhereInput;
  OR?: CompanyScalarWhereInput[] | CompanyScalarWhereInput;
  NOT?: CompanyScalarWhereInput[] | CompanyScalarWhereInput;
}

export type PhotoWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  name?: String;
}>;

export interface CompanyUpdateManyWithWhereNestedInput {
  where: CompanyScalarWhereInput;
  data: CompanyUpdateManyDataInput;
}

export interface UserCreateOneWithoutSignUpLoveInput {
  create?: UserCreateWithoutSignUpLoveInput;
  connect?: UserWhereUniqueInput;
}

export interface CompanyUpdateManyDataInput {
  name?: String;
  code?: String;
  establishmentDate?: DateTimeInput;
  representative?: String;
  BusinessScope?: String;
}

export interface LoveMatchingUpdateInput {
  period?: String;
  city?: CityUpdateOneInput;
  woman?: UserUpdateOneWithoutLoveWomanInput;
  man?: UserUpdateOneWithoutLoveManInput;
}

export interface LocationUpsertWithoutBornsInput {
  update: LocationUpdateWithoutBornsDataInput;
  create: LocationCreateWithoutBornsInput;
}

export interface LocationGroupCreateInput {
  kind?: LocationGroupKind;
  code?: String;
  name?: String;
  users?: UserCreateManyWithoutLocationGroupsInput;
}

export interface UserUpsertWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput;
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  username?: String;
  uid?: String;
  token?: String;
}>;

export interface VillageUpsertWithWhereUniqueWithoutStreetInput {
  where: VillageWhereUniqueInput;
  update: VillageUpdateWithoutStreetDataInput;
  create: VillageCreateWithoutStreetInput;
}

export interface FeeSettingUpdateInput {
  name?: String;
  fee?: Boolean;
}

export interface VillageScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  code?: String;
  code_not?: String;
  code_in?: String[] | String;
  code_not_in?: String[] | String;
  code_lt?: String;
  code_lte?: String;
  code_gt?: String;
  code_gte?: String;
  code_contains?: String;
  code_not_contains?: String;
  code_starts_with?: String;
  code_not_starts_with?: String;
  code_ends_with?: String;
  code_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: VillageScalarWhereInput[] | VillageScalarWhereInput;
  OR?: VillageScalarWhereInput[] | VillageScalarWhereInput;
  NOT?: VillageScalarWhereInput[] | VillageScalarWhereInput;
}

export interface UserCreateManyInput {
  create?: UserCreateInput[] | UserCreateInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface VillageUpdateManyWithWhereNestedInput {
  where: VillageScalarWhereInput;
  data: VillageUpdateManyDataInput;
}

export interface StreetCreateInput {
  code: String;
  name: String;
  Area: AreaCreateOneWithoutTownsInput;
  villages?: VillageCreateManyWithoutStreetInput;
}

export interface VillageUpdateManyDataInput {
  code?: String;
  name?: String;
}

export interface UserCreateWithoutWorksInput {
  username: String;
  password: String;
  name?: String;
  gender?: String;
  avatar?: PhotoCreateOneWithoutUserInput;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationCreateOneWithoutBornsInput;
  residence?: LocationCreateOneWithoutLivesInput;
  uid: String;
  token: String;
  posts?: PostCreateManyWithoutAuthorInput;
  regStatus?: RegStatusCreateOneWithoutApplicantsInput;
  regTimes?: Int;
  maxRegTimes?: Int;
  families?: FamilyCreateManyWithoutFromInput;
  studies?: SchoolEduCreateManyWithoutStudentsInput;
  exam?: CollegeEntranceExamCreateOneWithoutStudentInput;
  sentMessages?: MessageCreateManyWithoutFromInput;
  receiveMessages?: MessageCreateManyWithoutToInput;
  groupMessages?: GroupMessageCreateManyWithoutFromInput;
  groups?: GroupCreateManyWithoutUsersInput;
  friends?: UserCreateManyInput;
  familyGroup?: FamilyGroupCreateOneWithoutUsersInput;
  creater?: FamilyGroupCreateOneWithoutCreaterInput;
  classMate?: ClassMateCreateManyWithoutStudentInput;
  workGroup?: WorkGroupCreateOneInput;
  colleagues?: ColleagueCreateManyWithoutWorkerInput;
  fromOldColleagues?: OldColleagueCreateManyWithoutFromInput;
  toOldColleagues?: OldColleagueCreateManyWithoutToInput;
  locationGroups?: LocationGroupCreateManyWithoutUsersInput;
  forgetPassword?: FindPassWordCreateOneWithoutForgetterInput;
  remmemberPassword?: FindPassWordCreateManyWithoutRemmemberInput;
  loveSetting?: LoveSettingCreateOneWithoutUserInput;
  loveWoman?: LoveMatchingCreateManyWithoutWomanInput;
  loveMan?: LoveMatchingCreateManyWithoutManInput;
  signUpLove?: LoveSignUpCreateOneWithoutPersonInput;
  skills?: SkillCreateManyWithoutPersonsInput;
  fitConditions?: PartnerConditionCreateManyWithoutPartnersInput;
  nofitConditions?: PartnerConditionCreateManyWithoutPassedPartnersInput;
  projects?: ProjectCreateManyWithoutStarterInput;
  trades?: TradeCreateManyWithoutUserInput;
}

export interface StreetUpsertWithWhereUniqueWithoutAreaInput {
  where: StreetWhereUniqueInput;
  update: StreetUpdateWithoutAreaDataInput;
  create: StreetCreateWithoutAreaInput;
}

export interface PersonCreateOneWithoutFamiliesInput {
  create?: PersonCreateWithoutFamiliesInput;
  connect?: PersonWhereUniqueInput;
}

export interface StreetScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  code?: String;
  code_not?: String;
  code_in?: String[] | String;
  code_not_in?: String[] | String;
  code_lt?: String;
  code_lte?: String;
  code_gt?: String;
  code_gte?: String;
  code_contains?: String;
  code_not_contains?: String;
  code_starts_with?: String;
  code_not_starts_with?: String;
  code_ends_with?: String;
  code_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: StreetScalarWhereInput[] | StreetScalarWhereInput;
  OR?: StreetScalarWhereInput[] | StreetScalarWhereInput;
  NOT?: StreetScalarWhereInput[] | StreetScalarWhereInput;
}

export interface LocationCreateWithoutSchoolsInput {
  name?: String;
  province?: ProvinceCreateOneInput;
  city?: CityCreateOneInput;
  area?: AreaCreateOneInput;
  street?: StreetCreateOneInput;
  village?: VillageCreateOneInput;
  companies?: CompanyCreateManyWithoutLocationInput;
  universities?: UniversityCreateManyInput;
  borns?: UserCreateManyWithoutBirthplaceInput;
  lives?: UserCreateManyWithoutResidenceInput;
}

export interface StreetUpdateManyWithWhereNestedInput {
  where: StreetScalarWhereInput;
  data: StreetUpdateManyDataInput;
}

export interface CollegeEntranceExamCreateWithoutStudentInput {
  province: ProvinceCreateOneInput;
  subject: String;
  culscore: Float;
  proscore?: Float;
  candidatenum: String;
  times?: Int;
}

export interface StreetUpdateManyDataInput {
  code?: String;
  name?: String;
}

export interface GroupCreateWithoutUsersInput {
  type?: GroupKind;
  name?: String;
  messages?: MessageCreateManyInput;
}

export interface AreaUpdateManyMutationInput {
  code?: String;
  name?: String;
}

export interface SchoolEduCreateInput {
  school?: SchoolCreateOneInput;
  startTime?: DateTimeInput;
  major?: MajorCreateOneInput;
  grade?: Int;
  className?: String;
  students?: UserCreateManyWithoutStudiesInput;
}

export interface BootCountCreateInput {
  bootUser?: UserCreateOneInput;
}

export interface WorkGroupCreateOneWithoutColleaguesInput {
  create?: WorkGroupCreateWithoutColleaguesInput;
  connect?: WorkGroupWhereUniqueInput;
}

export interface BootCountUpdateInput {
  bootUser?: UserUpdateOneInput;
}

export interface FindPassWordCreateManyWithoutRemmemberInput {
  create?:
    | FindPassWordCreateWithoutRemmemberInput[]
    | FindPassWordCreateWithoutRemmemberInput;
  connect?: FindPassWordWhereUniqueInput[] | FindPassWordWhereUniqueInput;
}

export interface CityUpdateInput {
  code?: String;
  name?: String;
  province?: ProvinceUpdateOneRequiredWithoutCitiesInput;
  areas?: AreaUpdateManyWithoutCityInput;
}

export interface UserCreateManyWithoutNofitConditionsInput {
  create?:
    | UserCreateWithoutNofitConditionsInput[]
    | UserCreateWithoutNofitConditionsInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface CityUpdateManyMutationInput {
  code?: String;
  name?: String;
}

export interface ProductCreateOneInput {
  create?: ProductCreateInput;
  connect?: ProductWhereUniqueInput;
}

export interface ClassGroupCreateInput {
  study?: SchoolEduCreateOneInput;
  name?: String;
  members?: ClassMateCreateManyWithoutGroupInput;
}

export interface SchoolEduSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SchoolEduWhereInput;
  AND?: SchoolEduSubscriptionWhereInput[] | SchoolEduSubscriptionWhereInput;
  OR?: SchoolEduSubscriptionWhereInput[] | SchoolEduSubscriptionWhereInput;
  NOT?: SchoolEduSubscriptionWhereInput[] | SchoolEduSubscriptionWhereInput;
}

export interface ClassMateCreateManyWithoutGroupInput {
  create?:
    | ClassMateCreateWithoutGroupInput[]
    | ClassMateCreateWithoutGroupInput;
  connect?: ClassMateWhereUniqueInput[] | ClassMateWhereUniqueInput;
}

export interface LocationSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: LocationWhereInput;
  AND?: LocationSubscriptionWhereInput[] | LocationSubscriptionWhereInput;
  OR?: LocationSubscriptionWhereInput[] | LocationSubscriptionWhereInput;
  NOT?: LocationSubscriptionWhereInput[] | LocationSubscriptionWhereInput;
}

export interface ClassMateCreateWithoutGroupInput {
  student?: UserCreateOneWithoutClassMateInput;
  status: String;
}

export interface UserUpdateManyMutationInput {
  username?: String;
  password?: String;
  name?: String;
  gender?: String;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  uid?: String;
  token?: String;
  regTimes?: Int;
  maxRegTimes?: Int;
}

export interface UserCreateOneWithoutClassMateInput {
  create?: UserCreateWithoutClassMateInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateWithoutSkillsInput {
  username: String;
  password: String;
  name?: String;
  gender?: String;
  avatar?: PhotoCreateOneWithoutUserInput;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationCreateOneWithoutBornsInput;
  residence?: LocationCreateOneWithoutLivesInput;
  uid: String;
  token: String;
  posts?: PostCreateManyWithoutAuthorInput;
  regStatus?: RegStatusCreateOneWithoutApplicantsInput;
  regTimes?: Int;
  maxRegTimes?: Int;
  families?: FamilyCreateManyWithoutFromInput;
  studies?: SchoolEduCreateManyWithoutStudentsInput;
  works?: WorkCreateManyWithoutWorkerInput;
  exam?: CollegeEntranceExamCreateOneWithoutStudentInput;
  sentMessages?: MessageCreateManyWithoutFromInput;
  receiveMessages?: MessageCreateManyWithoutToInput;
  groupMessages?: GroupMessageCreateManyWithoutFromInput;
  groups?: GroupCreateManyWithoutUsersInput;
  friends?: UserCreateManyInput;
  familyGroup?: FamilyGroupCreateOneWithoutUsersInput;
  creater?: FamilyGroupCreateOneWithoutCreaterInput;
  classMate?: ClassMateCreateManyWithoutStudentInput;
  workGroup?: WorkGroupCreateOneInput;
  colleagues?: ColleagueCreateManyWithoutWorkerInput;
  fromOldColleagues?: OldColleagueCreateManyWithoutFromInput;
  toOldColleagues?: OldColleagueCreateManyWithoutToInput;
  locationGroups?: LocationGroupCreateManyWithoutUsersInput;
  forgetPassword?: FindPassWordCreateOneWithoutForgetterInput;
  remmemberPassword?: FindPassWordCreateManyWithoutRemmemberInput;
  loveSetting?: LoveSettingCreateOneWithoutUserInput;
  loveWoman?: LoveMatchingCreateManyWithoutWomanInput;
  loveMan?: LoveMatchingCreateManyWithoutManInput;
  signUpLove?: LoveSignUpCreateOneWithoutPersonInput;
  fitConditions?: PartnerConditionCreateManyWithoutPartnersInput;
  nofitConditions?: PartnerConditionCreateManyWithoutPassedPartnersInput;
  projects?: ProjectCreateManyWithoutStarterInput;
  trades?: TradeCreateManyWithoutUserInput;
}

export interface UserCreateWithoutClassMateInput {
  username: String;
  password: String;
  name?: String;
  gender?: String;
  avatar?: PhotoCreateOneWithoutUserInput;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationCreateOneWithoutBornsInput;
  residence?: LocationCreateOneWithoutLivesInput;
  uid: String;
  token: String;
  posts?: PostCreateManyWithoutAuthorInput;
  regStatus?: RegStatusCreateOneWithoutApplicantsInput;
  regTimes?: Int;
  maxRegTimes?: Int;
  families?: FamilyCreateManyWithoutFromInput;
  studies?: SchoolEduCreateManyWithoutStudentsInput;
  works?: WorkCreateManyWithoutWorkerInput;
  exam?: CollegeEntranceExamCreateOneWithoutStudentInput;
  sentMessages?: MessageCreateManyWithoutFromInput;
  receiveMessages?: MessageCreateManyWithoutToInput;
  groupMessages?: GroupMessageCreateManyWithoutFromInput;
  groups?: GroupCreateManyWithoutUsersInput;
  friends?: UserCreateManyInput;
  familyGroup?: FamilyGroupCreateOneWithoutUsersInput;
  creater?: FamilyGroupCreateOneWithoutCreaterInput;
  workGroup?: WorkGroupCreateOneInput;
  colleagues?: ColleagueCreateManyWithoutWorkerInput;
  fromOldColleagues?: OldColleagueCreateManyWithoutFromInput;
  toOldColleagues?: OldColleagueCreateManyWithoutToInput;
  locationGroups?: LocationGroupCreateManyWithoutUsersInput;
  forgetPassword?: FindPassWordCreateOneWithoutForgetterInput;
  remmemberPassword?: FindPassWordCreateManyWithoutRemmemberInput;
  loveSetting?: LoveSettingCreateOneWithoutUserInput;
  loveWoman?: LoveMatchingCreateManyWithoutWomanInput;
  loveMan?: LoveMatchingCreateManyWithoutManInput;
  signUpLove?: LoveSignUpCreateOneWithoutPersonInput;
  skills?: SkillCreateManyWithoutPersonsInput;
  fitConditions?: PartnerConditionCreateManyWithoutPartnersInput;
  nofitConditions?: PartnerConditionCreateManyWithoutPassedPartnersInput;
  projects?: ProjectCreateManyWithoutStarterInput;
  trades?: TradeCreateManyWithoutUserInput;
}

export interface ProductUpdateManyMutationInput {
  subject?: String;
  info?: String;
  price?: Float;
  kind?: String;
}

export interface ClassGroupUpdateInput {
  study?: SchoolEduUpdateOneInput;
  name?: String;
  members?: ClassMateUpdateManyWithoutGroupInput;
}

export interface LoveSignUpUpdateManyMutationInput {
  period?: String;
}

export interface ClassMateUpdateManyWithoutGroupInput {
  create?:
    | ClassMateCreateWithoutGroupInput[]
    | ClassMateCreateWithoutGroupInput;
  delete?: ClassMateWhereUniqueInput[] | ClassMateWhereUniqueInput;
  connect?: ClassMateWhereUniqueInput[] | ClassMateWhereUniqueInput;
  disconnect?: ClassMateWhereUniqueInput[] | ClassMateWhereUniqueInput;
  update?:
    | ClassMateUpdateWithWhereUniqueWithoutGroupInput[]
    | ClassMateUpdateWithWhereUniqueWithoutGroupInput;
  upsert?:
    | ClassMateUpsertWithWhereUniqueWithoutGroupInput[]
    | ClassMateUpsertWithWhereUniqueWithoutGroupInput;
  deleteMany?: ClassMateScalarWhereInput[] | ClassMateScalarWhereInput;
  updateMany?:
    | ClassMateUpdateManyWithWhereNestedInput[]
    | ClassMateUpdateManyWithWhereNestedInput;
}

export interface UserUpdateWithoutLocationGroupsDataInput {
  username?: String;
  password?: String;
  name?: String;
  gender?: String;
  avatar?: PhotoUpdateOneWithoutUserInput;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationUpdateOneWithoutBornsInput;
  residence?: LocationUpdateOneWithoutLivesInput;
  uid?: String;
  token?: String;
  posts?: PostUpdateManyWithoutAuthorInput;
  regStatus?: RegStatusUpdateOneWithoutApplicantsInput;
  regTimes?: Int;
  maxRegTimes?: Int;
  families?: FamilyUpdateManyWithoutFromInput;
  studies?: SchoolEduUpdateManyWithoutStudentsInput;
  works?: WorkUpdateManyWithoutWorkerInput;
  exam?: CollegeEntranceExamUpdateOneWithoutStudentInput;
  sentMessages?: MessageUpdateManyWithoutFromInput;
  receiveMessages?: MessageUpdateManyWithoutToInput;
  groupMessages?: GroupMessageUpdateManyWithoutFromInput;
  groups?: GroupUpdateManyWithoutUsersInput;
  friends?: UserUpdateManyInput;
  familyGroup?: FamilyGroupUpdateOneWithoutUsersInput;
  creater?: FamilyGroupUpdateOneWithoutCreaterInput;
  classMate?: ClassMateUpdateManyWithoutStudentInput;
  workGroup?: WorkGroupUpdateOneInput;
  colleagues?: ColleagueUpdateManyWithoutWorkerInput;
  fromOldColleagues?: OldColleagueUpdateManyWithoutFromInput;
  toOldColleagues?: OldColleagueUpdateManyWithoutToInput;
  forgetPassword?: FindPassWordUpdateOneWithoutForgetterInput;
  remmemberPassword?: FindPassWordUpdateManyWithoutRemmemberInput;
  loveSetting?: LoveSettingUpdateOneWithoutUserInput;
  loveWoman?: LoveMatchingUpdateManyWithoutWomanInput;
  loveMan?: LoveMatchingUpdateManyWithoutManInput;
  signUpLove?: LoveSignUpUpdateOneWithoutPersonInput;
  skills?: SkillUpdateManyWithoutPersonsInput;
  fitConditions?: PartnerConditionUpdateManyWithoutPartnersInput;
  nofitConditions?: PartnerConditionUpdateManyWithoutPassedPartnersInput;
  projects?: ProjectUpdateManyWithoutStarterInput;
  trades?: TradeUpdateManyWithoutUserInput;
}

export interface ClassMateUpdateWithWhereUniqueWithoutGroupInput {
  where: ClassMateWhereUniqueInput;
  data: ClassMateUpdateWithoutGroupDataInput;
}

export type WorkWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ClassMateUpdateWithoutGroupDataInput {
  student?: UserUpdateOneWithoutClassMateInput;
  status?: String;
}

export interface CityCreateManyWithoutProvinceInput {
  create?: CityCreateWithoutProvinceInput[] | CityCreateWithoutProvinceInput;
  connect?: CityWhereUniqueInput[] | CityWhereUniqueInput;
}

export interface UserUpdateOneWithoutClassMateInput {
  create?: UserCreateWithoutClassMateInput;
  update?: UserUpdateWithoutClassMateDataInput;
  upsert?: UserUpsertWithoutClassMateInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface PostCreateWithoutAuthorInput {
  isPublished?: Boolean;
  title: String;
  content: String;
}

export interface UserUpdateWithoutClassMateDataInput {
  username?: String;
  password?: String;
  name?: String;
  gender?: String;
  avatar?: PhotoUpdateOneWithoutUserInput;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationUpdateOneWithoutBornsInput;
  residence?: LocationUpdateOneWithoutLivesInput;
  uid?: String;
  token?: String;
  posts?: PostUpdateManyWithoutAuthorInput;
  regStatus?: RegStatusUpdateOneWithoutApplicantsInput;
  regTimes?: Int;
  maxRegTimes?: Int;
  families?: FamilyUpdateManyWithoutFromInput;
  studies?: SchoolEduUpdateManyWithoutStudentsInput;
  works?: WorkUpdateManyWithoutWorkerInput;
  exam?: CollegeEntranceExamUpdateOneWithoutStudentInput;
  sentMessages?: MessageUpdateManyWithoutFromInput;
  receiveMessages?: MessageUpdateManyWithoutToInput;
  groupMessages?: GroupMessageUpdateManyWithoutFromInput;
  groups?: GroupUpdateManyWithoutUsersInput;
  friends?: UserUpdateManyInput;
  familyGroup?: FamilyGroupUpdateOneWithoutUsersInput;
  creater?: FamilyGroupUpdateOneWithoutCreaterInput;
  workGroup?: WorkGroupUpdateOneInput;
  colleagues?: ColleagueUpdateManyWithoutWorkerInput;
  fromOldColleagues?: OldColleagueUpdateManyWithoutFromInput;
  toOldColleagues?: OldColleagueUpdateManyWithoutToInput;
  locationGroups?: LocationGroupUpdateManyWithoutUsersInput;
  forgetPassword?: FindPassWordUpdateOneWithoutForgetterInput;
  remmemberPassword?: FindPassWordUpdateManyWithoutRemmemberInput;
  loveSetting?: LoveSettingUpdateOneWithoutUserInput;
  loveWoman?: LoveMatchingUpdateManyWithoutWomanInput;
  loveMan?: LoveMatchingUpdateManyWithoutManInput;
  signUpLove?: LoveSignUpUpdateOneWithoutPersonInput;
  skills?: SkillUpdateManyWithoutPersonsInput;
  fitConditions?: PartnerConditionUpdateManyWithoutPartnersInput;
  nofitConditions?: PartnerConditionUpdateManyWithoutPassedPartnersInput;
  projects?: ProjectUpdateManyWithoutStarterInput;
  trades?: TradeUpdateManyWithoutUserInput;
}

export interface LocationCreateWithoutCompaniesInput {
  name?: String;
  province?: ProvinceCreateOneInput;
  city?: CityCreateOneInput;
  area?: AreaCreateOneInput;
  street?: StreetCreateOneInput;
  village?: VillageCreateOneInput;
  schools?: SchoolCreateManyWithoutLocationInput;
  universities?: UniversityCreateManyInput;
  borns?: UserCreateManyWithoutBirthplaceInput;
  lives?: UserCreateManyWithoutResidenceInput;
}

export interface UserUpsertWithoutClassMateInput {
  update: UserUpdateWithoutClassMateDataInput;
  create: UserCreateWithoutClassMateInput;
}

export interface FamilyGroupCreateWithoutMotherInput {
  father?: PersonCreateOneWithoutAsFatherInput;
  creater?: UserCreateOneWithoutCreaterInput;
  name?: String;
  families?: FamilyCreateManyInput;
  users?: UserCreateManyWithoutFamilyGroupInput;
}

export interface ClassMateUpsertWithWhereUniqueWithoutGroupInput {
  where: ClassMateWhereUniqueInput;
  update: ClassMateUpdateWithoutGroupDataInput;
  create: ClassMateCreateWithoutGroupInput;
}

export interface FindPassWordCreateOneWithoutForgetterInput {
  create?: FindPassWordCreateWithoutForgetterInput;
  connect?: FindPassWordWhereUniqueInput;
}

export interface ClassGroupUpdateManyMutationInput {
  name?: String;
}

export interface UserCreateManyWithoutFitConditionsInput {
  create?:
    | UserCreateWithoutFitConditionsInput[]
    | UserCreateWithoutFitConditionsInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface ClassMateCreateInput {
  student?: UserCreateOneWithoutClassMateInput;
  status: String;
  group: ClassGroupCreateOneWithoutMembersInput;
}

export interface WorkGroupWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  company?: CompanyWhereInput;
  colleagues_every?: ColleagueWhereInput;
  colleagues_some?: ColleagueWhereInput;
  colleagues_none?: ColleagueWhereInput;
  AND?: WorkGroupWhereInput[] | WorkGroupWhereInput;
  OR?: WorkGroupWhereInput[] | WorkGroupWhereInput;
  NOT?: WorkGroupWhereInput[] | WorkGroupWhereInput;
}

export interface ClassMateUpdateInput {
  student?: UserUpdateOneWithoutClassMateInput;
  status?: String;
  group?: ClassGroupUpdateOneRequiredWithoutMembersInput;
}

export interface TradeCreateInput {
  product?: ProductCreateOneInput;
  number?: Int;
  amount?: Float;
  user?: UserCreateOneWithoutTradesInput;
  status?: String;
}

export interface ClassMateUpdateManyMutationInput {
  status?: String;
}

export interface PersonUpdateManyMutationInput {
  name?: String;
}

export interface ColleagueCreateInput {
  worker?: UserCreateOneWithoutColleaguesInput;
  status: String;
  group?: WorkGroupCreateOneWithoutColleaguesInput;
}

export type TradeWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ColleagueUpdateInput {
  worker?: UserUpdateOneWithoutColleaguesInput;
  status?: String;
  group?: WorkGroupUpdateOneWithoutColleaguesInput;
}

export interface SchoolCreateWithoutLocationInput {
  name?: String;
  kind?: Educationkind;
}

export interface ColleagueUpdateManyMutationInput {
  status?: String;
}

export interface PhotoCreateInput {
  name?: String;
  url?: String;
  user?: UserCreateOneWithoutAvatarInput;
}

export interface CollegeEntranceExamCreateInput {
  province: ProvinceCreateOneInput;
  subject: String;
  culscore: Float;
  proscore?: Float;
  candidatenum: String;
  times?: Int;
  student: UserCreateOneWithoutExamInput;
}

export interface UserCreateOneWithoutLoveManInput {
  create?: UserCreateWithoutLoveManInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateOneWithoutExamInput {
  create?: UserCreateWithoutExamInput;
  connect?: UserWhereUniqueInput;
}

export type CityWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  code?: String;
}>;

export interface UserCreateWithoutExamInput {
  username: String;
  password: String;
  name?: String;
  gender?: String;
  avatar?: PhotoCreateOneWithoutUserInput;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationCreateOneWithoutBornsInput;
  residence?: LocationCreateOneWithoutLivesInput;
  uid: String;
  token: String;
  posts?: PostCreateManyWithoutAuthorInput;
  regStatus?: RegStatusCreateOneWithoutApplicantsInput;
  regTimes?: Int;
  maxRegTimes?: Int;
  families?: FamilyCreateManyWithoutFromInput;
  studies?: SchoolEduCreateManyWithoutStudentsInput;
  works?: WorkCreateManyWithoutWorkerInput;
  sentMessages?: MessageCreateManyWithoutFromInput;
  receiveMessages?: MessageCreateManyWithoutToInput;
  groupMessages?: GroupMessageCreateManyWithoutFromInput;
  groups?: GroupCreateManyWithoutUsersInput;
  friends?: UserCreateManyInput;
  familyGroup?: FamilyGroupCreateOneWithoutUsersInput;
  creater?: FamilyGroupCreateOneWithoutCreaterInput;
  classMate?: ClassMateCreateManyWithoutStudentInput;
  workGroup?: WorkGroupCreateOneInput;
  colleagues?: ColleagueCreateManyWithoutWorkerInput;
  fromOldColleagues?: OldColleagueCreateManyWithoutFromInput;
  toOldColleagues?: OldColleagueCreateManyWithoutToInput;
  locationGroups?: LocationGroupCreateManyWithoutUsersInput;
  forgetPassword?: FindPassWordCreateOneWithoutForgetterInput;
  remmemberPassword?: FindPassWordCreateManyWithoutRemmemberInput;
  loveSetting?: LoveSettingCreateOneWithoutUserInput;
  loveWoman?: LoveMatchingCreateManyWithoutWomanInput;
  loveMan?: LoveMatchingCreateManyWithoutManInput;
  signUpLove?: LoveSignUpCreateOneWithoutPersonInput;
  skills?: SkillCreateManyWithoutPersonsInput;
  fitConditions?: PartnerConditionCreateManyWithoutPartnersInput;
  nofitConditions?: PartnerConditionCreateManyWithoutPassedPartnersInput;
  projects?: ProjectCreateManyWithoutStarterInput;
  trades?: TradeCreateManyWithoutUserInput;
}

export interface LoveSettingUpdateInput {
  myHeight?: Int;
  myWeight?: Int;
  otherHeightMin?: Int;
  otherHeightMax?: Int;
  otherWeightMin?: Int;
  otherWeightMax?: Int;
  otherAgeMin?: Int;
  otherAgeMax?: Int;
  dateTime?: String;
  datePlace?: String;
  memeberGrade?: Int;
  memeberGradeEndTime?: String;
  user?: UserUpdateOneRequiredWithoutLoveSettingInput;
}

export interface CollegeEntranceExamUpdateInput {
  province?: ProvinceUpdateOneRequiredInput;
  subject?: String;
  culscore?: Float;
  proscore?: Float;
  candidatenum?: String;
  times?: Int;
  student?: UserUpdateOneRequiredWithoutExamInput;
}

export interface FamilyCreateWithoutToInput {
  from: UserCreateOneWithoutFamiliesInput;
  relationship: String;
  spouse?: FamilyCreateOneInput;
  status: String;
}

export interface CollegeEntranceExamUpdateManyMutationInput {
  subject?: String;
  culscore?: Float;
  proscore?: Float;
  candidatenum?: String;
  times?: Int;
}

export interface UserUpsertWithoutExamInput {
  update: UserUpdateWithoutExamDataInput;
  create: UserCreateWithoutExamInput;
}

export interface UserUpdateWithoutExamDataInput {
  username?: String;
  password?: String;
  name?: String;
  gender?: String;
  avatar?: PhotoUpdateOneWithoutUserInput;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationUpdateOneWithoutBornsInput;
  residence?: LocationUpdateOneWithoutLivesInput;
  uid?: String;
  token?: String;
  posts?: PostUpdateManyWithoutAuthorInput;
  regStatus?: RegStatusUpdateOneWithoutApplicantsInput;
  regTimes?: Int;
  maxRegTimes?: Int;
  families?: FamilyUpdateManyWithoutFromInput;
  studies?: SchoolEduUpdateManyWithoutStudentsInput;
  works?: WorkUpdateManyWithoutWorkerInput;
  sentMessages?: MessageUpdateManyWithoutFromInput;
  receiveMessages?: MessageUpdateManyWithoutToInput;
  groupMessages?: GroupMessageUpdateManyWithoutFromInput;
  groups?: GroupUpdateManyWithoutUsersInput;
  friends?: UserUpdateManyInput;
  familyGroup?: FamilyGroupUpdateOneWithoutUsersInput;
  creater?: FamilyGroupUpdateOneWithoutCreaterInput;
  classMate?: ClassMateUpdateManyWithoutStudentInput;
  workGroup?: WorkGroupUpdateOneInput;
  colleagues?: ColleagueUpdateManyWithoutWorkerInput;
  fromOldColleagues?: OldColleagueUpdateManyWithoutFromInput;
  toOldColleagues?: OldColleagueUpdateManyWithoutToInput;
  locationGroups?: LocationGroupUpdateManyWithoutUsersInput;
  forgetPassword?: FindPassWordUpdateOneWithoutForgetterInput;
  remmemberPassword?: FindPassWordUpdateManyWithoutRemmemberInput;
  loveSetting?: LoveSettingUpdateOneWithoutUserInput;
  loveWoman?: LoveMatchingUpdateManyWithoutWomanInput;
  loveMan?: LoveMatchingUpdateManyWithoutManInput;
  signUpLove?: LoveSignUpUpdateOneWithoutPersonInput;
  skills?: SkillUpdateManyWithoutPersonsInput;
  fitConditions?: PartnerConditionUpdateManyWithoutPartnersInput;
  nofitConditions?: PartnerConditionUpdateManyWithoutPassedPartnersInput;
  projects?: ProjectUpdateManyWithoutStarterInput;
  trades?: TradeUpdateManyWithoutUserInput;
}

export interface UserUpdateOneRequiredWithoutExamInput {
  create?: UserCreateWithoutExamInput;
  update?: UserUpdateWithoutExamDataInput;
  upsert?: UserUpsertWithoutExamInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateManyWithoutFamilyGroupInput {
  create?:
    | UserCreateWithoutFamilyGroupInput[]
    | UserCreateWithoutFamilyGroupInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface CityCreateOneWithoutAreasInput {
  create?: CityCreateWithoutAreasInput;
  connect?: CityWhereUniqueInput;
}

export interface UserUpdateWithoutRegStatusDataInput {
  username?: String;
  password?: String;
  name?: String;
  gender?: String;
  avatar?: PhotoUpdateOneWithoutUserInput;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationUpdateOneWithoutBornsInput;
  residence?: LocationUpdateOneWithoutLivesInput;
  uid?: String;
  token?: String;
  posts?: PostUpdateManyWithoutAuthorInput;
  regTimes?: Int;
  maxRegTimes?: Int;
  families?: FamilyUpdateManyWithoutFromInput;
  studies?: SchoolEduUpdateManyWithoutStudentsInput;
  works?: WorkUpdateManyWithoutWorkerInput;
  exam?: CollegeEntranceExamUpdateOneWithoutStudentInput;
  sentMessages?: MessageUpdateManyWithoutFromInput;
  receiveMessages?: MessageUpdateManyWithoutToInput;
  groupMessages?: GroupMessageUpdateManyWithoutFromInput;
  groups?: GroupUpdateManyWithoutUsersInput;
  friends?: UserUpdateManyInput;
  familyGroup?: FamilyGroupUpdateOneWithoutUsersInput;
  creater?: FamilyGroupUpdateOneWithoutCreaterInput;
  classMate?: ClassMateUpdateManyWithoutStudentInput;
  workGroup?: WorkGroupUpdateOneInput;
  colleagues?: ColleagueUpdateManyWithoutWorkerInput;
  fromOldColleagues?: OldColleagueUpdateManyWithoutFromInput;
  toOldColleagues?: OldColleagueUpdateManyWithoutToInput;
  locationGroups?: LocationGroupUpdateManyWithoutUsersInput;
  forgetPassword?: FindPassWordUpdateOneWithoutForgetterInput;
  remmemberPassword?: FindPassWordUpdateManyWithoutRemmemberInput;
  loveSetting?: LoveSettingUpdateOneWithoutUserInput;
  loveWoman?: LoveMatchingUpdateManyWithoutWomanInput;
  loveMan?: LoveMatchingUpdateManyWithoutManInput;
  signUpLove?: LoveSignUpUpdateOneWithoutPersonInput;
  skills?: SkillUpdateManyWithoutPersonsInput;
  fitConditions?: PartnerConditionUpdateManyWithoutPartnersInput;
  nofitConditions?: PartnerConditionUpdateManyWithoutPassedPartnersInput;
  projects?: ProjectUpdateManyWithoutStarterInput;
  trades?: TradeUpdateManyWithoutUserInput;
}

export interface AreaUpdateInput {
  code?: String;
  name?: String;
  city?: CityUpdateOneRequiredWithoutAreasInput;
  towns?: StreetUpdateManyWithoutAreaInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface WorkGroupPreviousValues {
  id: ID_Output;
}

export interface WorkGroupPreviousValuesPromise
  extends Promise<WorkGroupPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface WorkGroupPreviousValuesSubscription
  extends Promise<AsyncIterator<WorkGroupPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface ClassMateEdge {
  node: ClassMate;
  cursor: String;
}

export interface ClassMateEdgePromise
  extends Promise<ClassMateEdge>,
    Fragmentable {
  node: <T = ClassMatePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ClassMateEdgeSubscription
  extends Promise<AsyncIterator<ClassMateEdge>>,
    Fragmentable {
  node: <T = ClassMateSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Photo {
  id: ID_Output;
  name?: String;
  url?: String;
}

export interface PhotoPromise extends Promise<Photo>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  url: () => Promise<String>;
  user: <T = UserPromise>() => T;
}

export interface PhotoSubscription
  extends Promise<AsyncIterator<Photo>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
  user: <T = UserSubscription>() => T;
}

export interface ClassMateConnection {
  pageInfo: PageInfo;
  edges: ClassMateEdge[];
}

export interface ClassMateConnectionPromise
  extends Promise<ClassMateConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ClassMateEdge>>() => T;
  aggregate: <T = AggregateClassMatePromise>() => T;
}

export interface ClassMateConnectionSubscription
  extends Promise<AsyncIterator<ClassMateConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ClassMateEdgeSubscription>>>() => T;
  aggregate: <T = AggregateClassMateSubscription>() => T;
}

export interface Street {
  id: ID_Output;
  code: String;
  name: String;
}

export interface StreetPromise extends Promise<Street>, Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<String>;
  name: () => Promise<String>;
  Area: <T = AreaPromise>() => T;
  villages: <T = FragmentableArray<Village>>(
    args?: {
      where?: VillageWhereInput;
      orderBy?: VillageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface StreetSubscription
  extends Promise<AsyncIterator<Street>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  code: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  Area: <T = AreaSubscription>() => T;
  villages: <T = Promise<AsyncIterator<VillageSubscription>>>(
    args?: {
      where?: VillageWhereInput;
      orderBy?: VillageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface AggregateClassGroup {
  count: Int;
}

export interface AggregateClassGroupPromise
  extends Promise<AggregateClassGroup>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateClassGroupSubscription
  extends Promise<AsyncIterator<AggregateClassGroup>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface User {
  id: ID_Output;
  username: String;
  password: String;
  name?: String;
  gender?: String;
  birthdaycalendar?: String;
  birthday?: DateTimeOutput;
  uid: String;
  token: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  regTimes?: Int;
  maxRegTimes?: Int;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  username: () => Promise<String>;
  password: () => Promise<String>;
  name: () => Promise<String>;
  gender: () => Promise<String>;
  avatar: <T = PhotoPromise>() => T;
  birthdaycalendar: () => Promise<String>;
  birthday: () => Promise<DateTimeOutput>;
  birthplace: <T = LocationPromise>() => T;
  residence: <T = LocationPromise>() => T;
  uid: () => Promise<String>;
  token: () => Promise<String>;
  posts: <T = FragmentableArray<Post>>(
    args?: {
      where?: PostWhereInput;
      orderBy?: PostOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  regStatus: <T = RegStatusPromise>() => T;
  regTimes: () => Promise<Int>;
  maxRegTimes: () => Promise<Int>;
  families: <T = FragmentableArray<Family>>(
    args?: {
      where?: FamilyWhereInput;
      orderBy?: FamilyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  studies: <T = FragmentableArray<SchoolEdu>>(
    args?: {
      where?: SchoolEduWhereInput;
      orderBy?: SchoolEduOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  works: <T = FragmentableArray<Work>>(
    args?: {
      where?: WorkWhereInput;
      orderBy?: WorkOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  exam: <T = CollegeEntranceExamPromise>() => T;
  sentMessages: <T = FragmentableArray<Message>>(
    args?: {
      where?: MessageWhereInput;
      orderBy?: MessageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  receiveMessages: <T = FragmentableArray<Message>>(
    args?: {
      where?: MessageWhereInput;
      orderBy?: MessageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  groupMessages: <T = FragmentableArray<GroupMessage>>(
    args?: {
      where?: GroupMessageWhereInput;
      orderBy?: GroupMessageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  groups: <T = FragmentableArray<Group>>(
    args?: {
      where?: GroupWhereInput;
      orderBy?: GroupOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  friends: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  familyGroup: <T = FamilyGroupPromise>() => T;
  creater: <T = FamilyGroupPromise>() => T;
  classMate: <T = FragmentableArray<ClassMate>>(
    args?: {
      where?: ClassMateWhereInput;
      orderBy?: ClassMateOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  workGroup: <T = WorkGroupPromise>() => T;
  colleagues: <T = FragmentableArray<Colleague>>(
    args?: {
      where?: ColleagueWhereInput;
      orderBy?: ColleagueOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  fromOldColleagues: <T = FragmentableArray<OldColleague>>(
    args?: {
      where?: OldColleagueWhereInput;
      orderBy?: OldColleagueOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  toOldColleagues: <T = FragmentableArray<OldColleague>>(
    args?: {
      where?: OldColleagueWhereInput;
      orderBy?: OldColleagueOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  locationGroups: <T = FragmentableArray<LocationGroup>>(
    args?: {
      where?: LocationGroupWhereInput;
      orderBy?: LocationGroupOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  forgetPassword: <T = FindPassWordPromise>() => T;
  remmemberPassword: <T = FragmentableArray<FindPassWord>>(
    args?: {
      where?: FindPassWordWhereInput;
      orderBy?: FindPassWordOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  loveSetting: <T = LoveSettingPromise>() => T;
  loveWoman: <T = FragmentableArray<LoveMatching>>(
    args?: {
      where?: LoveMatchingWhereInput;
      orderBy?: LoveMatchingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  loveMan: <T = FragmentableArray<LoveMatching>>(
    args?: {
      where?: LoveMatchingWhereInput;
      orderBy?: LoveMatchingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  signUpLove: <T = LoveSignUpPromise>() => T;
  skills: <T = FragmentableArray<Skill>>(
    args?: {
      where?: SkillWhereInput;
      orderBy?: SkillOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  fitConditions: <T = FragmentableArray<PartnerCondition>>(
    args?: {
      where?: PartnerConditionWhereInput;
      orderBy?: PartnerConditionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  nofitConditions: <T = FragmentableArray<PartnerCondition>>(
    args?: {
      where?: PartnerConditionWhereInput;
      orderBy?: PartnerConditionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  projects: <T = FragmentableArray<Project>>(
    args?: {
      where?: ProjectWhereInput;
      orderBy?: ProjectOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  trades: <T = FragmentableArray<Trade>>(
    args?: {
      where?: TradeWhereInput;
      orderBy?: TradeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  username: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<String>>;
  avatar: <T = PhotoSubscription>() => T;
  birthdaycalendar: () => Promise<AsyncIterator<String>>;
  birthday: () => Promise<AsyncIterator<DateTimeOutput>>;
  birthplace: <T = LocationSubscription>() => T;
  residence: <T = LocationSubscription>() => T;
  uid: () => Promise<AsyncIterator<String>>;
  token: () => Promise<AsyncIterator<String>>;
  posts: <T = Promise<AsyncIterator<PostSubscription>>>(
    args?: {
      where?: PostWhereInput;
      orderBy?: PostOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  regStatus: <T = RegStatusSubscription>() => T;
  regTimes: () => Promise<AsyncIterator<Int>>;
  maxRegTimes: () => Promise<AsyncIterator<Int>>;
  families: <T = Promise<AsyncIterator<FamilySubscription>>>(
    args?: {
      where?: FamilyWhereInput;
      orderBy?: FamilyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  studies: <T = Promise<AsyncIterator<SchoolEduSubscription>>>(
    args?: {
      where?: SchoolEduWhereInput;
      orderBy?: SchoolEduOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  works: <T = Promise<AsyncIterator<WorkSubscription>>>(
    args?: {
      where?: WorkWhereInput;
      orderBy?: WorkOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  exam: <T = CollegeEntranceExamSubscription>() => T;
  sentMessages: <T = Promise<AsyncIterator<MessageSubscription>>>(
    args?: {
      where?: MessageWhereInput;
      orderBy?: MessageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  receiveMessages: <T = Promise<AsyncIterator<MessageSubscription>>>(
    args?: {
      where?: MessageWhereInput;
      orderBy?: MessageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  groupMessages: <T = Promise<AsyncIterator<GroupMessageSubscription>>>(
    args?: {
      where?: GroupMessageWhereInput;
      orderBy?: GroupMessageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  groups: <T = Promise<AsyncIterator<GroupSubscription>>>(
    args?: {
      where?: GroupWhereInput;
      orderBy?: GroupOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  friends: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  familyGroup: <T = FamilyGroupSubscription>() => T;
  creater: <T = FamilyGroupSubscription>() => T;
  classMate: <T = Promise<AsyncIterator<ClassMateSubscription>>>(
    args?: {
      where?: ClassMateWhereInput;
      orderBy?: ClassMateOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  workGroup: <T = WorkGroupSubscription>() => T;
  colleagues: <T = Promise<AsyncIterator<ColleagueSubscription>>>(
    args?: {
      where?: ColleagueWhereInput;
      orderBy?: ColleagueOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  fromOldColleagues: <T = Promise<AsyncIterator<OldColleagueSubscription>>>(
    args?: {
      where?: OldColleagueWhereInput;
      orderBy?: OldColleagueOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  toOldColleagues: <T = Promise<AsyncIterator<OldColleagueSubscription>>>(
    args?: {
      where?: OldColleagueWhereInput;
      orderBy?: OldColleagueOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  locationGroups: <T = Promise<AsyncIterator<LocationGroupSubscription>>>(
    args?: {
      where?: LocationGroupWhereInput;
      orderBy?: LocationGroupOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  forgetPassword: <T = FindPassWordSubscription>() => T;
  remmemberPassword: <T = Promise<AsyncIterator<FindPassWordSubscription>>>(
    args?: {
      where?: FindPassWordWhereInput;
      orderBy?: FindPassWordOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  loveSetting: <T = LoveSettingSubscription>() => T;
  loveWoman: <T = Promise<AsyncIterator<LoveMatchingSubscription>>>(
    args?: {
      where?: LoveMatchingWhereInput;
      orderBy?: LoveMatchingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  loveMan: <T = Promise<AsyncIterator<LoveMatchingSubscription>>>(
    args?: {
      where?: LoveMatchingWhereInput;
      orderBy?: LoveMatchingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  signUpLove: <T = LoveSignUpSubscription>() => T;
  skills: <T = Promise<AsyncIterator<SkillSubscription>>>(
    args?: {
      where?: SkillWhereInput;
      orderBy?: SkillOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  fitConditions: <T = Promise<AsyncIterator<PartnerConditionSubscription>>>(
    args?: {
      where?: PartnerConditionWhereInput;
      orderBy?: PartnerConditionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  nofitConditions: <T = Promise<AsyncIterator<PartnerConditionSubscription>>>(
    args?: {
      where?: PartnerConditionWhereInput;
      orderBy?: PartnerConditionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  projects: <T = Promise<AsyncIterator<ProjectSubscription>>>(
    args?: {
      where?: ProjectWhereInput;
      orderBy?: ProjectOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  trades: <T = Promise<AsyncIterator<TradeSubscription>>>(
    args?: {
      where?: TradeWhereInput;
      orderBy?: TradeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface ClassGroupEdge {
  node: ClassGroup;
  cursor: String;
}

export interface ClassGroupEdgePromise
  extends Promise<ClassGroupEdge>,
    Fragmentable {
  node: <T = ClassGroupPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ClassGroupEdgeSubscription
  extends Promise<AsyncIterator<ClassGroupEdge>>,
    Fragmentable {
  node: <T = ClassGroupSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface Advertisement {
  id: ID_Output;
  image1?: String;
  image2?: String;
  image3?: String;
  image4?: String;
  image5?: String;
  startTime?: DateTimeOutput;
  endTime?: DateTimeOutput;
}

export interface AdvertisementPromise
  extends Promise<Advertisement>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  image1: () => Promise<String>;
  image2: () => Promise<String>;
  image3: () => Promise<String>;
  image4: () => Promise<String>;
  image5: () => Promise<String>;
  startTime: () => Promise<DateTimeOutput>;
  endTime: () => Promise<DateTimeOutput>;
}

export interface AdvertisementSubscription
  extends Promise<AsyncIterator<Advertisement>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  image1: () => Promise<AsyncIterator<String>>;
  image2: () => Promise<AsyncIterator<String>>;
  image3: () => Promise<AsyncIterator<String>>;
  image4: () => Promise<AsyncIterator<String>>;
  image5: () => Promise<AsyncIterator<String>>;
  startTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  endTime: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface WorkGroupEdge {
  node: WorkGroup;
  cursor: String;
}

export interface WorkGroupEdgePromise
  extends Promise<WorkGroupEdge>,
    Fragmentable {
  node: <T = WorkGroupPromise>() => T;
  cursor: () => Promise<String>;
}

export interface WorkGroupEdgeSubscription
  extends Promise<AsyncIterator<WorkGroupEdge>>,
    Fragmentable {
  node: <T = WorkGroupSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface WorkSubscriptionPayload {
  mutation: MutationType;
  node: Work;
  updatedFields: String[];
  previousValues: WorkPreviousValues;
}

export interface WorkSubscriptionPayloadPromise
  extends Promise<WorkSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = WorkPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = WorkPreviousValuesPromise>() => T;
}

export interface WorkSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<WorkSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = WorkSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = WorkPreviousValuesSubscription>() => T;
}

export interface VillagePreviousValues {
  id: ID_Output;
  code: String;
  name: String;
}

export interface VillagePreviousValuesPromise
  extends Promise<VillagePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<String>;
  name: () => Promise<String>;
}

export interface VillagePreviousValuesSubscription
  extends Promise<AsyncIterator<VillagePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  code: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface AggregateWorkGroup {
  count: Int;
}

export interface AggregateWorkGroupPromise
  extends Promise<AggregateWorkGroup>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateWorkGroupSubscription
  extends Promise<AsyncIterator<AggregateWorkGroup>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AdvertisementSubscriptionPayload {
  mutation: MutationType;
  node: Advertisement;
  updatedFields: String[];
  previousValues: AdvertisementPreviousValues;
}

export interface AdvertisementSubscriptionPayloadPromise
  extends Promise<AdvertisementSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AdvertisementPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AdvertisementPreviousValuesPromise>() => T;
}

export interface AdvertisementSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AdvertisementSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AdvertisementSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AdvertisementPreviousValuesSubscription>() => T;
}

export interface WorkGroupConnection {
  pageInfo: PageInfo;
  edges: WorkGroupEdge[];
}

export interface WorkGroupConnectionPromise
  extends Promise<WorkGroupConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<WorkGroupEdge>>() => T;
  aggregate: <T = AggregateWorkGroupPromise>() => T;
}

export interface WorkGroupConnectionSubscription
  extends Promise<AsyncIterator<WorkGroupConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<WorkGroupEdgeSubscription>>>() => T;
  aggregate: <T = AggregateWorkGroupSubscription>() => T;
}

export interface WorkConnection {
  pageInfo: PageInfo;
  edges: WorkEdge[];
}

export interface WorkConnectionPromise
  extends Promise<WorkConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<WorkEdge>>() => T;
  aggregate: <T = AggregateWorkPromise>() => T;
}

export interface WorkConnectionSubscription
  extends Promise<AsyncIterator<WorkConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<WorkEdgeSubscription>>>() => T;
  aggregate: <T = AggregateWorkSubscription>() => T;
}

export interface AggregateWork {
  count: Int;
}

export interface AggregateWorkPromise
  extends Promise<AggregateWork>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateWorkSubscription
  extends Promise<AsyncIterator<AggregateWork>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface VillageEdge {
  node: Village;
  cursor: String;
}

export interface VillageEdgePromise extends Promise<VillageEdge>, Fragmentable {
  node: <T = VillagePromise>() => T;
  cursor: () => Promise<String>;
}

export interface VillageEdgeSubscription
  extends Promise<AsyncIterator<VillageEdge>>,
    Fragmentable {
  node: <T = VillageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AdvertisementPreviousValues {
  id: ID_Output;
  image1?: String;
  image2?: String;
  image3?: String;
  image4?: String;
  image5?: String;
  startTime?: DateTimeOutput;
  endTime?: DateTimeOutput;
}

export interface AdvertisementPreviousValuesPromise
  extends Promise<AdvertisementPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  image1: () => Promise<String>;
  image2: () => Promise<String>;
  image3: () => Promise<String>;
  image4: () => Promise<String>;
  image5: () => Promise<String>;
  startTime: () => Promise<DateTimeOutput>;
  endTime: () => Promise<DateTimeOutput>;
}

export interface AdvertisementPreviousValuesSubscription
  extends Promise<AsyncIterator<AdvertisementPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  image1: () => Promise<AsyncIterator<String>>;
  image2: () => Promise<AsyncIterator<String>>;
  image3: () => Promise<AsyncIterator<String>>;
  image4: () => Promise<AsyncIterator<String>>;
  image5: () => Promise<AsyncIterator<String>>;
  startTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  endTime: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ClassGroupConnection {
  pageInfo: PageInfo;
  edges: ClassGroupEdge[];
}

export interface ClassGroupConnectionPromise
  extends Promise<ClassGroupConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ClassGroupEdge>>() => T;
  aggregate: <T = AggregateClassGroupPromise>() => T;
}

export interface ClassGroupConnectionSubscription
  extends Promise<AsyncIterator<ClassGroupConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ClassGroupEdgeSubscription>>>() => T;
  aggregate: <T = AggregateClassGroupSubscription>() => T;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface AreaSubscriptionPayload {
  mutation: MutationType;
  node: Area;
  updatedFields: String[];
  previousValues: AreaPreviousValues;
}

export interface AreaSubscriptionPayloadPromise
  extends Promise<AreaSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AreaPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AreaPreviousValuesPromise>() => T;
}

export interface AreaSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AreaSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AreaSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AreaPreviousValuesSubscription>() => T;
}

export interface UniversityEdge {
  node: University;
  cursor: String;
}

export interface UniversityEdgePromise
  extends Promise<UniversityEdge>,
    Fragmentable {
  node: <T = UniversityPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UniversityEdgeSubscription
  extends Promise<AsyncIterator<UniversityEdge>>,
    Fragmentable {
  node: <T = UniversitySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AreaPreviousValues {
  id: ID_Output;
  code: String;
  name: String;
}

export interface AreaPreviousValuesPromise
  extends Promise<AreaPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<String>;
  name: () => Promise<String>;
}

export interface AreaPreviousValuesSubscription
  extends Promise<AsyncIterator<AreaPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  code: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTrade {
  count: Int;
}

export interface AggregateTradePromise
  extends Promise<AggregateTrade>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTradeSubscription
  extends Promise<AsyncIterator<AggregateTrade>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateCity {
  count: Int;
}

export interface AggregateCityPromise
  extends Promise<AggregateCity>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCitySubscription
  extends Promise<AsyncIterator<AggregateCity>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TradeConnection {
  pageInfo: PageInfo;
  edges: TradeEdge[];
}

export interface TradeConnectionPromise
  extends Promise<TradeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TradeEdge>>() => T;
  aggregate: <T = AggregateTradePromise>() => T;
}

export interface TradeConnectionSubscription
  extends Promise<AsyncIterator<TradeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TradeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTradeSubscription>() => T;
}

export interface BootCountSubscriptionPayload {
  mutation: MutationType;
  node: BootCount;
  updatedFields: String[];
  previousValues: BootCountPreviousValues;
}

export interface BootCountSubscriptionPayloadPromise
  extends Promise<BootCountSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BootCountPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BootCountPreviousValuesPromise>() => T;
}

export interface BootCountSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BootCountSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BootCountSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BootCountPreviousValuesSubscription>() => T;
}

export interface StreetEdge {
  node: Street;
  cursor: String;
}

export interface StreetEdgePromise extends Promise<StreetEdge>, Fragmentable {
  node: <T = StreetPromise>() => T;
  cursor: () => Promise<String>;
}

export interface StreetEdgeSubscription
  extends Promise<AsyncIterator<StreetEdge>>,
    Fragmentable {
  node: <T = StreetSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BootCountPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
}

export interface BootCountPreviousValuesPromise
  extends Promise<BootCountPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface BootCountPreviousValuesSubscription
  extends Promise<AsyncIterator<BootCountPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateStation {
  count: Int;
}

export interface AggregateStationPromise
  extends Promise<AggregateStation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStationSubscription
  extends Promise<AsyncIterator<AggregateStation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CityEdge {
  node: City;
  cursor: String;
}

export interface CityEdgePromise extends Promise<CityEdge>, Fragmentable {
  node: <T = CityPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CityEdgeSubscription
  extends Promise<AsyncIterator<CityEdge>>,
    Fragmentable {
  node: <T = CitySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface StationConnection {
  pageInfo: PageInfo;
  edges: StationEdge[];
}

export interface StationConnectionPromise
  extends Promise<StationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<StationEdge>>() => T;
  aggregate: <T = AggregateStationPromise>() => T;
}

export interface StationConnectionSubscription
  extends Promise<AsyncIterator<StationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStationSubscription>() => T;
}

export interface CitySubscriptionPayload {
  mutation: MutationType;
  node: City;
  updatedFields: String[];
  previousValues: CityPreviousValues;
}

export interface CitySubscriptionPayloadPromise
  extends Promise<CitySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CityPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CityPreviousValuesPromise>() => T;
}

export interface CitySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CitySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CitySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CityPreviousValuesSubscription>() => T;
}

export interface AggregateSkill {
  count: Int;
}

export interface AggregateSkillPromise
  extends Promise<AggregateSkill>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSkillSubscription
  extends Promise<AsyncIterator<AggregateSkill>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CityPreviousValues {
  id: ID_Output;
  code: String;
  name: String;
}

export interface CityPreviousValuesPromise
  extends Promise<CityPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<String>;
  name: () => Promise<String>;
}

export interface CityPreviousValuesSubscription
  extends Promise<AsyncIterator<CityPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  code: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface SkillConnection {
  pageInfo: PageInfo;
  edges: SkillEdge[];
}

export interface SkillConnectionPromise
  extends Promise<SkillConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SkillEdge>>() => T;
  aggregate: <T = AggregateSkillPromise>() => T;
}

export interface SkillConnectionSubscription
  extends Promise<AsyncIterator<SkillConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SkillEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSkillSubscription>() => T;
}

export interface CityConnection {
  pageInfo: PageInfo;
  edges: CityEdge[];
}

export interface CityConnectionPromise
  extends Promise<CityConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CityEdge>>() => T;
  aggregate: <T = AggregateCityPromise>() => T;
}

export interface CityConnectionSubscription
  extends Promise<AsyncIterator<CityConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CityEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCitySubscription>() => T;
}

export interface SchoolEduEdge {
  node: SchoolEdu;
  cursor: String;
}

export interface SchoolEduEdgePromise
  extends Promise<SchoolEduEdge>,
    Fragmentable {
  node: <T = SchoolEduPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SchoolEduEdgeSubscription
  extends Promise<AsyncIterator<SchoolEduEdge>>,
    Fragmentable {
  node: <T = SchoolEduSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ClassGroupSubscriptionPayload {
  mutation: MutationType;
  node: ClassGroup;
  updatedFields: String[];
  previousValues: ClassGroupPreviousValues;
}

export interface ClassGroupSubscriptionPayloadPromise
  extends Promise<ClassGroupSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ClassGroupPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ClassGroupPreviousValuesPromise>() => T;
}

export interface ClassGroupSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ClassGroupSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ClassGroupSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ClassGroupPreviousValuesSubscription>() => T;
}

export interface AggregateSchool {
  count: Int;
}

export interface AggregateSchoolPromise
  extends Promise<AggregateSchool>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSchoolSubscription
  extends Promise<AsyncIterator<AggregateSchool>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ClassGroupPreviousValues {
  id: ID_Output;
  name?: String;
}

export interface ClassGroupPreviousValuesPromise
  extends Promise<ClassGroupPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface ClassGroupPreviousValuesSubscription
  extends Promise<AsyncIterator<ClassGroupPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface SchoolConnection {
  pageInfo: PageInfo;
  edges: SchoolEdge[];
}

export interface SchoolConnectionPromise
  extends Promise<SchoolConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SchoolEdge>>() => T;
  aggregate: <T = AggregateSchoolPromise>() => T;
}

export interface SchoolConnectionSubscription
  extends Promise<AsyncIterator<SchoolConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SchoolEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSchoolSubscription>() => T;
}

export interface AggregateBootCount {
  count: Int;
}

export interface AggregateBootCountPromise
  extends Promise<AggregateBootCount>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBootCountSubscription
  extends Promise<AsyncIterator<AggregateBootCount>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RegisterCountEdge {
  node: RegisterCount;
  cursor: String;
}

export interface RegisterCountEdgePromise
  extends Promise<RegisterCountEdge>,
    Fragmentable {
  node: <T = RegisterCountPromise>() => T;
  cursor: () => Promise<String>;
}

export interface RegisterCountEdgeSubscription
  extends Promise<AsyncIterator<RegisterCountEdge>>,
    Fragmentable {
  node: <T = RegisterCountSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ClassMateSubscriptionPayload {
  mutation: MutationType;
  node: ClassMate;
  updatedFields: String[];
  previousValues: ClassMatePreviousValues;
}

export interface ClassMateSubscriptionPayloadPromise
  extends Promise<ClassMateSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ClassMatePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ClassMatePreviousValuesPromise>() => T;
}

export interface ClassMateSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ClassMateSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ClassMateSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ClassMatePreviousValuesSubscription>() => T;
}

export interface RegisterCount {
  id: ID_Output;
  deviceId?: String;
  createdAt: DateTimeOutput;
}

export interface RegisterCountPromise
  extends Promise<RegisterCount>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  addUser: <T = UserPromise>() => T;
  deviceId: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface RegisterCountSubscription
  extends Promise<AsyncIterator<RegisterCount>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  addUser: <T = UserSubscription>() => T;
  deviceId: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ClassMatePreviousValues {
  id: ID_Output;
  status: String;
}

export interface ClassMatePreviousValuesPromise
  extends Promise<ClassMatePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  status: () => Promise<String>;
}

export interface ClassMatePreviousValuesSubscription
  extends Promise<AsyncIterator<ClassMatePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  status: () => Promise<AsyncIterator<String>>;
}

export interface RegStatusEdge {
  node: RegStatus;
  cursor: String;
}

export interface RegStatusEdgePromise
  extends Promise<RegStatusEdge>,
    Fragmentable {
  node: <T = RegStatusPromise>() => T;
  cursor: () => Promise<String>;
}

export interface RegStatusEdgeSubscription
  extends Promise<AsyncIterator<RegStatusEdge>>,
    Fragmentable {
  node: <T = RegStatusSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BootCountEdge {
  node: BootCount;
  cursor: String;
}

export interface BootCountEdgePromise
  extends Promise<BootCountEdge>,
    Fragmentable {
  node: <T = BootCountPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BootCountEdgeSubscription
  extends Promise<AsyncIterator<BootCountEdge>>,
    Fragmentable {
  node: <T = BootCountSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface School {
  id: ID_Output;
  name?: String;
  kind?: Educationkind;
}

export interface SchoolPromise extends Promise<School>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  kind: () => Promise<Educationkind>;
  location: <T = LocationPromise>() => T;
}

export interface SchoolSubscription
  extends Promise<AsyncIterator<School>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  kind: () => Promise<AsyncIterator<Educationkind>>;
  location: <T = LocationSubscription>() => T;
}

export interface ColleagueSubscriptionPayload {
  mutation: MutationType;
  node: Colleague;
  updatedFields: String[];
  previousValues: ColleaguePreviousValues;
}

export interface ColleagueSubscriptionPayloadPromise
  extends Promise<ColleagueSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ColleaguePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ColleaguePreviousValuesPromise>() => T;
}

export interface ColleagueSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ColleagueSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ColleagueSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ColleaguePreviousValuesSubscription>() => T;
}

export interface ProvinceEdge {
  node: Province;
  cursor: String;
}

export interface ProvinceEdgePromise
  extends Promise<ProvinceEdge>,
    Fragmentable {
  node: <T = ProvincePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProvinceEdgeSubscription
  extends Promise<AsyncIterator<ProvinceEdge>>,
    Fragmentable {
  node: <T = ProvinceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ColleaguePreviousValues {
  id: ID_Output;
  status: String;
}

export interface ColleaguePreviousValuesPromise
  extends Promise<ColleaguePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  status: () => Promise<String>;
}

export interface ColleaguePreviousValuesSubscription
  extends Promise<AsyncIterator<ColleaguePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  status: () => Promise<AsyncIterator<String>>;
}

export interface AdvertisementConnection {
  pageInfo: PageInfo;
  edges: AdvertisementEdge[];
}

export interface AdvertisementConnectionPromise
  extends Promise<AdvertisementConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AdvertisementEdge>>() => T;
  aggregate: <T = AggregateAdvertisementPromise>() => T;
}

export interface AdvertisementConnectionSubscription
  extends Promise<AsyncIterator<AdvertisementConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AdvertisementEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAdvertisementSubscription>() => T;
}

export interface BootCountConnection {
  pageInfo: PageInfo;
  edges: BootCountEdge[];
}

export interface BootCountConnectionPromise
  extends Promise<BootCountConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BootCountEdge>>() => T;
  aggregate: <T = AggregateBootCountPromise>() => T;
}

export interface BootCountConnectionSubscription
  extends Promise<AsyncIterator<BootCountConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BootCountEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBootCountSubscription>() => T;
}

export interface ProjectEdge {
  node: Project;
  cursor: String;
}

export interface ProjectEdgePromise extends Promise<ProjectEdge>, Fragmentable {
  node: <T = ProjectPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProjectEdgeSubscription
  extends Promise<AsyncIterator<ProjectEdge>>,
    Fragmentable {
  node: <T = ProjectSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CollegeEntranceExamSubscriptionPayload {
  mutation: MutationType;
  node: CollegeEntranceExam;
  updatedFields: String[];
  previousValues: CollegeEntranceExamPreviousValues;
}

export interface CollegeEntranceExamSubscriptionPayloadPromise
  extends Promise<CollegeEntranceExamSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CollegeEntranceExamPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CollegeEntranceExamPreviousValuesPromise>() => T;
}

export interface CollegeEntranceExamSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CollegeEntranceExamSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CollegeEntranceExamSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CollegeEntranceExamPreviousValuesSubscription>() => T;
}

export interface AggregateProduct {
  count: Int;
}

export interface AggregateProductPromise
  extends Promise<AggregateProduct>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductSubscription
  extends Promise<AsyncIterator<AggregateProduct>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CollegeEntranceExamPreviousValues {
  id: ID_Output;
  subject: String;
  culscore: Float;
  proscore?: Float;
  candidatenum: String;
  times?: Int;
}

export interface CollegeEntranceExamPreviousValuesPromise
  extends Promise<CollegeEntranceExamPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  subject: () => Promise<String>;
  culscore: () => Promise<Float>;
  proscore: () => Promise<Float>;
  candidatenum: () => Promise<String>;
  times: () => Promise<Int>;
}

export interface CollegeEntranceExamPreviousValuesSubscription
  extends Promise<AsyncIterator<CollegeEntranceExamPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  subject: () => Promise<AsyncIterator<String>>;
  culscore: () => Promise<AsyncIterator<Float>>;
  proscore: () => Promise<AsyncIterator<Float>>;
  candidatenum: () => Promise<AsyncIterator<String>>;
  times: () => Promise<AsyncIterator<Int>>;
}

export interface ProductConnection {
  pageInfo: PageInfo;
  edges: ProductEdge[];
}

export interface ProductConnectionPromise
  extends Promise<ProductConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductEdge>>() => T;
  aggregate: <T = AggregateProductPromise>() => T;
}

export interface ProductConnectionSubscription
  extends Promise<AsyncIterator<ProductConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProductEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProductSubscription>() => T;
}

export interface BootCount {
  id: ID_Output;
  createdAt: DateTimeOutput;
}

export interface BootCountPromise extends Promise<BootCount>, Fragmentable {
  id: () => Promise<ID_Output>;
  bootUser: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface BootCountSubscription
  extends Promise<AsyncIterator<BootCount>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  bootUser: <T = UserSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregatePost {
  count: Int;
}

export interface AggregatePostPromise
  extends Promise<AggregatePost>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePostSubscription
  extends Promise<AsyncIterator<AggregatePost>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CompanySubscriptionPayload {
  mutation: MutationType;
  node: Company;
  updatedFields: String[];
  previousValues: CompanyPreviousValues;
}

export interface CompanySubscriptionPayloadPromise
  extends Promise<CompanySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CompanyPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CompanyPreviousValuesPromise>() => T;
}

export interface CompanySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CompanySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CompanySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CompanyPreviousValuesSubscription>() => T;
}

export interface PostConnection {
  pageInfo: PageInfo;
  edges: PostEdge[];
}

export interface PostConnectionPromise
  extends Promise<PostConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PostEdge>>() => T;
  aggregate: <T = AggregatePostPromise>() => T;
}

export interface PostConnectionSubscription
  extends Promise<AsyncIterator<PostConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PostEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePostSubscription>() => T;
}

export interface CompanyPreviousValues {
  id: ID_Output;
  name?: String;
  code?: String;
  establishmentDate?: DateTimeOutput;
  representative?: String;
  BusinessScope?: String;
}

export interface CompanyPreviousValuesPromise
  extends Promise<CompanyPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  code: () => Promise<String>;
  establishmentDate: () => Promise<DateTimeOutput>;
  representative: () => Promise<String>;
  BusinessScope: () => Promise<String>;
}

export interface CompanyPreviousValuesSubscription
  extends Promise<AsyncIterator<CompanyPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  code: () => Promise<AsyncIterator<String>>;
  establishmentDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  representative: () => Promise<AsyncIterator<String>>;
  BusinessScope: () => Promise<AsyncIterator<String>>;
}

export interface PhotoEdge {
  node: Photo;
  cursor: String;
}

export interface PhotoEdgePromise extends Promise<PhotoEdge>, Fragmentable {
  node: <T = PhotoPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PhotoEdgeSubscription
  extends Promise<AsyncIterator<PhotoEdge>>,
    Fragmentable {
  node: <T = PhotoSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateArea {
  count: Int;
}

export interface AggregateAreaPromise
  extends Promise<AggregateArea>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAreaSubscription
  extends Promise<AsyncIterator<AggregateArea>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface WorkPreviousValues {
  id: ID_Output;
  startTime?: DateTimeOutput;
  endTime?: DateTimeOutput;
  department?: String;
  jobContent?: String;
}

export interface WorkPreviousValuesPromise
  extends Promise<WorkPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  startTime: () => Promise<DateTimeOutput>;
  endTime: () => Promise<DateTimeOutput>;
  department: () => Promise<String>;
  jobContent: () => Promise<String>;
}

export interface WorkPreviousValuesSubscription
  extends Promise<AsyncIterator<WorkPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  startTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  endTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  department: () => Promise<AsyncIterator<String>>;
  jobContent: () => Promise<AsyncIterator<String>>;
}

export interface FamilySubscriptionPayload {
  mutation: MutationType;
  node: Family;
  updatedFields: String[];
  previousValues: FamilyPreviousValues;
}

export interface FamilySubscriptionPayloadPromise
  extends Promise<FamilySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FamilyPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FamilyPreviousValuesPromise>() => T;
}

export interface FamilySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FamilySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FamilySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FamilyPreviousValuesSubscription>() => T;
}

export interface PersonEdge {
  node: Person;
  cursor: String;
}

export interface PersonEdgePromise extends Promise<PersonEdge>, Fragmentable {
  node: <T = PersonPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PersonEdgeSubscription
  extends Promise<AsyncIterator<PersonEdge>>,
    Fragmentable {
  node: <T = PersonSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface FamilyPreviousValues {
  id: ID_Output;
  relationship: String;
  status: String;
}

export interface FamilyPreviousValuesPromise
  extends Promise<FamilyPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  relationship: () => Promise<String>;
  status: () => Promise<String>;
}

export interface FamilyPreviousValuesSubscription
  extends Promise<AsyncIterator<FamilyPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  relationship: () => Promise<AsyncIterator<String>>;
  status: () => Promise<AsyncIterator<String>>;
}

export interface AdvertisementEdge {
  node: Advertisement;
  cursor: String;
}

export interface AdvertisementEdgePromise
  extends Promise<AdvertisementEdge>,
    Fragmentable {
  node: <T = AdvertisementPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AdvertisementEdgeSubscription
  extends Promise<AsyncIterator<AdvertisementEdge>>,
    Fragmentable {
  node: <T = AdvertisementSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AreaEdge {
  node: Area;
  cursor: String;
}

export interface AreaEdgePromise extends Promise<AreaEdge>, Fragmentable {
  node: <T = AreaPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AreaEdgeSubscription
  extends Promise<AsyncIterator<AreaEdge>>,
    Fragmentable {
  node: <T = AreaSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PartnerConditionEdge {
  node: PartnerCondition;
  cursor: String;
}

export interface PartnerConditionEdgePromise
  extends Promise<PartnerConditionEdge>,
    Fragmentable {
  node: <T = PartnerConditionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PartnerConditionEdgeSubscription
  extends Promise<AsyncIterator<PartnerConditionEdge>>,
    Fragmentable {
  node: <T = PartnerConditionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface FamilyGroupSubscriptionPayload {
  mutation: MutationType;
  node: FamilyGroup;
  updatedFields: String[];
  previousValues: FamilyGroupPreviousValues;
}

export interface FamilyGroupSubscriptionPayloadPromise
  extends Promise<FamilyGroupSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FamilyGroupPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FamilyGroupPreviousValuesPromise>() => T;
}

export interface FamilyGroupSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FamilyGroupSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FamilyGroupSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FamilyGroupPreviousValuesSubscription>() => T;
}

export interface AggregateOldColleague {
  count: Int;
}

export interface AggregateOldColleaguePromise
  extends Promise<AggregateOldColleague>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateOldColleagueSubscription
  extends Promise<AsyncIterator<AggregateOldColleague>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FamilyGroupPreviousValues {
  id: ID_Output;
  name?: String;
}

export interface FamilyGroupPreviousValuesPromise
  extends Promise<FamilyGroupPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface FamilyGroupPreviousValuesSubscription
  extends Promise<AsyncIterator<FamilyGroupPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface OldColleagueConnection {
  pageInfo: PageInfo;
  edges: OldColleagueEdge[];
}

export interface OldColleagueConnectionPromise
  extends Promise<OldColleagueConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<OldColleagueEdge>>() => T;
  aggregate: <T = AggregateOldColleaguePromise>() => T;
}

export interface OldColleagueConnectionSubscription
  extends Promise<AsyncIterator<OldColleagueConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<OldColleagueEdgeSubscription>>>() => T;
  aggregate: <T = AggregateOldColleagueSubscription>() => T;
}

export interface AreaConnection {
  pageInfo: PageInfo;
  edges: AreaEdge[];
}

export interface AreaConnectionPromise
  extends Promise<AreaConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AreaEdge>>() => T;
  aggregate: <T = AggregateAreaPromise>() => T;
}

export interface AreaConnectionSubscription
  extends Promise<AsyncIterator<AreaConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AreaEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAreaSubscription>() => T;
}

export interface MessageEdge {
  node: Message;
  cursor: String;
}

export interface MessageEdgePromise extends Promise<MessageEdge>, Fragmentable {
  node: <T = MessagePromise>() => T;
  cursor: () => Promise<String>;
}

export interface MessageEdgeSubscription
  extends Promise<AsyncIterator<MessageEdge>>,
    Fragmentable {
  node: <T = MessageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface FeeSettingSubscriptionPayload {
  mutation: MutationType;
  node: FeeSetting;
  updatedFields: String[];
  previousValues: FeeSettingPreviousValues;
}

export interface FeeSettingSubscriptionPayloadPromise
  extends Promise<FeeSettingSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FeeSettingPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FeeSettingPreviousValuesPromise>() => T;
}

export interface FeeSettingSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FeeSettingSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FeeSettingSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FeeSettingPreviousValuesSubscription>() => T;
}

export interface AggregateMajor {
  count: Int;
}

export interface AggregateMajorPromise
  extends Promise<AggregateMajor>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMajorSubscription
  extends Promise<AsyncIterator<AggregateMajor>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FeeSettingPreviousValues {
  id: ID_Output;
  name?: String;
  fee?: Boolean;
}

export interface FeeSettingPreviousValuesPromise
  extends Promise<FeeSettingPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  fee: () => Promise<Boolean>;
}

export interface FeeSettingPreviousValuesSubscription
  extends Promise<AsyncIterator<FeeSettingPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  fee: () => Promise<AsyncIterator<Boolean>>;
}

export interface MajorConnection {
  pageInfo: PageInfo;
  edges: MajorEdge[];
}

export interface MajorConnectionPromise
  extends Promise<MajorConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MajorEdge>>() => T;
  aggregate: <T = AggregateMajorPromise>() => T;
}

export interface MajorConnectionSubscription
  extends Promise<AsyncIterator<MajorConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MajorEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMajorSubscription>() => T;
}

export interface Product {
  id: ID_Output;
  subject?: String;
  info?: String;
  price?: Float;
  kind?: String;
}

export interface ProductPromise extends Promise<Product>, Fragmentable {
  id: () => Promise<ID_Output>;
  subject: () => Promise<String>;
  info: () => Promise<String>;
  price: () => Promise<Float>;
  kind: () => Promise<String>;
}

export interface ProductSubscription
  extends Promise<AsyncIterator<Product>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  subject: () => Promise<AsyncIterator<String>>;
  info: () => Promise<AsyncIterator<String>>;
  price: () => Promise<AsyncIterator<Float>>;
  kind: () => Promise<AsyncIterator<String>>;
}

export interface AggregateLoveSignUp {
  count: Int;
}

export interface AggregateLoveSignUpPromise
  extends Promise<AggregateLoveSignUp>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLoveSignUpSubscription
  extends Promise<AsyncIterator<AggregateLoveSignUp>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FindPassWordSubscriptionPayload {
  mutation: MutationType;
  node: FindPassWord;
  updatedFields: String[];
  previousValues: FindPassWordPreviousValues;
}

export interface FindPassWordSubscriptionPayloadPromise
  extends Promise<FindPassWordSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FindPassWordPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FindPassWordPreviousValuesPromise>() => T;
}

export interface FindPassWordSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FindPassWordSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FindPassWordSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FindPassWordPreviousValuesSubscription>() => T;
}

export interface LoveSignUpConnection {
  pageInfo: PageInfo;
  edges: LoveSignUpEdge[];
}

export interface LoveSignUpConnectionPromise
  extends Promise<LoveSignUpConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LoveSignUpEdge>>() => T;
  aggregate: <T = AggregateLoveSignUpPromise>() => T;
}

export interface LoveSignUpConnectionSubscription
  extends Promise<AsyncIterator<LoveSignUpConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LoveSignUpEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLoveSignUpSubscription>() => T;
}

export interface FindPassWordPreviousValues {
  id: ID_Output;
  times?: Int;
}

export interface FindPassWordPreviousValuesPromise
  extends Promise<FindPassWordPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  times: () => Promise<Int>;
}

export interface FindPassWordPreviousValuesSubscription
  extends Promise<AsyncIterator<FindPassWordPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  times: () => Promise<AsyncIterator<Int>>;
}

export interface LoveSettingEdge {
  node: LoveSetting;
  cursor: String;
}

export interface LoveSettingEdgePromise
  extends Promise<LoveSettingEdge>,
    Fragmentable {
  node: <T = LoveSettingPromise>() => T;
  cursor: () => Promise<String>;
}

export interface LoveSettingEdgeSubscription
  extends Promise<AsyncIterator<LoveSettingEdge>>,
    Fragmentable {
  node: <T = LoveSettingSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Trade {
  id: ID_Output;
  number?: Int;
  amount?: Float;
  status?: String;
}

export interface TradePromise extends Promise<Trade>, Fragmentable {
  id: () => Promise<ID_Output>;
  product: <T = ProductPromise>() => T;
  number: () => Promise<Int>;
  amount: () => Promise<Float>;
  user: <T = UserPromise>() => T;
  status: () => Promise<String>;
}

export interface TradeSubscription
  extends Promise<AsyncIterator<Trade>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  product: <T = ProductSubscription>() => T;
  number: () => Promise<AsyncIterator<Int>>;
  amount: () => Promise<AsyncIterator<Float>>;
  user: <T = UserSubscription>() => T;
  status: () => Promise<AsyncIterator<String>>;
}

export interface Area {
  id: ID_Output;
  code: String;
  name: String;
}

export interface AreaPromise extends Promise<Area>, Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<String>;
  name: () => Promise<String>;
  city: <T = CityPromise>() => T;
  towns: <T = FragmentableArray<Street>>(
    args?: {
      where?: StreetWhereInput;
      orderBy?: StreetOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface AreaSubscription
  extends Promise<AsyncIterator<Area>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  code: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  city: <T = CitySubscription>() => T;
  towns: <T = Promise<AsyncIterator<StreetSubscription>>>(
    args?: {
      where?: StreetWhereInput;
      orderBy?: StreetOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface GroupSubscriptionPayload {
  mutation: MutationType;
  node: Group;
  updatedFields: String[];
  previousValues: GroupPreviousValues;
}

export interface GroupSubscriptionPayloadPromise
  extends Promise<GroupSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GroupPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GroupPreviousValuesPromise>() => T;
}

export interface GroupSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GroupSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GroupSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GroupPreviousValuesSubscription>() => T;
}

export interface LoveMatchingEdge {
  node: LoveMatching;
  cursor: String;
}

export interface LoveMatchingEdgePromise
  extends Promise<LoveMatchingEdge>,
    Fragmentable {
  node: <T = LoveMatchingPromise>() => T;
  cursor: () => Promise<String>;
}

export interface LoveMatchingEdgeSubscription
  extends Promise<AsyncIterator<LoveMatchingEdge>>,
    Fragmentable {
  node: <T = LoveMatchingSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface GroupPreviousValues {
  id: ID_Output;
  type?: GroupKind;
  name?: String;
}

export interface GroupPreviousValuesPromise
  extends Promise<GroupPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<GroupKind>;
  name: () => Promise<String>;
}

export interface GroupPreviousValuesSubscription
  extends Promise<AsyncIterator<GroupPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<GroupKind>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface AggregateLogs {
  count: Int;
}

export interface AggregateLogsPromise
  extends Promise<AggregateLogs>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLogsSubscription
  extends Promise<AsyncIterator<AggregateLogs>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Project {
  id: ID_Output;
  name?: String;
  content?: String;
}

export interface ProjectPromise extends Promise<Project>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  place: <T = CityPromise>() => T;
  content: () => Promise<String>;
  conditions: <T = FragmentableArray<PartnerCondition>>(
    args?: {
      where?: PartnerConditionWhereInput;
      orderBy?: PartnerConditionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  starter: <T = UserPromise>() => T;
}

export interface ProjectSubscription
  extends Promise<AsyncIterator<Project>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  place: <T = CitySubscription>() => T;
  content: () => Promise<AsyncIterator<String>>;
  conditions: <T = Promise<AsyncIterator<PartnerConditionSubscription>>>(
    args?: {
      where?: PartnerConditionWhereInput;
      orderBy?: PartnerConditionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  starter: <T = UserSubscription>() => T;
}

export interface LogsConnection {
  pageInfo: PageInfo;
  edges: LogsEdge[];
}

export interface LogsConnectionPromise
  extends Promise<LogsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LogsEdge>>() => T;
  aggregate: <T = AggregateLogsPromise>() => T;
}

export interface LogsConnectionSubscription
  extends Promise<AsyncIterator<LogsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LogsEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLogsSubscription>() => T;
}

export interface GroupMessageSubscriptionPayload {
  mutation: MutationType;
  node: GroupMessage;
  updatedFields: String[];
  previousValues: GroupMessagePreviousValues;
}

export interface GroupMessageSubscriptionPayloadPromise
  extends Promise<GroupMessageSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GroupMessagePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GroupMessagePreviousValuesPromise>() => T;
}

export interface GroupMessageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GroupMessageSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GroupMessageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GroupMessagePreviousValuesSubscription>() => T;
}

export interface City {
  id: ID_Output;
  code: String;
  name: String;
}

export interface CityPromise extends Promise<City>, Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<String>;
  name: () => Promise<String>;
  province: <T = ProvincePromise>() => T;
  areas: <T = FragmentableArray<Area>>(
    args?: {
      where?: AreaWhereInput;
      orderBy?: AreaOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface CitySubscription
  extends Promise<AsyncIterator<City>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  code: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  province: <T = ProvinceSubscription>() => T;
  areas: <T = Promise<AsyncIterator<AreaSubscription>>>(
    args?: {
      where?: AreaWhereInput;
      orderBy?: AreaOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface GroupMessagePreviousValues {
  id: ID_Output;
  type?: GroupKind;
  to: String;
  text?: String;
  createdAt: DateTimeOutput;
}

export interface GroupMessagePreviousValuesPromise
  extends Promise<GroupMessagePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<GroupKind>;
  to: () => Promise<String>;
  text: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface GroupMessagePreviousValuesSubscription
  extends Promise<AsyncIterator<GroupMessagePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<GroupKind>>;
  to: () => Promise<AsyncIterator<String>>;
  text: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface LocationGroupEdge {
  node: LocationGroup;
  cursor: String;
}

export interface LocationGroupEdgePromise
  extends Promise<LocationGroupEdge>,
    Fragmentable {
  node: <T = LocationGroupPromise>() => T;
  cursor: () => Promise<String>;
}

export interface LocationGroupEdgeSubscription
  extends Promise<AsyncIterator<LocationGroupEdge>>,
    Fragmentable {
  node: <T = LocationGroupSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PartnerCondition {
  id: ID_Output;
  skillName?: String;
  place?: String;
  number?: Int;
}

export interface PartnerConditionPromise
  extends Promise<PartnerCondition>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  skillName: () => Promise<String>;
  place: () => Promise<String>;
  number: () => Promise<Int>;
  partners: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  passedPartners: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  project: <T = ProjectPromise>() => T;
}

export interface PartnerConditionSubscription
  extends Promise<AsyncIterator<PartnerCondition>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  skillName: () => Promise<AsyncIterator<String>>;
  place: () => Promise<AsyncIterator<String>>;
  number: () => Promise<AsyncIterator<Int>>;
  partners: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  passedPartners: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  project: <T = ProjectSubscription>() => T;
}

export interface AggregateLocation {
  count: Int;
}

export interface AggregateLocationPromise
  extends Promise<AggregateLocation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLocationSubscription
  extends Promise<AsyncIterator<AggregateLocation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LocationSubscriptionPayload {
  mutation: MutationType;
  node: Location;
  updatedFields: String[];
  previousValues: LocationPreviousValues;
}

export interface LocationSubscriptionPayloadPromise
  extends Promise<LocationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LocationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LocationPreviousValuesPromise>() => T;
}

export interface LocationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LocationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LocationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LocationPreviousValuesSubscription>() => T;
}

export interface LocationConnection {
  pageInfo: PageInfo;
  edges: LocationEdge[];
}

export interface LocationConnectionPromise
  extends Promise<LocationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LocationEdge>>() => T;
  aggregate: <T = AggregateLocationPromise>() => T;
}

export interface LocationConnectionSubscription
  extends Promise<AsyncIterator<LocationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LocationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLocationSubscription>() => T;
}

export interface LocationPreviousValues {
  id: ID_Output;
  name?: String;
}

export interface LocationPreviousValuesPromise
  extends Promise<LocationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface LocationPreviousValuesSubscription
  extends Promise<AsyncIterator<LocationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface AggregateGroupMessage {
  count: Int;
}

export interface AggregateGroupMessagePromise
  extends Promise<AggregateGroupMessage>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGroupMessageSubscription
  extends Promise<AsyncIterator<AggregateGroupMessage>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Skill {
  id: ID_Output;
  name?: String;
}

export interface SkillPromise extends Promise<Skill>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  persons: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface SkillSubscription
  extends Promise<AsyncIterator<Skill>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  persons: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface GroupMessageConnection {
  pageInfo: PageInfo;
  edges: GroupMessageEdge[];
}

export interface GroupMessageConnectionPromise
  extends Promise<GroupMessageConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GroupMessageEdge>>() => T;
  aggregate: <T = AggregateGroupMessagePromise>() => T;
}

export interface GroupMessageConnectionSubscription
  extends Promise<AsyncIterator<GroupMessageConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GroupMessageEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGroupMessageSubscription>() => T;
}

export interface LocationGroupSubscriptionPayload {
  mutation: MutationType;
  node: LocationGroup;
  updatedFields: String[];
  previousValues: LocationGroupPreviousValues;
}

export interface LocationGroupSubscriptionPayloadPromise
  extends Promise<LocationGroupSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LocationGroupPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LocationGroupPreviousValuesPromise>() => T;
}

export interface LocationGroupSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LocationGroupSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LocationGroupSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LocationGroupPreviousValuesSubscription>() => T;
}

export interface GroupEdge {
  node: Group;
  cursor: String;
}

export interface GroupEdgePromise extends Promise<GroupEdge>, Fragmentable {
  node: <T = GroupPromise>() => T;
  cursor: () => Promise<String>;
}

export interface GroupEdgeSubscription
  extends Promise<AsyncIterator<GroupEdge>>,
    Fragmentable {
  node: <T = GroupSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface LocationGroupPreviousValues {
  id: ID_Output;
  kind?: LocationGroupKind;
  code?: String;
  name?: String;
}

export interface LocationGroupPreviousValuesPromise
  extends Promise<LocationGroupPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  kind: () => Promise<LocationGroupKind>;
  code: () => Promise<String>;
  name: () => Promise<String>;
}

export interface LocationGroupPreviousValuesSubscription
  extends Promise<AsyncIterator<LocationGroupPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  kind: () => Promise<AsyncIterator<LocationGroupKind>>;
  code: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface AggregateFindPassWord {
  count: Int;
}

export interface AggregateFindPassWordPromise
  extends Promise<AggregateFindPassWord>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFindPassWordSubscription
  extends Promise<AsyncIterator<AggregateFindPassWord>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LoveSignUp {
  id: ID_Output;
  period?: String;
}

export interface LoveSignUpPromise extends Promise<LoveSignUp>, Fragmentable {
  id: () => Promise<ID_Output>;
  period: () => Promise<String>;
  city: <T = CityPromise>() => T;
  person: <T = UserPromise>() => T;
}

export interface LoveSignUpSubscription
  extends Promise<AsyncIterator<LoveSignUp>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  period: () => Promise<AsyncIterator<String>>;
  city: <T = CitySubscription>() => T;
  person: <T = UserSubscription>() => T;
}

export interface FindPassWordConnection {
  pageInfo: PageInfo;
  edges: FindPassWordEdge[];
}

export interface FindPassWordConnectionPromise
  extends Promise<FindPassWordConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FindPassWordEdge>>() => T;
  aggregate: <T = AggregateFindPassWordPromise>() => T;
}

export interface FindPassWordConnectionSubscription
  extends Promise<AsyncIterator<FindPassWordConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FindPassWordEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFindPassWordSubscription>() => T;
}

export interface LogsSubscriptionPayload {
  mutation: MutationType;
  node: Logs;
  updatedFields: String[];
  previousValues: LogsPreviousValues;
}

export interface LogsSubscriptionPayloadPromise
  extends Promise<LogsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LogsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LogsPreviousValuesPromise>() => T;
}

export interface LogsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LogsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LogsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LogsPreviousValuesSubscription>() => T;
}

export interface FeeSettingEdge {
  node: FeeSetting;
  cursor: String;
}

export interface FeeSettingEdgePromise
  extends Promise<FeeSettingEdge>,
    Fragmentable {
  node: <T = FeeSettingPromise>() => T;
  cursor: () => Promise<String>;
}

export interface FeeSettingEdgeSubscription
  extends Promise<AsyncIterator<FeeSettingEdge>>,
    Fragmentable {
  node: <T = FeeSettingSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface LogsPreviousValues {
  createFamilyGroupTime?: DateTimeOutput;
}

export interface LogsPreviousValuesPromise
  extends Promise<LogsPreviousValues>,
    Fragmentable {
  createFamilyGroupTime: () => Promise<DateTimeOutput>;
}

export interface LogsPreviousValuesSubscription
  extends Promise<AsyncIterator<LogsPreviousValues>>,
    Fragmentable {
  createFamilyGroupTime: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface FeeSetting {
  id: ID_Output;
  name?: String;
  fee?: Boolean;
}

export interface FeeSettingPromise extends Promise<FeeSetting>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  fee: () => Promise<Boolean>;
}

export interface FeeSettingSubscription
  extends Promise<AsyncIterator<FeeSetting>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  fee: () => Promise<AsyncIterator<Boolean>>;
}

export interface LoveMatching {
  id: ID_Output;
  period?: String;
}

export interface LoveMatchingPromise
  extends Promise<LoveMatching>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  period: () => Promise<String>;
  city: <T = CityPromise>() => T;
  woman: <T = UserPromise>() => T;
  man: <T = UserPromise>() => T;
}

export interface LoveMatchingSubscription
  extends Promise<AsyncIterator<LoveMatching>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  period: () => Promise<AsyncIterator<String>>;
  city: <T = CitySubscription>() => T;
  woman: <T = UserSubscription>() => T;
  man: <T = UserSubscription>() => T;
}

export interface FamilyGroupEdge {
  node: FamilyGroup;
  cursor: String;
}

export interface FamilyGroupEdgePromise
  extends Promise<FamilyGroupEdge>,
    Fragmentable {
  node: <T = FamilyGroupPromise>() => T;
  cursor: () => Promise<String>;
}

export interface FamilyGroupEdgeSubscription
  extends Promise<AsyncIterator<FamilyGroupEdge>>,
    Fragmentable {
  node: <T = FamilyGroupSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface LoveMatchingSubscriptionPayload {
  mutation: MutationType;
  node: LoveMatching;
  updatedFields: String[];
  previousValues: LoveMatchingPreviousValues;
}

export interface LoveMatchingSubscriptionPayloadPromise
  extends Promise<LoveMatchingSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LoveMatchingPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LoveMatchingPreviousValuesPromise>() => T;
}

export interface LoveMatchingSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LoveMatchingSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LoveMatchingSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LoveMatchingPreviousValuesSubscription>() => T;
}

export interface AggregateFamily {
  count: Int;
}

export interface AggregateFamilyPromise
  extends Promise<AggregateFamily>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFamilySubscription
  extends Promise<AsyncIterator<AggregateFamily>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LoveMatchingPreviousValues {
  id: ID_Output;
  period?: String;
}

export interface LoveMatchingPreviousValuesPromise
  extends Promise<LoveMatchingPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  period: () => Promise<String>;
}

export interface LoveMatchingPreviousValuesSubscription
  extends Promise<AsyncIterator<LoveMatchingPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  period: () => Promise<AsyncIterator<String>>;
}

export interface FamilyConnection {
  pageInfo: PageInfo;
  edges: FamilyEdge[];
}

export interface FamilyConnectionPromise
  extends Promise<FamilyConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FamilyEdge>>() => T;
  aggregate: <T = AggregateFamilyPromise>() => T;
}

export interface FamilyConnectionSubscription
  extends Promise<AsyncIterator<FamilyConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FamilyEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFamilySubscription>() => T;
}

export interface LoveSetting {
  id: ID_Output;
  myHeight?: Int;
  myWeight?: Int;
  otherHeightMin?: Int;
  otherHeightMax?: Int;
  otherWeightMin?: Int;
  otherWeightMax?: Int;
  otherAgeMin?: Int;
  otherAgeMax?: Int;
  dateTime?: String;
  datePlace?: String;
  memeberGrade?: Int;
  memeberGradeEndTime?: String;
}

export interface LoveSettingPromise extends Promise<LoveSetting>, Fragmentable {
  id: () => Promise<ID_Output>;
  myHeight: () => Promise<Int>;
  myWeight: () => Promise<Int>;
  otherHeightMin: () => Promise<Int>;
  otherHeightMax: () => Promise<Int>;
  otherWeightMin: () => Promise<Int>;
  otherWeightMax: () => Promise<Int>;
  otherAgeMin: () => Promise<Int>;
  otherAgeMax: () => Promise<Int>;
  dateTime: () => Promise<String>;
  datePlace: () => Promise<String>;
  memeberGrade: () => Promise<Int>;
  memeberGradeEndTime: () => Promise<String>;
  user: <T = UserPromise>() => T;
}

export interface LoveSettingSubscription
  extends Promise<AsyncIterator<LoveSetting>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  myHeight: () => Promise<AsyncIterator<Int>>;
  myWeight: () => Promise<AsyncIterator<Int>>;
  otherHeightMin: () => Promise<AsyncIterator<Int>>;
  otherHeightMax: () => Promise<AsyncIterator<Int>>;
  otherWeightMin: () => Promise<AsyncIterator<Int>>;
  otherWeightMax: () => Promise<AsyncIterator<Int>>;
  otherAgeMin: () => Promise<AsyncIterator<Int>>;
  otherAgeMax: () => Promise<AsyncIterator<Int>>;
  dateTime: () => Promise<AsyncIterator<String>>;
  datePlace: () => Promise<AsyncIterator<String>>;
  memeberGrade: () => Promise<AsyncIterator<Int>>;
  memeberGradeEndTime: () => Promise<AsyncIterator<String>>;
  user: <T = UserSubscription>() => T;
}

export interface CompanyEdge {
  node: Company;
  cursor: String;
}

export interface CompanyEdgePromise extends Promise<CompanyEdge>, Fragmentable {
  node: <T = CompanyPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CompanyEdgeSubscription
  extends Promise<AsyncIterator<CompanyEdge>>,
    Fragmentable {
  node: <T = CompanySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface LoveSettingSubscriptionPayload {
  mutation: MutationType;
  node: LoveSetting;
  updatedFields: String[];
  previousValues: LoveSettingPreviousValues;
}

export interface LoveSettingSubscriptionPayloadPromise
  extends Promise<LoveSettingSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LoveSettingPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LoveSettingPreviousValuesPromise>() => T;
}

export interface LoveSettingSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LoveSettingSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LoveSettingSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LoveSettingPreviousValuesSubscription>() => T;
}

export interface AggregateCollegeEntranceExam {
  count: Int;
}

export interface AggregateCollegeEntranceExamPromise
  extends Promise<AggregateCollegeEntranceExam>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCollegeEntranceExamSubscription
  extends Promise<AsyncIterator<AggregateCollegeEntranceExam>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LoveSettingPreviousValues {
  id: ID_Output;
  myHeight?: Int;
  myWeight?: Int;
  otherHeightMin?: Int;
  otherHeightMax?: Int;
  otherWeightMin?: Int;
  otherWeightMax?: Int;
  otherAgeMin?: Int;
  otherAgeMax?: Int;
  dateTime?: String;
  datePlace?: String;
  memeberGrade?: Int;
  memeberGradeEndTime?: String;
}

export interface LoveSettingPreviousValuesPromise
  extends Promise<LoveSettingPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  myHeight: () => Promise<Int>;
  myWeight: () => Promise<Int>;
  otherHeightMin: () => Promise<Int>;
  otherHeightMax: () => Promise<Int>;
  otherWeightMin: () => Promise<Int>;
  otherWeightMax: () => Promise<Int>;
  otherAgeMin: () => Promise<Int>;
  otherAgeMax: () => Promise<Int>;
  dateTime: () => Promise<String>;
  datePlace: () => Promise<String>;
  memeberGrade: () => Promise<Int>;
  memeberGradeEndTime: () => Promise<String>;
}

export interface LoveSettingPreviousValuesSubscription
  extends Promise<AsyncIterator<LoveSettingPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  myHeight: () => Promise<AsyncIterator<Int>>;
  myWeight: () => Promise<AsyncIterator<Int>>;
  otherHeightMin: () => Promise<AsyncIterator<Int>>;
  otherHeightMax: () => Promise<AsyncIterator<Int>>;
  otherWeightMin: () => Promise<AsyncIterator<Int>>;
  otherWeightMax: () => Promise<AsyncIterator<Int>>;
  otherAgeMin: () => Promise<AsyncIterator<Int>>;
  otherAgeMax: () => Promise<AsyncIterator<Int>>;
  dateTime: () => Promise<AsyncIterator<String>>;
  datePlace: () => Promise<AsyncIterator<String>>;
  memeberGrade: () => Promise<AsyncIterator<Int>>;
  memeberGradeEndTime: () => Promise<AsyncIterator<String>>;
}

export interface CollegeEntranceExamConnection {
  pageInfo: PageInfo;
  edges: CollegeEntranceExamEdge[];
}

export interface CollegeEntranceExamConnectionPromise
  extends Promise<CollegeEntranceExamConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CollegeEntranceExamEdge>>() => T;
  aggregate: <T = AggregateCollegeEntranceExamPromise>() => T;
}

export interface CollegeEntranceExamConnectionSubscription
  extends Promise<AsyncIterator<CollegeEntranceExamConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<CollegeEntranceExamEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateCollegeEntranceExamSubscription>() => T;
}

export interface FindPassWord {
  id: ID_Output;
  times?: Int;
}

export interface FindPassWordPromise
  extends Promise<FindPassWord>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  times: () => Promise<Int>;
  forgetter: <T = UserPromise>() => T;
  remmember: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface FindPassWordSubscription
  extends Promise<AsyncIterator<FindPassWord>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  times: () => Promise<AsyncIterator<Int>>;
  forgetter: <T = UserSubscription>() => T;
  remmember: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface ColleagueEdge {
  node: Colleague;
  cursor: String;
}

export interface ColleagueEdgePromise
  extends Promise<ColleagueEdge>,
    Fragmentable {
  node: <T = ColleaguePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ColleagueEdgeSubscription
  extends Promise<AsyncIterator<ColleagueEdge>>,
    Fragmentable {
  node: <T = ColleagueSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface LoveSignUpSubscriptionPayload {
  mutation: MutationType;
  node: LoveSignUp;
  updatedFields: String[];
  previousValues: LoveSignUpPreviousValues;
}

export interface LoveSignUpSubscriptionPayloadPromise
  extends Promise<LoveSignUpSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LoveSignUpPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LoveSignUpPreviousValuesPromise>() => T;
}

export interface LoveSignUpSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LoveSignUpSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LoveSignUpSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LoveSignUpPreviousValuesSubscription>() => T;
}

export interface AggregateClassMate {
  count: Int;
}

export interface AggregateClassMatePromise
  extends Promise<AggregateClassMate>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateClassMateSubscription
  extends Promise<AsyncIterator<AggregateClassMate>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LoveSignUpPreviousValues {
  id: ID_Output;
  period?: String;
}

export interface LoveSignUpPreviousValuesPromise
  extends Promise<LoveSignUpPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  period: () => Promise<String>;
}

export interface LoveSignUpPreviousValuesSubscription
  extends Promise<AsyncIterator<LoveSignUpPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  period: () => Promise<AsyncIterator<String>>;
}

export interface Location {
  id: ID_Output;
  name?: String;
}

export interface LocationPromise extends Promise<Location>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  province: <T = ProvincePromise>() => T;
  city: <T = CityPromise>() => T;
  area: <T = AreaPromise>() => T;
  street: <T = StreetPromise>() => T;
  village: <T = VillagePromise>() => T;
  schools: <T = FragmentableArray<School>>(
    args?: {
      where?: SchoolWhereInput;
      orderBy?: SchoolOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  companies: <T = FragmentableArray<Company>>(
    args?: {
      where?: CompanyWhereInput;
      orderBy?: CompanyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  universities: <T = FragmentableArray<University>>(
    args?: {
      where?: UniversityWhereInput;
      orderBy?: UniversityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  borns: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  lives: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface LocationSubscription
  extends Promise<AsyncIterator<Location>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  province: <T = ProvinceSubscription>() => T;
  city: <T = CitySubscription>() => T;
  area: <T = AreaSubscription>() => T;
  street: <T = StreetSubscription>() => T;
  village: <T = VillageSubscription>() => T;
  schools: <T = Promise<AsyncIterator<SchoolSubscription>>>(
    args?: {
      where?: SchoolWhereInput;
      orderBy?: SchoolOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  companies: <T = Promise<AsyncIterator<CompanySubscription>>>(
    args?: {
      where?: CompanyWhereInput;
      orderBy?: CompanyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  universities: <T = Promise<AsyncIterator<UniversitySubscription>>>(
    args?: {
      where?: UniversityWhereInput;
      orderBy?: UniversityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  borns: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  lives: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface LocationGroup {
  id: ID_Output;
  kind?: LocationGroupKind;
  code?: String;
  name?: String;
}

export interface LocationGroupPromise
  extends Promise<LocationGroup>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  kind: () => Promise<LocationGroupKind>;
  code: () => Promise<String>;
  name: () => Promise<String>;
  users: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface LocationGroupSubscription
  extends Promise<AsyncIterator<LocationGroup>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  kind: () => Promise<AsyncIterator<LocationGroupKind>>;
  code: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  users: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface AggregateVillage {
  count: Int;
}

export interface AggregateVillagePromise
  extends Promise<AggregateVillage>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateVillageSubscription
  extends Promise<AsyncIterator<AggregateVillage>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MajorSubscriptionPayload {
  mutation: MutationType;
  node: Major;
  updatedFields: String[];
  previousValues: MajorPreviousValues;
}

export interface MajorSubscriptionPayloadPromise
  extends Promise<MajorSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MajorPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MajorPreviousValuesPromise>() => T;
}

export interface MajorSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MajorSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MajorSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MajorPreviousValuesSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface MajorPreviousValues {
  id: ID_Output;
  name: String;
  category: String;
  education: Educationkind;
}

export interface MajorPreviousValuesPromise
  extends Promise<MajorPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  category: () => Promise<String>;
  education: () => Promise<Educationkind>;
}

export interface MajorPreviousValuesSubscription
  extends Promise<AsyncIterator<MajorPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  category: () => Promise<AsyncIterator<String>>;
  education: () => Promise<AsyncIterator<Educationkind>>;
}

export interface UniversityConnection {
  pageInfo: PageInfo;
  edges: UniversityEdge[];
}

export interface UniversityConnectionPromise
  extends Promise<UniversityConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UniversityEdge>>() => T;
  aggregate: <T = AggregateUniversityPromise>() => T;
}

export interface UniversityConnectionSubscription
  extends Promise<AsyncIterator<UniversityConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UniversityEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUniversitySubscription>() => T;
}

export interface OldColleague {
  id: ID_Output;
  status: String;
}

export interface OldColleaguePromise
  extends Promise<OldColleague>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  from: <T = UserPromise>() => T;
  to: <T = UserPromise>() => T;
  company: <T = CompanyPromise>() => T;
  status: () => Promise<String>;
}

export interface OldColleagueSubscription
  extends Promise<AsyncIterator<OldColleague>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  from: <T = UserSubscription>() => T;
  to: <T = UserSubscription>() => T;
  company: <T = CompanySubscription>() => T;
  status: () => Promise<AsyncIterator<String>>;
}

export interface AggregateStreet {
  count: Int;
}

export interface AggregateStreetPromise
  extends Promise<AggregateStreet>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStreetSubscription
  extends Promise<AsyncIterator<AggregateStreet>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MessageSubscriptionPayload {
  mutation: MutationType;
  node: Message;
  updatedFields: String[];
  previousValues: MessagePreviousValues;
}

export interface MessageSubscriptionPayloadPromise
  extends Promise<MessageSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MessagePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MessagePreviousValuesPromise>() => T;
}

export interface MessageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MessageSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MessageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MessagePreviousValuesSubscription>() => T;
}

export interface StationEdge {
  node: Station;
  cursor: String;
}

export interface StationEdgePromise extends Promise<StationEdge>, Fragmentable {
  node: <T = StationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface StationEdgeSubscription
  extends Promise<AsyncIterator<StationEdge>>,
    Fragmentable {
  node: <T = StationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface MessagePreviousValues {
  id: ID_Output;
  text?: String;
  createdAt: DateTimeOutput;
}

export interface MessagePreviousValuesPromise
  extends Promise<MessagePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface MessagePreviousValuesSubscription
  extends Promise<AsyncIterator<MessagePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  text: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SkillEdge {
  node: Skill;
  cursor: String;
}

export interface SkillEdgePromise extends Promise<SkillEdge>, Fragmentable {
  node: <T = SkillPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SkillEdgeSubscription
  extends Promise<AsyncIterator<SkillEdge>>,
    Fragmentable {
  node: <T = SkillSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ClassGroup {
  id: ID_Output;
  name?: String;
}

export interface ClassGroupPromise extends Promise<ClassGroup>, Fragmentable {
  id: () => Promise<ID_Output>;
  study: <T = SchoolEduPromise>() => T;
  name: () => Promise<String>;
  members: <T = FragmentableArray<ClassMate>>(
    args?: {
      where?: ClassMateWhereInput;
      orderBy?: ClassMateOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface ClassGroupSubscription
  extends Promise<AsyncIterator<ClassGroup>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  study: <T = SchoolEduSubscription>() => T;
  name: () => Promise<AsyncIterator<String>>;
  members: <T = Promise<AsyncIterator<ClassMateSubscription>>>(
    args?: {
      where?: ClassMateWhereInput;
      orderBy?: ClassMateOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface SchoolEduConnection {
  pageInfo: PageInfo;
  edges: SchoolEduEdge[];
}

export interface SchoolEduConnectionPromise
  extends Promise<SchoolEduConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SchoolEduEdge>>() => T;
  aggregate: <T = AggregateSchoolEduPromise>() => T;
}

export interface SchoolEduConnectionSubscription
  extends Promise<AsyncIterator<SchoolEduConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SchoolEduEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSchoolEduSubscription>() => T;
}

export interface OldColleagueSubscriptionPayload {
  mutation: MutationType;
  node: OldColleague;
  updatedFields: String[];
  previousValues: OldColleaguePreviousValues;
}

export interface OldColleagueSubscriptionPayloadPromise
  extends Promise<OldColleagueSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = OldColleaguePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = OldColleaguePreviousValuesPromise>() => T;
}

export interface OldColleagueSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OldColleagueSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = OldColleagueSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = OldColleaguePreviousValuesSubscription>() => T;
}

export interface AggregateRegisterCount {
  count: Int;
}

export interface AggregateRegisterCountPromise
  extends Promise<AggregateRegisterCount>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRegisterCountSubscription
  extends Promise<AsyncIterator<AggregateRegisterCount>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface OldColleaguePreviousValues {
  id: ID_Output;
  status: String;
}

export interface OldColleaguePreviousValuesPromise
  extends Promise<OldColleaguePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  status: () => Promise<String>;
}

export interface OldColleaguePreviousValuesSubscription
  extends Promise<AsyncIterator<OldColleaguePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  status: () => Promise<AsyncIterator<String>>;
}

export interface AggregateRegStatus {
  count: Int;
}

export interface AggregateRegStatusPromise
  extends Promise<AggregateRegStatus>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRegStatusSubscription
  extends Promise<AsyncIterator<AggregateRegStatus>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ClassMate {
  id: ID_Output;
  status: String;
}

export interface ClassMatePromise extends Promise<ClassMate>, Fragmentable {
  id: () => Promise<ID_Output>;
  student: <T = UserPromise>() => T;
  status: () => Promise<String>;
  group: <T = ClassGroupPromise>() => T;
}

export interface ClassMateSubscription
  extends Promise<AsyncIterator<ClassMate>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  student: <T = UserSubscription>() => T;
  status: () => Promise<AsyncIterator<String>>;
  group: <T = ClassGroupSubscription>() => T;
}

export interface AggregateProvince {
  count: Int;
}

export interface AggregateProvincePromise
  extends Promise<AggregateProvince>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProvinceSubscription
  extends Promise<AsyncIterator<AggregateProvince>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PartnerConditionSubscriptionPayload {
  mutation: MutationType;
  node: PartnerCondition;
  updatedFields: String[];
  previousValues: PartnerConditionPreviousValues;
}

export interface PartnerConditionSubscriptionPayloadPromise
  extends Promise<PartnerConditionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PartnerConditionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PartnerConditionPreviousValuesPromise>() => T;
}

export interface PartnerConditionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PartnerConditionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PartnerConditionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PartnerConditionPreviousValuesSubscription>() => T;
}

export interface AggregateProject {
  count: Int;
}

export interface AggregateProjectPromise
  extends Promise<AggregateProject>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProjectSubscription
  extends Promise<AsyncIterator<AggregateProject>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PartnerConditionPreviousValues {
  id: ID_Output;
  skillName?: String;
  place?: String;
  number?: Int;
}

export interface PartnerConditionPreviousValuesPromise
  extends Promise<PartnerConditionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  skillName: () => Promise<String>;
  place: () => Promise<String>;
  number: () => Promise<Int>;
}

export interface PartnerConditionPreviousValuesSubscription
  extends Promise<AsyncIterator<PartnerConditionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  skillName: () => Promise<AsyncIterator<String>>;
  place: () => Promise<AsyncIterator<String>>;
  number: () => Promise<AsyncIterator<Int>>;
}

export interface ProductEdge {
  node: Product;
  cursor: String;
}

export interface ProductEdgePromise extends Promise<ProductEdge>, Fragmentable {
  node: <T = ProductPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductEdgeSubscription
  extends Promise<AsyncIterator<ProductEdge>>,
    Fragmentable {
  node: <T = ProductSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Group {
  id: ID_Output;
  type?: GroupKind;
  name?: String;
}

export interface GroupPromise extends Promise<Group>, Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<GroupKind>;
  name: () => Promise<String>;
  users: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  messages: <T = FragmentableArray<Message>>(
    args?: {
      where?: MessageWhereInput;
      orderBy?: MessageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface GroupSubscription
  extends Promise<AsyncIterator<Group>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<GroupKind>>;
  name: () => Promise<AsyncIterator<String>>;
  users: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  messages: <T = Promise<AsyncIterator<MessageSubscription>>>(
    args?: {
      where?: MessageWhereInput;
      orderBy?: MessageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface PostEdge {
  node: Post;
  cursor: String;
}

export interface PostEdgePromise extends Promise<PostEdge>, Fragmentable {
  node: <T = PostPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PostEdgeSubscription
  extends Promise<AsyncIterator<PostEdge>>,
    Fragmentable {
  node: <T = PostSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PersonSubscriptionPayload {
  mutation: MutationType;
  node: Person;
  updatedFields: String[];
  previousValues: PersonPreviousValues;
}

export interface PersonSubscriptionPayloadPromise
  extends Promise<PersonSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PersonPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PersonPreviousValuesPromise>() => T;
}

export interface PersonSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PersonSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PersonSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PersonPreviousValuesSubscription>() => T;
}

export interface PhotoConnection {
  pageInfo: PageInfo;
  edges: PhotoEdge[];
}

export interface PhotoConnectionPromise
  extends Promise<PhotoConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PhotoEdge>>() => T;
  aggregate: <T = AggregatePhotoPromise>() => T;
}

export interface PhotoConnectionSubscription
  extends Promise<AsyncIterator<PhotoConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PhotoEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePhotoSubscription>() => T;
}

export interface PersonPreviousValues {
  id: ID_Output;
  name: String;
}

export interface PersonPreviousValuesPromise
  extends Promise<PersonPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface PersonPreviousValuesSubscription
  extends Promise<AsyncIterator<PersonPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface PersonConnection {
  pageInfo: PageInfo;
  edges: PersonEdge[];
}

export interface PersonConnectionPromise
  extends Promise<PersonConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PersonEdge>>() => T;
  aggregate: <T = AggregatePersonPromise>() => T;
}

export interface PersonConnectionSubscription
  extends Promise<AsyncIterator<PersonConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PersonEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePersonSubscription>() => T;
}

export interface GroupMessage {
  id: ID_Output;
  type?: GroupKind;
  to: String;
  text?: String;
  createdAt: DateTimeOutput;
}

export interface GroupMessagePromise
  extends Promise<GroupMessage>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<GroupKind>;
  to: () => Promise<String>;
  from: <T = UserPromise>() => T;
  text: () => Promise<String>;
  image: <T = PhotoPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface GroupMessageSubscription
  extends Promise<AsyncIterator<GroupMessage>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<GroupKind>>;
  to: () => Promise<AsyncIterator<String>>;
  from: <T = UserSubscription>() => T;
  text: () => Promise<AsyncIterator<String>>;
  image: <T = PhotoSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PartnerConditionConnection {
  pageInfo: PageInfo;
  edges: PartnerConditionEdge[];
}

export interface PartnerConditionConnectionPromise
  extends Promise<PartnerConditionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PartnerConditionEdge>>() => T;
  aggregate: <T = AggregatePartnerConditionPromise>() => T;
}

export interface PartnerConditionConnectionSubscription
  extends Promise<AsyncIterator<PartnerConditionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PartnerConditionEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePartnerConditionSubscription>() => T;
}

export interface PhotoSubscriptionPayload {
  mutation: MutationType;
  node: Photo;
  updatedFields: String[];
  previousValues: PhotoPreviousValues;
}

export interface PhotoSubscriptionPayloadPromise
  extends Promise<PhotoSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PhotoPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PhotoPreviousValuesPromise>() => T;
}

export interface PhotoSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PhotoSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PhotoSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PhotoPreviousValuesSubscription>() => T;
}

export interface AggregateMessage {
  count: Int;
}

export interface AggregateMessagePromise
  extends Promise<AggregateMessage>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMessageSubscription
  extends Promise<AsyncIterator<AggregateMessage>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PhotoPreviousValues {
  id: ID_Output;
  name?: String;
  url?: String;
}

export interface PhotoPreviousValuesPromise
  extends Promise<PhotoPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  url: () => Promise<String>;
}

export interface PhotoPreviousValuesSubscription
  extends Promise<AsyncIterator<PhotoPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
}

export interface MajorEdge {
  node: Major;
  cursor: String;
}

export interface MajorEdgePromise extends Promise<MajorEdge>, Fragmentable {
  node: <T = MajorPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MajorEdgeSubscription
  extends Promise<AsyncIterator<MajorEdge>>,
    Fragmentable {
  node: <T = MajorSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Message {
  id: ID_Output;
  text?: String;
  createdAt: DateTimeOutput;
}

export interface MessagePromise extends Promise<Message>, Fragmentable {
  id: () => Promise<ID_Output>;
  to: <T = UserPromise>() => T;
  from: <T = UserPromise>() => T;
  text: () => Promise<String>;
  image: <T = PhotoPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface MessageSubscription
  extends Promise<AsyncIterator<Message>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  to: <T = UserSubscription>() => T;
  from: <T = UserSubscription>() => T;
  text: () => Promise<AsyncIterator<String>>;
  image: <T = PhotoSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface LoveSignUpEdge {
  node: LoveSignUp;
  cursor: String;
}

export interface LoveSignUpEdgePromise
  extends Promise<LoveSignUpEdge>,
    Fragmentable {
  node: <T = LoveSignUpPromise>() => T;
  cursor: () => Promise<String>;
}

export interface LoveSignUpEdgeSubscription
  extends Promise<AsyncIterator<LoveSignUpEdge>>,
    Fragmentable {
  node: <T = LoveSignUpSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PostSubscriptionPayload {
  mutation: MutationType;
  node: Post;
  updatedFields: String[];
  previousValues: PostPreviousValues;
}

export interface PostSubscriptionPayloadPromise
  extends Promise<PostSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PostPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PostPreviousValuesPromise>() => T;
}

export interface PostSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PostSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PostSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PostPreviousValuesSubscription>() => T;
}

export interface LoveSettingConnection {
  pageInfo: PageInfo;
  edges: LoveSettingEdge[];
}

export interface LoveSettingConnectionPromise
  extends Promise<LoveSettingConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LoveSettingEdge>>() => T;
  aggregate: <T = AggregateLoveSettingPromise>() => T;
}

export interface LoveSettingConnectionSubscription
  extends Promise<AsyncIterator<LoveSettingConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LoveSettingEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLoveSettingSubscription>() => T;
}

export interface PostPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  isPublished: Boolean;
  title: String;
  content: String;
}

export interface PostPreviousValuesPromise
  extends Promise<PostPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  isPublished: () => Promise<Boolean>;
  title: () => Promise<String>;
  content: () => Promise<String>;
}

export interface PostPreviousValuesSubscription
  extends Promise<AsyncIterator<PostPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  isPublished: () => Promise<AsyncIterator<Boolean>>;
  title: () => Promise<AsyncIterator<String>>;
  content: () => Promise<AsyncIterator<String>>;
}

export interface LoveMatchingConnection {
  pageInfo: PageInfo;
  edges: LoveMatchingEdge[];
}

export interface LoveMatchingConnectionPromise
  extends Promise<LoveMatchingConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LoveMatchingEdge>>() => T;
  aggregate: <T = AggregateLoveMatchingPromise>() => T;
}

export interface LoveMatchingConnectionSubscription
  extends Promise<AsyncIterator<LoveMatchingConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LoveMatchingEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLoveMatchingSubscription>() => T;
}

export interface CollegeEntranceExam {
  id: ID_Output;
  subject: String;
  culscore: Float;
  proscore?: Float;
  candidatenum: String;
  times?: Int;
}

export interface CollegeEntranceExamPromise
  extends Promise<CollegeEntranceExam>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  province: <T = ProvincePromise>() => T;
  subject: () => Promise<String>;
  culscore: () => Promise<Float>;
  proscore: () => Promise<Float>;
  candidatenum: () => Promise<String>;
  times: () => Promise<Int>;
  student: <T = UserPromise>() => T;
}

export interface CollegeEntranceExamSubscription
  extends Promise<AsyncIterator<CollegeEntranceExam>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  province: <T = ProvinceSubscription>() => T;
  subject: () => Promise<AsyncIterator<String>>;
  culscore: () => Promise<AsyncIterator<Float>>;
  proscore: () => Promise<AsyncIterator<Float>>;
  candidatenum: () => Promise<AsyncIterator<String>>;
  times: () => Promise<AsyncIterator<Int>>;
  student: <T = UserSubscription>() => T;
}

export interface Logs {
  createFamilyGroupTime?: DateTimeOutput;
}

export interface LogsPromise extends Promise<Logs>, Fragmentable {
  user: <T = UserPromise>() => T;
  createFamilyGroupTime: () => Promise<DateTimeOutput>;
}

export interface LogsSubscription
  extends Promise<AsyncIterator<Logs>>,
    Fragmentable {
  user: <T = UserSubscription>() => T;
  createFamilyGroupTime: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ProductSubscriptionPayload {
  mutation: MutationType;
  node: Product;
  updatedFields: String[];
  previousValues: ProductPreviousValues;
}

export interface ProductSubscriptionPayloadPromise
  extends Promise<ProductSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductPreviousValuesPromise>() => T;
}

export interface ProductSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductPreviousValuesSubscription>() => T;
}

export interface LocationGroupConnection {
  pageInfo: PageInfo;
  edges: LocationGroupEdge[];
}

export interface LocationGroupConnectionPromise
  extends Promise<LocationGroupConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LocationGroupEdge>>() => T;
  aggregate: <T = AggregateLocationGroupPromise>() => T;
}

export interface LocationGroupConnectionSubscription
  extends Promise<AsyncIterator<LocationGroupConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LocationGroupEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLocationGroupSubscription>() => T;
}

export interface ProductPreviousValues {
  id: ID_Output;
  subject?: String;
  info?: String;
  price?: Float;
  kind?: String;
}

export interface ProductPreviousValuesPromise
  extends Promise<ProductPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  subject: () => Promise<String>;
  info: () => Promise<String>;
  price: () => Promise<Float>;
  kind: () => Promise<String>;
}

export interface ProductPreviousValuesSubscription
  extends Promise<AsyncIterator<ProductPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  subject: () => Promise<AsyncIterator<String>>;
  info: () => Promise<AsyncIterator<String>>;
  price: () => Promise<AsyncIterator<Float>>;
  kind: () => Promise<AsyncIterator<String>>;
}

export interface Province {
  id: ID_Output;
  code: String;
  name: String;
}

export interface ProvincePromise extends Promise<Province>, Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<String>;
  name: () => Promise<String>;
  cities: <T = FragmentableArray<City>>(
    args?: {
      where?: CityWhereInput;
      orderBy?: CityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface ProvinceSubscription
  extends Promise<AsyncIterator<Province>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  code: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  cities: <T = Promise<AsyncIterator<CitySubscription>>>(
    args?: {
      where?: CityWhereInput;
      orderBy?: CityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface SchoolEdu {
  id: ID_Output;
  startTime?: DateTimeOutput;
  grade?: Int;
  className?: String;
}

export interface SchoolEduPromise extends Promise<SchoolEdu>, Fragmentable {
  id: () => Promise<ID_Output>;
  school: <T = SchoolPromise>() => T;
  startTime: () => Promise<DateTimeOutput>;
  major: <T = MajorPromise>() => T;
  grade: () => Promise<Int>;
  className: () => Promise<String>;
  students: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface SchoolEduSubscription
  extends Promise<AsyncIterator<SchoolEdu>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  school: <T = SchoolSubscription>() => T;
  startTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  major: <T = MajorSubscription>() => T;
  grade: () => Promise<AsyncIterator<Int>>;
  className: () => Promise<AsyncIterator<String>>;
  students: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface AggregateGroup {
  count: Int;
}

export interface AggregateGroupPromise
  extends Promise<AggregateGroup>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGroupSubscription
  extends Promise<AsyncIterator<AggregateGroup>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProjectSubscriptionPayload {
  mutation: MutationType;
  node: Project;
  updatedFields: String[];
  previousValues: ProjectPreviousValues;
}

export interface ProjectSubscriptionPayloadPromise
  extends Promise<ProjectSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProjectPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProjectPreviousValuesPromise>() => T;
}

export interface ProjectSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProjectSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProjectSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProjectPreviousValuesSubscription>() => T;
}

export interface FindPassWordEdge {
  node: FindPassWord;
  cursor: String;
}

export interface FindPassWordEdgePromise
  extends Promise<FindPassWordEdge>,
    Fragmentable {
  node: <T = FindPassWordPromise>() => T;
  cursor: () => Promise<String>;
}

export interface FindPassWordEdgeSubscription
  extends Promise<AsyncIterator<FindPassWordEdge>>,
    Fragmentable {
  node: <T = FindPassWordSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ProjectPreviousValues {
  id: ID_Output;
  name?: String;
  content?: String;
}

export interface ProjectPreviousValuesPromise
  extends Promise<ProjectPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  content: () => Promise<String>;
}

export interface ProjectPreviousValuesSubscription
  extends Promise<AsyncIterator<ProjectPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  content: () => Promise<AsyncIterator<String>>;
}

export interface FeeSettingConnection {
  pageInfo: PageInfo;
  edges: FeeSettingEdge[];
}

export interface FeeSettingConnectionPromise
  extends Promise<FeeSettingConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FeeSettingEdge>>() => T;
  aggregate: <T = AggregateFeeSettingPromise>() => T;
}

export interface FeeSettingConnectionSubscription
  extends Promise<AsyncIterator<FeeSettingConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FeeSettingEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFeeSettingSubscription>() => T;
}

export interface FamilyGroup {
  id: ID_Output;
  name?: String;
}

export interface FamilyGroupPromise extends Promise<FamilyGroup>, Fragmentable {
  id: () => Promise<ID_Output>;
  father: <T = PersonPromise>() => T;
  mother: <T = PersonPromise>() => T;
  creater: <T = UserPromise>() => T;
  name: () => Promise<String>;
  families: <T = FragmentableArray<Family>>(
    args?: {
      where?: FamilyWhereInput;
      orderBy?: FamilyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  users: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface FamilyGroupSubscription
  extends Promise<AsyncIterator<FamilyGroup>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  father: <T = PersonSubscription>() => T;
  mother: <T = PersonSubscription>() => T;
  creater: <T = UserSubscription>() => T;
  name: () => Promise<AsyncIterator<String>>;
  families: <T = Promise<AsyncIterator<FamilySubscription>>>(
    args?: {
      where?: FamilyWhereInput;
      orderBy?: FamilyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  users: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface FamilyGroupConnection {
  pageInfo: PageInfo;
  edges: FamilyGroupEdge[];
}

export interface FamilyGroupConnectionPromise
  extends Promise<FamilyGroupConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FamilyGroupEdge>>() => T;
  aggregate: <T = AggregateFamilyGroupPromise>() => T;
}

export interface FamilyGroupConnectionSubscription
  extends Promise<AsyncIterator<FamilyGroupConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FamilyGroupEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFamilyGroupSubscription>() => T;
}

export interface ProvinceSubscriptionPayload {
  mutation: MutationType;
  node: Province;
  updatedFields: String[];
  previousValues: ProvincePreviousValues;
}

export interface ProvinceSubscriptionPayloadPromise
  extends Promise<ProvinceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProvincePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProvincePreviousValuesPromise>() => T;
}

export interface ProvinceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProvinceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProvinceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProvincePreviousValuesSubscription>() => T;
}

export interface AggregateCompany {
  count: Int;
}

export interface AggregateCompanyPromise
  extends Promise<AggregateCompany>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCompanySubscription
  extends Promise<AsyncIterator<AggregateCompany>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProvincePreviousValues {
  id: ID_Output;
  code: String;
  name: String;
}

export interface ProvincePreviousValuesPromise
  extends Promise<ProvincePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<String>;
  name: () => Promise<String>;
}

export interface ProvincePreviousValuesSubscription
  extends Promise<AsyncIterator<ProvincePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  code: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface CollegeEntranceExamEdge {
  node: CollegeEntranceExam;
  cursor: String;
}

export interface CollegeEntranceExamEdgePromise
  extends Promise<CollegeEntranceExamEdge>,
    Fragmentable {
  node: <T = CollegeEntranceExamPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CollegeEntranceExamEdgeSubscription
  extends Promise<AsyncIterator<CollegeEntranceExamEdge>>,
    Fragmentable {
  node: <T = CollegeEntranceExamSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Person {
  id: ID_Output;
  name: String;
}

export interface PersonPromise extends Promise<Person>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  user: <T = UserPromise>() => T;
  families: <T = FragmentableArray<Family>>(
    args?: {
      where?: FamilyWhereInput;
      orderBy?: FamilyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  asFather: <T = FragmentableArray<FamilyGroup>>(
    args?: {
      where?: FamilyGroupWhereInput;
      orderBy?: FamilyGroupOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  asMother: <T = FragmentableArray<FamilyGroup>>(
    args?: {
      where?: FamilyGroupWhereInput;
      orderBy?: FamilyGroupOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface PersonSubscription
  extends Promise<AsyncIterator<Person>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  user: <T = UserSubscription>() => T;
  families: <T = Promise<AsyncIterator<FamilySubscription>>>(
    args?: {
      where?: FamilyWhereInput;
      orderBy?: FamilyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  asFather: <T = Promise<AsyncIterator<FamilyGroupSubscription>>>(
    args?: {
      where?: FamilyGroupWhereInput;
      orderBy?: FamilyGroupOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  asMother: <T = Promise<AsyncIterator<FamilyGroupSubscription>>>(
    args?: {
      where?: FamilyGroupWhereInput;
      orderBy?: FamilyGroupOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface ColleagueConnection {
  pageInfo: PageInfo;
  edges: ColleagueEdge[];
}

export interface ColleagueConnectionPromise
  extends Promise<ColleagueConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ColleagueEdge>>() => T;
  aggregate: <T = AggregateColleaguePromise>() => T;
}

export interface ColleagueConnectionSubscription
  extends Promise<AsyncIterator<ColleagueConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ColleagueEdgeSubscription>>>() => T;
  aggregate: <T = AggregateColleagueSubscription>() => T;
}

export interface RegStatusSubscriptionPayload {
  mutation: MutationType;
  node: RegStatus;
  updatedFields: String[];
  previousValues: RegStatusPreviousValues;
}

export interface RegStatusSubscriptionPayloadPromise
  extends Promise<RegStatusSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RegStatusPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RegStatusPreviousValuesPromise>() => T;
}

export interface RegStatusSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RegStatusSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RegStatusSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RegStatusPreviousValuesSubscription>() => T;
}

export interface WorkEdge {
  node: Work;
  cursor: String;
}

export interface WorkEdgePromise extends Promise<WorkEdge>, Fragmentable {
  node: <T = WorkPromise>() => T;
  cursor: () => Promise<String>;
}

export interface WorkEdgeSubscription
  extends Promise<AsyncIterator<WorkEdge>>,
    Fragmentable {
  node: <T = WorkSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface RegStatusPreviousValues {
  id: ID_Output;
  education: Educationkind;
}

export interface RegStatusPreviousValuesPromise
  extends Promise<RegStatusPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  education: () => Promise<Educationkind>;
}

export interface RegStatusPreviousValuesSubscription
  extends Promise<AsyncIterator<RegStatusPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  education: () => Promise<AsyncIterator<Educationkind>>;
}

export interface AggregateUniversity {
  count: Int;
}

export interface AggregateUniversityPromise
  extends Promise<AggregateUniversity>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUniversitySubscription
  extends Promise<AsyncIterator<AggregateUniversity>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Family {
  id: ID_Output;
  relationship: String;
  status: String;
}

export interface FamilyPromise extends Promise<Family>, Fragmentable {
  id: () => Promise<ID_Output>;
  from: <T = UserPromise>() => T;
  to: <T = PersonPromise>() => T;
  relationship: () => Promise<String>;
  spouse: <T = FamilyPromise>() => T;
  status: () => Promise<String>;
}

export interface FamilySubscription
  extends Promise<AsyncIterator<Family>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  from: <T = UserSubscription>() => T;
  to: <T = PersonSubscription>() => T;
  relationship: () => Promise<AsyncIterator<String>>;
  spouse: <T = FamilySubscription>() => T;
  status: () => Promise<AsyncIterator<String>>;
}

export interface StreetConnection {
  pageInfo: PageInfo;
  edges: StreetEdge[];
}

export interface StreetConnectionPromise
  extends Promise<StreetConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<StreetEdge>>() => T;
  aggregate: <T = AggregateStreetPromise>() => T;
}

export interface StreetConnectionSubscription
  extends Promise<AsyncIterator<StreetConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StreetEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStreetSubscription>() => T;
}

export interface RegisterCountSubscriptionPayload {
  mutation: MutationType;
  node: RegisterCount;
  updatedFields: String[];
  previousValues: RegisterCountPreviousValues;
}

export interface RegisterCountSubscriptionPayloadPromise
  extends Promise<RegisterCountSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RegisterCountPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RegisterCountPreviousValuesPromise>() => T;
}

export interface RegisterCountSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RegisterCountSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RegisterCountSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RegisterCountPreviousValuesSubscription>() => T;
}

export interface AggregateSchoolEdu {
  count: Int;
}

export interface AggregateSchoolEduPromise
  extends Promise<AggregateSchoolEdu>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSchoolEduSubscription
  extends Promise<AsyncIterator<AggregateSchoolEdu>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RegisterCountPreviousValues {
  id: ID_Output;
  deviceId?: String;
  createdAt: DateTimeOutput;
}

export interface RegisterCountPreviousValuesPromise
  extends Promise<RegisterCountPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  deviceId: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface RegisterCountPreviousValuesSubscription
  extends Promise<AsyncIterator<RegisterCountPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  deviceId: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface RegisterCountConnection {
  pageInfo: PageInfo;
  edges: RegisterCountEdge[];
}

export interface RegisterCountConnectionPromise
  extends Promise<RegisterCountConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RegisterCountEdge>>() => T;
  aggregate: <T = AggregateRegisterCountPromise>() => T;
}

export interface RegisterCountConnectionSubscription
  extends Promise<AsyncIterator<RegisterCountConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RegisterCountEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRegisterCountSubscription>() => T;
}

export interface Major {
  id: ID_Output;
  name: String;
  category: String;
  education: Educationkind;
}

export interface MajorPromise extends Promise<Major>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  category: () => Promise<String>;
  education: () => Promise<Educationkind>;
}

export interface MajorSubscription
  extends Promise<AsyncIterator<Major>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  category: () => Promise<AsyncIterator<String>>;
  education: () => Promise<AsyncIterator<Educationkind>>;
}

export interface ProvinceConnection {
  pageInfo: PageInfo;
  edges: ProvinceEdge[];
}

export interface ProvinceConnectionPromise
  extends Promise<ProvinceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProvinceEdge>>() => T;
  aggregate: <T = AggregateProvincePromise>() => T;
}

export interface ProvinceConnectionSubscription
  extends Promise<AsyncIterator<ProvinceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProvinceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProvinceSubscription>() => T;
}

export interface SchoolSubscriptionPayload {
  mutation: MutationType;
  node: School;
  updatedFields: String[];
  previousValues: SchoolPreviousValues;
}

export interface SchoolSubscriptionPayloadPromise
  extends Promise<SchoolSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SchoolPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SchoolPreviousValuesPromise>() => T;
}

export interface SchoolSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SchoolSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SchoolSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SchoolPreviousValuesSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface SchoolPreviousValues {
  id: ID_Output;
  name?: String;
  kind?: Educationkind;
}

export interface SchoolPreviousValuesPromise
  extends Promise<SchoolPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  kind: () => Promise<Educationkind>;
}

export interface SchoolPreviousValuesSubscription
  extends Promise<AsyncIterator<SchoolPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  kind: () => Promise<AsyncIterator<Educationkind>>;
}

export interface AggregatePerson {
  count: Int;
}

export interface AggregatePersonPromise
  extends Promise<AggregatePerson>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePersonSubscription
  extends Promise<AsyncIterator<AggregatePerson>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RegStatus {
  id: ID_Output;
  education: Educationkind;
}

export interface RegStatusPromise extends Promise<RegStatus>, Fragmentable {
  id: () => Promise<ID_Output>;
  education: () => Promise<Educationkind>;
  university: <T = UniversityPromise>() => T;
  major: <T = MajorPromise>() => T;
  applicants: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface RegStatusSubscription
  extends Promise<AsyncIterator<RegStatus>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  education: () => Promise<AsyncIterator<Educationkind>>;
  university: <T = UniversitySubscription>() => T;
  major: <T = MajorSubscription>() => T;
  applicants: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface OldColleagueEdge {
  node: OldColleague;
  cursor: String;
}

export interface OldColleagueEdgePromise
  extends Promise<OldColleagueEdge>,
    Fragmentable {
  node: <T = OldColleaguePromise>() => T;
  cursor: () => Promise<String>;
}

export interface OldColleagueEdgeSubscription
  extends Promise<AsyncIterator<OldColleagueEdge>>,
    Fragmentable {
  node: <T = OldColleagueSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface SchoolEduSubscriptionPayload {
  mutation: MutationType;
  node: SchoolEdu;
  updatedFields: String[];
  previousValues: SchoolEduPreviousValues;
}

export interface SchoolEduSubscriptionPayloadPromise
  extends Promise<SchoolEduSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SchoolEduPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SchoolEduPreviousValuesPromise>() => T;
}

export interface SchoolEduSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SchoolEduSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SchoolEduSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SchoolEduPreviousValuesSubscription>() => T;
}

export interface AggregateAdvertisement {
  count: Int;
}

export interface AggregateAdvertisementPromise
  extends Promise<AggregateAdvertisement>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAdvertisementSubscription
  extends Promise<AsyncIterator<AggregateAdvertisement>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SchoolEduPreviousValues {
  id: ID_Output;
  startTime?: DateTimeOutput;
  grade?: Int;
  className?: String;
}

export interface SchoolEduPreviousValuesPromise
  extends Promise<SchoolEduPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  startTime: () => Promise<DateTimeOutput>;
  grade: () => Promise<Int>;
  className: () => Promise<String>;
}

export interface SchoolEduPreviousValuesSubscription
  extends Promise<AsyncIterator<SchoolEduPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  startTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  grade: () => Promise<AsyncIterator<Int>>;
  className: () => Promise<AsyncIterator<String>>;
}

export interface AggregateLoveMatching {
  count: Int;
}

export interface AggregateLoveMatchingPromise
  extends Promise<AggregateLoveMatching>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLoveMatchingSubscription
  extends Promise<AsyncIterator<AggregateLoveMatching>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Post {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  isPublished: Boolean;
  title: String;
  content: String;
}

export interface PostPromise extends Promise<Post>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  isPublished: () => Promise<Boolean>;
  title: () => Promise<String>;
  content: () => Promise<String>;
  author: <T = UserPromise>() => T;
}

export interface PostSubscription
  extends Promise<AsyncIterator<Post>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  isPublished: () => Promise<AsyncIterator<Boolean>>;
  title: () => Promise<AsyncIterator<String>>;
  content: () => Promise<AsyncIterator<String>>;
  author: <T = UserSubscription>() => T;
}

export interface AggregateLocationGroup {
  count: Int;
}

export interface AggregateLocationGroupPromise
  extends Promise<AggregateLocationGroup>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLocationGroupSubscription
  extends Promise<AsyncIterator<AggregateLocationGroup>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SkillSubscriptionPayload {
  mutation: MutationType;
  node: Skill;
  updatedFields: String[];
  previousValues: SkillPreviousValues;
}

export interface SkillSubscriptionPayloadPromise
  extends Promise<SkillSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SkillPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SkillPreviousValuesPromise>() => T;
}

export interface SkillSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SkillSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SkillSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SkillPreviousValuesSubscription>() => T;
}

export interface GroupMessageEdge {
  node: GroupMessage;
  cursor: String;
}

export interface GroupMessageEdgePromise
  extends Promise<GroupMessageEdge>,
    Fragmentable {
  node: <T = GroupMessagePromise>() => T;
  cursor: () => Promise<String>;
}

export interface GroupMessageEdgeSubscription
  extends Promise<AsyncIterator<GroupMessageEdge>>,
    Fragmentable {
  node: <T = GroupMessageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface SkillPreviousValues {
  id: ID_Output;
  name?: String;
}

export interface SkillPreviousValuesPromise
  extends Promise<SkillPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface SkillPreviousValuesSubscription
  extends Promise<AsyncIterator<SkillPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface AggregateFeeSetting {
  count: Int;
}

export interface AggregateFeeSettingPromise
  extends Promise<AggregateFeeSetting>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFeeSettingSubscription
  extends Promise<AsyncIterator<AggregateFeeSetting>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface University {
  id: ID_Output;
  name: String;
  education: Educationkind;
  department?: String;
  location?: String;
  desc?: String;
}

export interface UniversityPromise extends Promise<University>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  education: () => Promise<Educationkind>;
  department: () => Promise<String>;
  location: () => Promise<String>;
  desc: () => Promise<String>;
}

export interface UniversitySubscription
  extends Promise<AsyncIterator<University>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  education: () => Promise<AsyncIterator<Educationkind>>;
  department: () => Promise<AsyncIterator<String>>;
  location: () => Promise<AsyncIterator<String>>;
  desc: () => Promise<AsyncIterator<String>>;
}

export interface FamilyEdge {
  node: Family;
  cursor: String;
}

export interface FamilyEdgePromise extends Promise<FamilyEdge>, Fragmentable {
  node: <T = FamilyPromise>() => T;
  cursor: () => Promise<String>;
}

export interface FamilyEdgeSubscription
  extends Promise<AsyncIterator<FamilyEdge>>,
    Fragmentable {
  node: <T = FamilySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface StationSubscriptionPayload {
  mutation: MutationType;
  node: Station;
  updatedFields: String[];
  previousValues: StationPreviousValues;
}

export interface StationSubscriptionPayloadPromise
  extends Promise<StationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StationPreviousValuesPromise>() => T;
}

export interface StationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StationPreviousValuesSubscription>() => T;
}

export interface AggregateColleague {
  count: Int;
}

export interface AggregateColleaguePromise
  extends Promise<AggregateColleague>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateColleagueSubscription
  extends Promise<AsyncIterator<AggregateColleague>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface StationPreviousValues {
  id: ID_Output;
  code?: String;
  name?: String;
}

export interface StationPreviousValuesPromise
  extends Promise<StationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<String>;
  name: () => Promise<String>;
}

export interface StationPreviousValuesSubscription
  extends Promise<AsyncIterator<StationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  code: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface VillageConnection {
  pageInfo: PageInfo;
  edges: VillageEdge[];
}

export interface VillageConnectionPromise
  extends Promise<VillageConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<VillageEdge>>() => T;
  aggregate: <T = AggregateVillagePromise>() => T;
}

export interface VillageConnectionSubscription
  extends Promise<AsyncIterator<VillageConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<VillageEdgeSubscription>>>() => T;
  aggregate: <T = AggregateVillageSubscription>() => T;
}

export interface Colleague {
  id: ID_Output;
  status: String;
}

export interface ColleaguePromise extends Promise<Colleague>, Fragmentable {
  id: () => Promise<ID_Output>;
  worker: <T = UserPromise>() => T;
  status: () => Promise<String>;
  group: <T = WorkGroupPromise>() => T;
}

export interface ColleagueSubscription
  extends Promise<AsyncIterator<Colleague>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  worker: <T = UserSubscription>() => T;
  status: () => Promise<AsyncIterator<String>>;
  group: <T = WorkGroupSubscription>() => T;
}

export interface WorkGroupSubscriptionPayload {
  mutation: MutationType;
  node: WorkGroup;
  updatedFields: String[];
  previousValues: WorkGroupPreviousValues;
}

export interface WorkGroupSubscriptionPayloadPromise
  extends Promise<WorkGroupSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = WorkGroupPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = WorkGroupPreviousValuesPromise>() => T;
}

export interface WorkGroupSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<WorkGroupSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = WorkGroupSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = WorkGroupPreviousValuesSubscription>() => T;
}

export interface StreetSubscriptionPayload {
  mutation: MutationType;
  node: Street;
  updatedFields: String[];
  previousValues: StreetPreviousValues;
}

export interface StreetSubscriptionPayloadPromise
  extends Promise<StreetSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StreetPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StreetPreviousValuesPromise>() => T;
}

export interface StreetSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StreetSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StreetSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StreetPreviousValuesSubscription>() => T;
}

export interface RegStatusConnection {
  pageInfo: PageInfo;
  edges: RegStatusEdge[];
}

export interface RegStatusConnectionPromise
  extends Promise<RegStatusConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RegStatusEdge>>() => T;
  aggregate: <T = AggregateRegStatusPromise>() => T;
}

export interface RegStatusConnectionSubscription
  extends Promise<AsyncIterator<RegStatusConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RegStatusEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRegStatusSubscription>() => T;
}

export interface StreetPreviousValues {
  id: ID_Output;
  code: String;
  name: String;
}

export interface StreetPreviousValuesPromise
  extends Promise<StreetPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<String>;
  name: () => Promise<String>;
}

export interface StreetPreviousValuesSubscription
  extends Promise<AsyncIterator<StreetPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  code: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePhoto {
  count: Int;
}

export interface AggregatePhotoPromise
  extends Promise<AggregatePhoto>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePhotoSubscription
  extends Promise<AsyncIterator<AggregatePhoto>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface WorkGroup {
  id: ID_Output;
}

export interface WorkGroupPromise extends Promise<WorkGroup>, Fragmentable {
  id: () => Promise<ID_Output>;
  company: <T = CompanyPromise>() => T;
  colleagues: <T = FragmentableArray<Colleague>>(
    args?: {
      where?: ColleagueWhereInput;
      orderBy?: ColleagueOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface WorkGroupSubscription
  extends Promise<AsyncIterator<WorkGroup>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  company: <T = CompanySubscription>() => T;
  colleagues: <T = Promise<AsyncIterator<ColleagueSubscription>>>(
    args?: {
      where?: ColleagueWhereInput;
      orderBy?: ColleagueOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface MessageConnection {
  pageInfo: PageInfo;
  edges: MessageEdge[];
}

export interface MessageConnectionPromise
  extends Promise<MessageConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MessageEdge>>() => T;
  aggregate: <T = AggregateMessagePromise>() => T;
}

export interface MessageConnectionSubscription
  extends Promise<AsyncIterator<MessageConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MessageEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMessageSubscription>() => T;
}

export interface TradeSubscriptionPayload {
  mutation: MutationType;
  node: Trade;
  updatedFields: String[];
  previousValues: TradePreviousValues;
}

export interface TradeSubscriptionPayloadPromise
  extends Promise<TradeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TradePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TradePreviousValuesPromise>() => T;
}

export interface TradeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TradeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TradeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TradePreviousValuesSubscription>() => T;
}

export interface LogsEdge {
  node: Logs;
  cursor: String;
}

export interface LogsEdgePromise extends Promise<LogsEdge>, Fragmentable {
  node: <T = LogsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface LogsEdgeSubscription
  extends Promise<AsyncIterator<LogsEdge>>,
    Fragmentable {
  node: <T = LogsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface TradePreviousValues {
  id: ID_Output;
  number?: Int;
  amount?: Float;
  status?: String;
}

export interface TradePreviousValuesPromise
  extends Promise<TradePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  number: () => Promise<Int>;
  amount: () => Promise<Float>;
  status: () => Promise<String>;
}

export interface TradePreviousValuesSubscription
  extends Promise<AsyncIterator<TradePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  number: () => Promise<AsyncIterator<Int>>;
  amount: () => Promise<AsyncIterator<Float>>;
  status: () => Promise<AsyncIterator<String>>;
}

export interface GroupConnection {
  pageInfo: PageInfo;
  edges: GroupEdge[];
}

export interface GroupConnectionPromise
  extends Promise<GroupConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GroupEdge>>() => T;
  aggregate: <T = AggregateGroupPromise>() => T;
}

export interface GroupConnectionSubscription
  extends Promise<AsyncIterator<GroupConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GroupEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGroupSubscription>() => T;
}

export interface Station {
  id: ID_Output;
  code?: String;
  name?: String;
}

export interface StationPromise extends Promise<Station>, Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<String>;
  name: () => Promise<String>;
}

export interface StationSubscription
  extends Promise<AsyncIterator<Station>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  code: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface CompanyConnection {
  pageInfo: PageInfo;
  edges: CompanyEdge[];
}

export interface CompanyConnectionPromise
  extends Promise<CompanyConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CompanyEdge>>() => T;
  aggregate: <T = AggregateCompanyPromise>() => T;
}

export interface CompanyConnectionSubscription
  extends Promise<AsyncIterator<CompanyConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CompanyEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCompanySubscription>() => T;
}

export interface UniversitySubscriptionPayload {
  mutation: MutationType;
  node: University;
  updatedFields: String[];
  previousValues: UniversityPreviousValues;
}

export interface UniversitySubscriptionPayloadPromise
  extends Promise<UniversitySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UniversityPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UniversityPreviousValuesPromise>() => T;
}

export interface UniversitySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UniversitySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UniversitySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UniversityPreviousValuesSubscription>() => T;
}

export interface TradeEdge {
  node: Trade;
  cursor: String;
}

export interface TradeEdgePromise extends Promise<TradeEdge>, Fragmentable {
  node: <T = TradePromise>() => T;
  cursor: () => Promise<String>;
}

export interface TradeEdgeSubscription
  extends Promise<AsyncIterator<TradeEdge>>,
    Fragmentable {
  node: <T = TradeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UniversityPreviousValues {
  id: ID_Output;
  name: String;
  education: Educationkind;
  department?: String;
  location?: String;
  desc?: String;
}

export interface UniversityPreviousValuesPromise
  extends Promise<UniversityPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  education: () => Promise<Educationkind>;
  department: () => Promise<String>;
  location: () => Promise<String>;
  desc: () => Promise<String>;
}

export interface UniversityPreviousValuesSubscription
  extends Promise<AsyncIterator<UniversityPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  education: () => Promise<AsyncIterator<Educationkind>>;
  department: () => Promise<AsyncIterator<String>>;
  location: () => Promise<AsyncIterator<String>>;
  desc: () => Promise<AsyncIterator<String>>;
}

export interface ProjectConnection {
  pageInfo: PageInfo;
  edges: ProjectEdge[];
}

export interface ProjectConnectionPromise
  extends Promise<ProjectConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProjectEdge>>() => T;
  aggregate: <T = AggregateProjectPromise>() => T;
}

export interface ProjectConnectionSubscription
  extends Promise<AsyncIterator<ProjectConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProjectEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProjectSubscription>() => T;
}

export interface Work {
  id: ID_Output;
  startTime?: DateTimeOutput;
  endTime?: DateTimeOutput;
  department?: String;
  jobContent?: String;
}

export interface WorkPromise extends Promise<Work>, Fragmentable {
  id: () => Promise<ID_Output>;
  startTime: () => Promise<DateTimeOutput>;
  endTime: () => Promise<DateTimeOutput>;
  company: <T = CompanyPromise>() => T;
  department: () => Promise<String>;
  post: <T = StationPromise>() => T;
  jobContent: () => Promise<String>;
  worker: <T = UserPromise>() => T;
}

export interface WorkSubscription
  extends Promise<AsyncIterator<Work>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  startTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  endTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  company: <T = CompanySubscription>() => T;
  department: () => Promise<AsyncIterator<String>>;
  post: <T = StationSubscription>() => T;
  jobContent: () => Promise<AsyncIterator<String>>;
  worker: <T = UserSubscription>() => T;
}

export interface AggregateLoveSetting {
  count: Int;
}

export interface AggregateLoveSettingPromise
  extends Promise<AggregateLoveSetting>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLoveSettingSubscription
  extends Promise<AsyncIterator<AggregateLoveSetting>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateFamilyGroup {
  count: Int;
}

export interface AggregateFamilyGroupPromise
  extends Promise<AggregateFamilyGroup>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFamilyGroupSubscription
  extends Promise<AsyncIterator<AggregateFamilyGroup>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface VillageSubscriptionPayload {
  mutation: MutationType;
  node: Village;
  updatedFields: String[];
  previousValues: VillagePreviousValues;
}

export interface VillageSubscriptionPayloadPromise
  extends Promise<VillageSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = VillagePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = VillagePreviousValuesPromise>() => T;
}

export interface VillageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<VillageSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = VillageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = VillagePreviousValuesSubscription>() => T;
}

export interface Company {
  id: ID_Output;
  name?: String;
  code?: String;
  establishmentDate?: DateTimeOutput;
  representative?: String;
  BusinessScope?: String;
}

export interface CompanyPromise extends Promise<Company>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  code: () => Promise<String>;
  establishmentDate: () => Promise<DateTimeOutput>;
  representative: () => Promise<String>;
  location: <T = LocationPromise>() => T;
  BusinessScope: () => Promise<String>;
  works: <T = FragmentableArray<Work>>(
    args?: {
      where?: WorkWhereInput;
      orderBy?: WorkOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  workGroup: <T = WorkGroupPromise>() => T;
}

export interface CompanySubscription
  extends Promise<AsyncIterator<Company>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  code: () => Promise<AsyncIterator<String>>;
  establishmentDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  representative: () => Promise<AsyncIterator<String>>;
  location: <T = LocationSubscription>() => T;
  BusinessScope: () => Promise<AsyncIterator<String>>;
  works: <T = Promise<AsyncIterator<WorkSubscription>>>(
    args?: {
      where?: WorkWhereInput;
      orderBy?: WorkOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  workGroup: <T = WorkGroupSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  username: String;
  password: String;
  name?: String;
  gender?: String;
  birthdaycalendar?: String;
  birthday?: DateTimeOutput;
  uid: String;
  token: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  regTimes?: Int;
  maxRegTimes?: Int;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  username: () => Promise<String>;
  password: () => Promise<String>;
  name: () => Promise<String>;
  gender: () => Promise<String>;
  birthdaycalendar: () => Promise<String>;
  birthday: () => Promise<DateTimeOutput>;
  uid: () => Promise<String>;
  token: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  regTimes: () => Promise<Int>;
  maxRegTimes: () => Promise<Int>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  username: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<String>>;
  birthdaycalendar: () => Promise<AsyncIterator<String>>;
  birthday: () => Promise<AsyncIterator<DateTimeOutput>>;
  uid: () => Promise<AsyncIterator<String>>;
  token: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  regTimes: () => Promise<AsyncIterator<Int>>;
  maxRegTimes: () => Promise<AsyncIterator<Int>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface Village {
  id: ID_Output;
  code: String;
  name: String;
}

export interface VillagePromise extends Promise<Village>, Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<String>;
  name: () => Promise<String>;
  street: <T = StreetPromise>() => T;
  people: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface VillageSubscription
  extends Promise<AsyncIterator<Village>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  code: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  street: <T = StreetSubscription>() => T;
  people: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface LocationEdge {
  node: Location;
  cursor: String;
}

export interface LocationEdgePromise
  extends Promise<LocationEdge>,
    Fragmentable {
  node: <T = LocationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface LocationEdgeSubscription
  extends Promise<AsyncIterator<LocationEdge>>,
    Fragmentable {
  node: <T = LocationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePartnerCondition {
  count: Int;
}

export interface AggregatePartnerConditionPromise
  extends Promise<AggregatePartnerCondition>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePartnerConditionSubscription
  extends Promise<AsyncIterator<AggregatePartnerCondition>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SchoolEdge {
  node: School;
  cursor: String;
}

export interface SchoolEdgePromise extends Promise<SchoolEdge>, Fragmentable {
  node: <T = SchoolPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SchoolEdgeSubscription
  extends Promise<AsyncIterator<SchoolEdge>>,
    Fragmentable {
  node: <T = SchoolSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point). 
*/
export type Float = number;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Advertisement",
    embedded: false
  },
  {
    name: "Area",
    embedded: false
  },
  {
    name: "BootCount",
    embedded: false
  },
  {
    name: "City",
    embedded: false
  },
  {
    name: "ClassGroup",
    embedded: false
  },
  {
    name: "ClassMate",
    embedded: false
  },
  {
    name: "Colleague",
    embedded: false
  },
  {
    name: "CollegeEntranceExam",
    embedded: false
  },
  {
    name: "Company",
    embedded: false
  },
  {
    name: "Educationkind",
    embedded: false
  },
  {
    name: "Family",
    embedded: false
  },
  {
    name: "FamilyGroup",
    embedded: false
  },
  {
    name: "FeeSetting",
    embedded: false
  },
  {
    name: "FindPassWord",
    embedded: false
  },
  {
    name: "Group",
    embedded: false
  },
  {
    name: "GroupKind",
    embedded: false
  },
  {
    name: "GroupMessage",
    embedded: false
  },
  {
    name: "Location",
    embedded: false
  },
  {
    name: "LocationGroup",
    embedded: false
  },
  {
    name: "LocationGroupKind",
    embedded: false
  },
  {
    name: "Logs",
    embedded: false
  },
  {
    name: "LoveMatching",
    embedded: false
  },
  {
    name: "LoveSetting",
    embedded: false
  },
  {
    name: "LoveSignUp",
    embedded: false
  },
  {
    name: "Major",
    embedded: false
  },
  {
    name: "Message",
    embedded: false
  },
  {
    name: "OldColleague",
    embedded: false
  },
  {
    name: "PartnerCondition",
    embedded: false
  },
  {
    name: "Person",
    embedded: false
  },
  {
    name: "Photo",
    embedded: false
  },
  {
    name: "Post",
    embedded: false
  },
  {
    name: "Product",
    embedded: false
  },
  {
    name: "Project",
    embedded: false
  },
  {
    name: "Province",
    embedded: false
  },
  {
    name: "RegStatus",
    embedded: false
  },
  {
    name: "RegisterCount",
    embedded: false
  },
  {
    name: "School",
    embedded: false
  },
  {
    name: "SchoolEdu",
    embedded: false
  },
  {
    name: "Skill",
    embedded: false
  },
  {
    name: "Station",
    embedded: false
  },
  {
    name: "Street",
    embedded: false
  },
  {
    name: "Trade",
    embedded: false
  },
  {
    name: "University",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "Village",
    embedded: false
  },
  {
    name: "Work",
    embedded: false
  },
  {
    name: "WorkGroup",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
